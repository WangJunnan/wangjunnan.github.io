<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王俊男的技术杂谈</title>
  
  <subtitle>喋喋不休</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangjunnan.github.io/"/>
  <updated>2019-10-11T11:44:26.388Z</updated>
  <id>http://wangjunnan.github.io/</id>
  
  <author>
    <name>王俊男</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sentinel源码解析一</title>
    <link href="http://wangjunnan.github.io/2019/10/11/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%80/"/>
    <id>http://wangjunnan.github.io/2019/10/11/Sentinel源码解析一/</id>
    <published>2019-10-11T11:42:31.000Z</published>
    <updated>2019-10-11T11:44:26.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>Sentinel</code>作为ali开源的一款轻量级流控框架，<strong>主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性</strong>。相比于<code>Hystrix</code>，<code>Sentinel</code>的设计更加简单，在 <code>Sentinel</code>中资源定义和规则配置是分离的，也就是说用户可以先通过<code>Sentinel API</code>给对应的业务逻辑定义资源（埋点），然后在需要的时候再配置规则，通过这种组合方式，极大的增加了<code>Sentinel</code>流控的灵活性。</p><p>引入<code>Sentinel</code>带来的性能损耗非常小。只有在业务单机量级超过25W QPS的时候才会有一些显著的影响（5% - 10% 左右），单机QPS不太大的时候损耗几乎可以忽略不计。</p><p><code>Sentinel</code>提供两种埋点方式:</p><ul><li><code>try-catch</code> 方式（通过 <code>SphU.entry(...)</code>），用户在 catch 块中执行异常处理 / fallback</li><li><code>if-else</code> 方式（通过 <code>SphO.entry(...)</code>），当返回 false 时执行异常处理 / fallback</li></ul><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在此之前，需要先了解一下<code>Sentinel</code>的工作流程<br>在 <code>Sentinel</code> 里面，所有的资源都对应一个资源名称（<code>resourceName</code>），每次资源调用都会创建一个 <code>Entry</code> 对象。<code>Entry</code> 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 <code>SphU API</code> 显式创建。<code>Entry</code> 创建的时候，同时也会创建一系列功能插槽（<code>slot chain</code>），这些插槽有不同的职责，例如默认情况下会创建一下7个插槽：</p><ul><li><code>NodeSelectorSlot</code> 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li><li><code>ClusterBuilderSlot</code> 则用于存储资源的统计信息以及调用者信息，例如该资源的 <code>RT, QPS, thread count</code> 等等，这些信息将用作为多维度限流，降级的依据；</li><li><code>StatisticSlot</code> 则用于记录、统计不同纬度的 <code>runtime</code> 指标监控信息；</li><li><code>FlowSlot</code> 则用于根据预设的限流规则以及前面 <code>slot</code> 统计的状态，来进行流量控制；</li><li><code>AuthoritySlot</code> 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li><code>DegradeSlot</code> 则通过统计信息以及预设的规则，来做熔断降级；</li><li><code>SystemSlot</code> 则通过系统的状态，例如 <code>load1</code> 等，来控制总的入口流量</li></ul><p>注意：这里的插槽链都是一一对应资源名称的</p><p>上面的所介绍的插槽（<code>slot chain</code>）是<code>Sentinel</code>非常重要的概念。同时还有一个非常重要的概念那就是<code>Node</code>，为了帮助理解，尽我所能画了下面这张图，可以看到整个结构非常的像一棵树：</p><p><img src="http://img.souche.com/f2e/f88669970def3f8da53f6488b3a31366.jpg" alt></p><p>简单解释下上图：</p><ul><li>顶部蓝色的<code>node</code>节点为根节点，全局唯一</li><li>下面黄色的节点为入口节点，每个<code>CentextName</code>(上下文名称)一一对应一个<ul><li>可以有多个子节点（对应多种资源）</li></ul></li><li>中间绿色框框中的节点都是属于同一个资源的(相同的<code>ResourceName</code>)</li><li>最底下紫色的节点是集群节点，可以理解成绿色框框中Node资源的整合</li></ul><p>以上2个概念务必要理清楚，之后再一步一步看源码会比较清晰</p><p>下面我们将从入口源码开始一步一步分析整个调用过程：</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>下面的是一个<code>Sentinel</code>使用的示例代码，我们就从这里切入开始分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个名称为entrance1，来源为appA 的上下文Context</span></span><br><span class="line">ContextUtil.enter(<span class="string">"entrance1"</span>, <span class="string">"appA"</span>);</span><br><span class="line"><span class="comment">// 创建一个资源名称nodeA的Entry</span></span><br><span class="line"> Entry nodeA = SphU.entry(<span class="string">"nodeA"</span>);</span><br><span class="line"> <span class="keyword">if</span> (nodeA != <span class="keyword">null</span>) &#123;</span><br><span class="line">    nodeA.exit();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 清除上下文</span></span><br><span class="line"> ContextUtil.exit();</span><br></pre></td></tr></table></figure><h3 id="ContextUtil-enter-“entrance1”-“appA”"><a href="#ContextUtil-enter-“entrance1”-“appA”" class="headerlink" title="ContextUtil.enter(“entrance1”, “appA”)"></a>ContextUtil.enter(“entrance1”, “appA”)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">enter</span><span class="params">(String name, String origin)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断上下文名称是否为默认的名称（sentinel_default_context） 是的话直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.CONTEXT_DEFAULT_NAME.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ContextNameDefineException(</span><br><span class="line">            <span class="string">"The "</span> + Constants.CONTEXT_DEFAULT_NAME + <span class="string">" can't be permit to defined!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trueEnter(name, origin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Context <span class="title">trueEnter</span><span class="params">(String name, String origin)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先从ThreadLocal中尝试获取，获取到则直接返回</span></span><br><span class="line">    Context context = contextHolder.get();</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Map&lt;String, DefaultNode&gt; localCacheNameMap = contextNameNodeMap;</span><br><span class="line">        <span class="comment">// 尝试从缓存中获取该上下文名称对应的 入口节点</span></span><br><span class="line">        DefaultNode node = localCacheNameMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 判断缓存中入口节点数量是否大于2000</span></span><br><span class="line">            <span class="keyword">if</span> (localCacheNameMap.size() &gt; Constants.MAX_CONTEXT_NAME_SIZE) &#123;</span><br><span class="line">                setNullContext();</span><br><span class="line">                <span class="keyword">return</span> NULL_CONTEXT;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加锁</span></span><br><span class="line">                    LOCK.lock();</span><br><span class="line">                    <span class="comment">// 双重检查锁</span></span><br><span class="line">                    node = contextNameNodeMap.get(name);</span><br><span class="line">                    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 判断缓存中入口节点数量是否大于2000</span></span><br><span class="line">                        <span class="keyword">if</span> (contextNameNodeMap.size() &gt; Constants.MAX_CONTEXT_NAME_SIZE) &#123;</span><br><span class="line">                            setNullContext();</span><br><span class="line">                            <span class="keyword">return</span> NULL_CONTEXT;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 根据上下文名称生成入口节点（entranceNode）</span></span><br><span class="line">                            node = <span class="keyword">new</span> EntranceNode(<span class="keyword">new</span> StringResourceWrapper(name, EntryType.IN), <span class="keyword">null</span>);</span><br><span class="line">                            <span class="comment">// 加入至全局根节点下</span></span><br><span class="line">                            Constants.ROOT.addChild(node);</span><br><span class="line">                            <span class="comment">// 加入缓存中</span></span><br><span class="line">                            Map&lt;String, DefaultNode&gt; newMap = <span class="keyword">new</span> HashMap&lt;&gt;(contextNameNodeMap.size() + <span class="number">1</span>);</span><br><span class="line">                            newMap.putAll(contextNameNodeMap);</span><br><span class="line">                            newMap.put(name, node);</span><br><span class="line">                            contextNameNodeMap = newMap;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    LOCK.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化上下文对象</span></span><br><span class="line">        context = <span class="keyword">new</span> Context(node, name);</span><br><span class="line">        context.setOrigin(origin);</span><br><span class="line">        <span class="comment">// 设置到当前线程中</span></span><br><span class="line">        contextHolder.set(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要做了2件事情</p><ol><li>根据<code>ContextName</code>生成<code>entranceNode</code>，并加入缓存，每个<code>ContextName</code>对应一个入口节点<code>entranceNode</code></li><li>根据<code>ContextName</code>和<code>entranceNode</code>初始化上下文对象，并将上下文对象设置到当前线程中</li></ol><p>这里有几点需要注意：</p><ol><li>入口节点数量不能大于2000，大于会直接抛异常</li><li>每个<code>ContextName</code>对应一个入口节点<code>entranceNode</code></li><li>每个<code>entranceNode</code>都有共同的父节点。也就是根节点</li></ol><h3 id="Entry-nodeA-SphU-entry-“nodeA”"><a href="#Entry-nodeA-SphU-entry-“nodeA”" class="headerlink" title="Entry nodeA = SphU.entry(“nodeA”)"></a>Entry nodeA = SphU.entry(“nodeA”)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SphU.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title">entry</span><span class="params">(String name)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="comment">// 默认为 出口流量类型，单位统计数为1</span></span><br><span class="line">    <span class="keyword">return</span> Env.sph.entry(name, EntryType.OUT, <span class="number">1</span>, OBJECTS0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CtSph.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Entry <span class="title">entry</span><span class="params">(String name, EntryType type, <span class="keyword">int</span> count, Object... args)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="comment">// 生成资源对象</span></span><br><span class="line">    StringResourceWrapper resource = <span class="keyword">new</span> StringResourceWrapper(name, type);</span><br><span class="line">    <span class="keyword">return</span> entry(resource, count, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Entry <span class="title">entry</span><span class="params">(ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> entryWithPriority(resourceWrapper, count, <span class="keyword">false</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码比较简单，不指定<code>EntryType</code>的话，则默认为出口流量类型，最终会调用<code>entryWithPriority</code>方法，主要业务逻辑也都在这个方法中</p><ul><li>entryWithPriority方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">entryWithPriority</span><span class="params">(ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程上下文对象</span></span><br><span class="line">    Context context = ContextUtil.getContext();</span><br><span class="line">    <span class="comment">// 上下文名称对应的入口节点是否已经超过阈值2000，超过则会返回空 CtEntry</span></span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> NullContext) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有指定上下文名称，则使用默认名称，也就是默认入口节点</span></span><br><span class="line">        context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局开关</span></span><br><span class="line">    <span class="keyword">if</span> (!Constants.ON) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成插槽链</span></span><br><span class="line">    ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 表示资源(插槽链)超过6000，因此不会进行规则检查。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成 Entry 对象</span></span><br><span class="line">    Entry e = <span class="keyword">new</span> CtEntry(resourceWrapper, chain, context);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 开始执行插槽链 调用逻辑</span></span><br><span class="line">        chain.entry(context, resourceWrapper, <span class="keyword">null</span>, count, prioritized, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e1) &#123;</span><br><span class="line">        <span class="comment">// 清除上下文</span></span><br><span class="line">        e.exit(count, args);</span><br><span class="line">        <span class="keyword">throw</span> e1;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e1) &#123;</span><br><span class="line">        <span class="comment">// 除非Sentinel内部存在错误，否则不应发生这种情况。</span></span><br><span class="line">        RecordLog.info(<span class="string">"Sentinel unexpected exception"</span>, e1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法可以说是涵盖了整个Sentinel的核心逻辑</p><ol><li>获取上下文对象，如果上下文对象还未初始化，则使用默认名称初始化。初始化逻辑在上文已经分析过</li><li>判断全局开关</li><li>根据给定的资源生成插槽链，插槽链是跟资源相关的，Sentinel最关键的逻辑也都在各个插槽中。初始化的逻辑在<code>lookProcessChain(resourceWrapper);</code>中，下文会分析</li><li>依顺序执行每个插槽逻辑</li></ol><h3 id="lookProcessChain-resourceWrapper-方法"><a href="#lookProcessChain-resourceWrapper-方法" class="headerlink" title="lookProcessChain(resourceWrapper)方法"></a>lookProcessChain(resourceWrapper)方法</h3><p><code>lookProcessChain</code>方法为指定资源生成插槽链，下面我们来看下它的初始化逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProcessorSlot&lt;Object&gt; <span class="title">lookProcessChain</span><span class="params">(ResourceWrapper resourceWrapper)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据资源尝试从全局缓存中获取</span></span><br><span class="line">    ProcessorSlotChain chain = chainMap.get(resourceWrapper);</span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 非常常见的双重检查锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            chain = chainMap.get(resourceWrapper);</span><br><span class="line">            <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断资源数是否大于6000</span></span><br><span class="line">                <span class="keyword">if</span> (chainMap.size() &gt;= Constants.MAX_SLOT_CHAIN_SIZE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 初始化插槽链</span></span><br><span class="line">                chain = SlotChainProvider.newSlotChain();</span><br><span class="line">                Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = <span class="keyword">new</span> HashMap&lt;ResourceWrapper, ProcessorSlotChain&gt;(</span><br><span class="line">                    chainMap.size() + <span class="number">1</span>);</span><br><span class="line">                newMap.putAll(chainMap);</span><br><span class="line">                newMap.put(resourceWrapper, chain);</span><br><span class="line">                chainMap = newMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>根据资源尝试从全局缓存中获取插槽链。每个资源对应一个插槽链（资源嘴多只能定义6000个）</li><li>初始化插槽链上的插槽（<code>SlotChainProvider.newSlotChain()</code>方法中）</li></ol><p>下面我们看下初始化插槽链上的插槽的逻辑</p><h3 id="SlotChainProvider-newSlotChain"><a href="#SlotChainProvider-newSlotChain" class="headerlink" title="SlotChainProvider.newSlotChain()"></a>SlotChainProvider.newSlotChain()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessorSlotChain <span class="title">newSlotChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否已经初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (builder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 加载 SlotChain </span></span><br><span class="line">    resolveSlotChainBuilder();</span><br><span class="line">    <span class="comment">// 加载失败则使用默认 插槽链 </span></span><br><span class="line">    <span class="keyword">if</span> (builder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RecordLog.warn(<span class="string">"[SlotChainProvider] Wrong state when resolving slot chain builder, using default"</span>);</span><br><span class="line">        builder = <span class="keyword">new</span> DefaultSlotChainBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建完成</span></span><br><span class="line">    <span class="keyword">return</span> builder.build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java自带 SPI机制 加载 slotChain</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveSlotChainBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;SlotChainBuilder&gt; list = <span class="keyword">new</span> ArrayList&lt;SlotChainBuilder&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> hasOther = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 尝试获取自定义SlotChainBuilder，通过JAVA SPI机制扩展</span></span><br><span class="line">    <span class="keyword">for</span> (SlotChainBuilder builder : LOADER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (builder.getClass() != DefaultSlotChainBuilder.class) &#123;</span><br><span class="line">            hasOther = <span class="keyword">true</span>;</span><br><span class="line">            list.add(builder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasOther) &#123;</span><br><span class="line">        builder = list.get(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未获取到自定义 SlotChainBuilder 则使用默认的</span></span><br><span class="line">        builder = <span class="keyword">new</span> DefaultSlotChainBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RecordLog.info(<span class="string">"[SlotChainProvider] Global slot chain builder resolved: "</span></span><br><span class="line">        + builder.getClass().getCanonicalName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先会尝试获取自定义的<code>SlotChainBuilder</code>来构建插槽链，自定义的<code>SlotChainBuilder</code>可以通过JAVA SPI机制来扩展</li><li>如果未配置自定义的<code>SlotChainBuilder</code>，则会使用默认的<code>DefaultSlotChainBuilder</code>来构建插槽链，<code>DefaultSlotChainBuilder</code>所构建的插槽就是文章开头我们提到的7种<code>Slot</code>。每个插槽都有其对应的职责，各司其职，后面我们会详细分析这几个插槽的源码，及所承担的职责。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章开头的提到的两个点(插槽链和Node)，这是Sentinel的重点，理解这两点对于阅读源码来说事半功倍</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Sentinel&lt;/code&gt;作为ali开源的一款轻量级流控框架，&lt;strong&gt;主要以流量为切入点，从流量控制、熔断降级、系统
      
    
    </summary>
    
      <category term="java框架" scheme="http://wangjunnan.github.io/categories/java%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Sentinel" scheme="http://wangjunnan.github.io/categories/java%E6%A1%86%E6%9E%B6/Sentinel/"/>
    
    
      <category term="并发" scheme="http://wangjunnan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Sentinel" scheme="http://wangjunnan.github.io/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>浅谈常用的限流算法</title>
    <link href="http://wangjunnan.github.io/2019/10/09/%E6%B5%85%E8%B0%88%E5%B8%B8%E7%94%A8%E7%9A%84%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <id>http://wangjunnan.github.io/2019/10/09/浅谈常用的限流算法/</id>
    <published>2019-10-09T02:15:47.000Z</published>
    <updated>2019-10-09T02:18:05.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。今天我们要聊的就是限流（Rate Limit），限流的目的很简单，就是为了保护系统不被瞬时大流量冲垮，<br>限流这个概念我其实很早之前就有去了解过，不过无奈之前工作所接触业务的并发量实在是谈不上限流。目前公司大促峰值QPS在2w往上，自然而然需要用到限流，特别是类似秒杀这种瞬时流量非常大但实际成单率低的业务场景。</p><p>目前比较常用的限流算法有三种</p><ul><li>计数器固定窗口算法</li><li>计数器滑动窗口算法</li><li>漏桶算法</li><li>令牌桶算法</li></ul><h2 id="计数器固定窗口算法"><a href="#计数器固定窗口算法" class="headerlink" title="计数器固定窗口算法"></a>计数器固定窗口算法</h2><p>计数器固定窗口算法是最简单的限流算法，实现方式也比较简单。就是通过维护一个单位时间内的计数值，每当一个请求通过时，就将计数值加1，当计数值超过预先设定的阈值时，就拒绝单位时间内的其他请求。如果单位时间已经结束，则将计数器清零，开启下一轮的计数。</p><p>但是这种实现会有一个问题，举个例子: </p><p>假设我们设定1秒内允许通过的请求阈值是200，如果有用户在时间窗口的最后几毫秒发送了200个请求，紧接着又在下一个时间窗口开始时发送了200个请求，那么这个用户其实在一秒内成功请求了400次，显然超过了阈值但并不会被限流。其实这就是临界值问题，那么临界值问题要怎么解决呢？</p><ul><li>代码实现 – <a href="https://github.com/WangJunnan/learn/blob/master/algorithm/src/main/java/com/walm/learn/algorithm/ratelimit/CounterRateLimit.java" target="_blank" rel="noopener">CounterRateLimit.java</a></li></ul><h2 id="计数器滑动窗口算法"><a href="#计数器滑动窗口算法" class="headerlink" title="计数器滑动窗口算法"></a>计数器滑动窗口算法</h2><p>计数器滑动窗口法就是为了解决上述固定窗口计数存在的问题而诞生，学过TCP协议的同学应该对滑动窗口不陌生，其实还是不太一样的，下文我们要说的滑动窗口是基于时间来划分窗口的。而TCP的滑动窗口指的是能够接受的字节数，并且大小是可变的（拥塞控制）</p><p>滑动窗口是怎么做的？</p><p>前面说了固定窗口存在临界值问题，要解决这种临界值问题，显然只用一个窗口是解决不了问题的。假设我们仍然设定1秒内允许通过的请求是200个，但是在这里我们需要把1秒的时间分成多格，假设分成5格（格数越多，流量过渡越平滑），每格窗口的时间大小是200毫秒，每过200毫秒，就将窗口向前移动一格。为了便于理解，可以看下图<br><img src="http://img.souche.com/f2e/c9acdd415f157334407d233927474513.jpg" alt></p><p>图中将窗口划为5份，每个小窗口中的数字表示在这个窗口中请求数，所以通过观察上图，可知在当前时间快（200毫秒）允许通过的请求数应该是20而不是200（只要超过20就会被限流），因为我们最终统计请求数时是需要把当前窗口的值进行累加，进而得到当前请求数来判断是不是需要进行限流。</p><p>那么滑动窗口限流法是完美的吗？<br>细心观察的我们应该能马上发现问题，<strong>滑动窗口限流法其实就是计数器固定窗口算法的一个变种</strong>。流量的过渡是否平滑依赖于我们设置的<strong>窗口格数也就是统计时间间隔</strong>，格数越多，统计越精确，但是具体要分多少格我们也说不上来呀… </p><ul><li>代码实现 – <a href="https://github.com/WangJunnan/learn/blob/master/algorithm/src/main/java/com/walm/learn/algorithm/ratelimit/SlidingWindowRateLimit.java" target="_blank" rel="noopener">SlidingWindowRateLimit.java</a></li></ul><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>上面所介绍的两种算法都不能非常平滑的过渡，下面就是漏桶算法登场了<br>什么是漏桶算法？<br>漏桶算法以一个常量限制了出口流量速率，因此漏桶算法可以平滑突发的流量。其中漏桶作为流量容器我们可以看做一个FIFO的队列，当入口流量速率大于出口流量速率时，因为流量容器是有限的，当超出流量容器大小时，超出的流量会被丢弃。<br>下图比较形象的说明了漏桶算法的原理，其中水龙头是入口流量，漏桶是流量容器，匀速流出的水是出口流量。<br><img src="http://img.souche.com/f2e/0186f84da43e3286f3d79e3a2f2d538e.jpg" alt></p><p>漏桶算法的特点</p><ul><li>漏桶具有固定容量，出口流量速率是固定常量（流出请求）</li><li>入口流量可以以任意速率流入到漏桶中（流入请求）</li><li><p>如果入口流量超出了桶的容量，则流入流量会溢出（新请求被拒绝）</p></li><li><p>代码实现 – <a href="https://github.com/WangJunnan/learn/blob/master/algorithm/src/main/java/com/walm/learn/algorithm/ratelimit/LeakyBucketRateLimit.java" target="_blank" rel="noopener">LeakyBucketRateLimit.java</a></p></li></ul><p><strong>不过因为漏桶算法限制了流出速率是一个固定常量值，所以漏桶算法不支持出现突发流出流量。但是在实际情况下，流量往往是突发的。</strong></p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法是漏桶算法的改进版，可以支持突发流量。不过与漏桶算法不同的是，令牌桶算法的漏桶中存放的是令牌而不是流量。<br>那么令牌桶算法是怎么突发流量的呢？<br>最开始，令牌桶是空的，我们以恒定速率往令牌桶里加入令牌，令牌桶被装满时，多余的令牌会被丢弃。当请求到来时，会先尝试从令牌桶获取令牌（相当于从令牌桶移除一个令牌），获取成功则请求被放行，获取失败则阻塞活拒绝请求。</p><p><img src="http://img.souche.com/f2e/d6decf371f1085a63bcf925bfcedeeae.jpg" alt></p><p>令牌桶算法的特点</p><ul><li>最多可以存发b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃</li><li>请求到来时，如果令牌桶中少于n个令牌，那么不会删除令牌。该请求会被限流（阻塞活拒绝）</li><li>算法允许最大b(令牌桶大小)个请求的突发</li></ul><p><strong>令牌桶算法限制的是平均流量，因此其允许突发流量（只要令牌桶中有令牌，就不会被限流）</strong></p><ul><li>代码实现 – <a href="https://github.com/WangJunnan/learn/blob/master/algorithm/src/main/java/com/walm/learn/algorithm/ratelimit/TokenBucketRateLimit.java" target="_blank" rel="noopener">TokenBucketRateLimit.java</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，基本把以上4种限流算法的原理都解释清楚了。每种限流算法都有其固定特点，及各自适用的场景，其中计数器算法是其中最简单的，相当于滑动窗口算法的简化版，令牌桶算法相比漏桶算法对资源的利用率更高（允许突发流量）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。今天我们要聊的就是限流（Rate Limit），限流的目的很简单，就是为了保护系
      
    
    </summary>
    
      <category term="算法" scheme="http://wangjunnan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式" scheme="http://wangjunnan.github.io/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="并发" scheme="http://wangjunnan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="算法" scheme="http://wangjunnan.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中时间的表现形式</title>
    <link href="http://wangjunnan.github.io/2019/09/26/JAVA%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"/>
    <id>http://wangjunnan.github.io/2019/09/26/JAVA中时间的表现形式/</id>
    <published>2019-09-26T08:02:02.000Z</published>
    <updated>2019-09-29T02:54:01.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大多数时候我们在表示时间的概念时，可能并不会去特意关注时区这个概念，毕竟在国内时区都是统一的，我们只需要使用默认时区 北京时间 就可以了。是的，在写这篇文章之前，我也没有过多的去关注时区的概念，以及在JAVA中的表现形式。但是因为目前所在的公司是跨境公司，公司主要业务在印度，印度时间跟北京时间显然是不同的。</p><h2 id="时区的概念"><a href="#时区的概念" class="headerlink" title="时区的概念"></a>时区的概念</h2><p>在这之前先说一下时区的概念，以及解释几个专有名词。<br>时区是地球上的区域使用同一个时间定义，整个全球被分成24个时区。所以每差一个时区，区时相差一个小时，相差多少个时区，就相差多少个小时。东边的时区时间比西边的时区时间早。北京时间指的就是东八区的时间。</p><h3 id="UTC时间和本地时间"><a href="#UTC时间和本地时间" class="headerlink" title="UTC时间和本地时间"></a>UTC时间和本地时间</h3><p>UTC时间又称协调世界时，是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间(GMT)。对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。<br><strong>如果时间是以协调世界时（UTC）表示，则在时间后面直接加上一个“Z”（不加空格）。“Z”是协调世界时中0时区的标志。</strong></p><ul><li>UTC偏移量和本地时间<br>例如北京时间的UTC偏移量是 +8，则当UTC时间是 2:00 时，北京时间的 10:00。所以借助于UTC时间，我们可以把全球的时间都统一起来。</li></ul><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>时区可以很好的表示各地的时间，但各个时区的字面时间显示仍然还是不同的，所以我们需要一种方式在来让世界各个角落的时间都有一样的表现形式。这引申出了时间戳，也被称为Unix时间(Unix time)，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。</p><h2 id="Java8中的时间类型"><a href="#Java8中的时间类型" class="headerlink" title="Java8中的时间类型"></a>Java8中的时间类型</h2><p>在JAVA8中，提供了新的时间日期操作类，相对于之前的 Date 类，可以说使用起来方便了许多，下面依次来介绍几个关键类。</p><ul><li>Instant 用来表示时间戳</li><li>LocalDateTime 单纯表示字面时间，不带时区信息。也就是说 <code>LocalDateTime = 2019-09-25 00:00:00</code>，这个时间我们并不知道是北京时间还是东京时间，仅仅用作字面时间</li><li>ZonedDateTime 含有时区信息的时间，类似于北京时间，UTC+8</li></ul><h3 id="它们如何表示时间"><a href="#它们如何表示时间" class="headerlink" title="它们如何表示时间"></a>它们如何表示时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(LocalDateTime.now());</span><br><span class="line">System.out.println(Instant.now());</span><br><span class="line">System.out.println(ZonedDateTime.now());</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">26</span>T14:<span class="number">50</span>:<span class="number">43.741</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">26</span>T06:<span class="number">50</span>:<span class="number">43.742</span>Z</span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">26</span>T14:<span class="number">50</span>:<span class="number">43.803</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure><p>可以看到<br><code>LocalDateTime</code> 会根据UTC时间获取到本地时间显示，但是会把时区信息丢弃<br><code>Instant</code> 则直接表示的UTC世界标准时间<br><code>ZonedDateTime</code> 会根据UTC时间获取到本地时间显示，同时也会显示当前的时区信息</p><p>其实ZonedDateTime 是由 Instant 加上时区信息结合而来，通过ZonedDateTime可以直接获取到Instant时间戳信息</p><h3 id="如何转换"><a href="#如何转换" class="headerlink" title="如何转换"></a>如何转换</h3><p>转换的核心其实都是往时间戳（世界标准时间）靠拢，试想是不是这样？只有转成了标准时间才能转成其他时区的时间</p><ul><li><code>ZonedDateTime</code> <-> <code>Instant</code></-></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zonedDateTime -&gt; instant</span></span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.now();</span><br><span class="line">Instant instant = zonedDateTime.toInstant();</span><br><span class="line"></span><br><span class="line"><span class="comment">// instant -&gt; zonedDateTime 要指定时区信息</span></span><br><span class="line">ZoneId DEFAULT_ZONE_ID = ZoneId.of(<span class="string">"Asia/Shanghai"</span>);</span><br><span class="line">zonedDateTime = instant.atZone(DEFAULT_ZONE_ID);</span><br></pre></td></tr></table></figure><ul><li><code>LocalDateTime</code> <-> <code>Instant</code></-></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalDateTime -&gt; Instant</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">Instant instant = localDateTime.toInstant(ZoneOffset.of(<span class="string">"+08:00"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instant -&gt; ZonedDateTime -&gt; LocalDateTime</span></span><br><span class="line"><span class="comment">// Instant 需要先转换成 ZonedDateTime 再转换成本地时间</span></span><br><span class="line">ZonedDateTime zonedDateTime = instant.atZone(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">localDateTime = zonedDateTime.toLocalDateTime();</span><br></pre></td></tr></table></figure><ul><li><code>LocalDateTime</code> <-> <code>ZonedDateTime</code></-></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalDateTime -&gt; ZonedDateTime 需要指定本地所在时区</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">ZonedDateTime zonedDateTime = localDateTime.atZone(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接转换成本地时间</span></span><br><span class="line">localDateTime = zonedDateTime.toLocalDateTime();</span><br></pre></td></tr></table></figure><p>可以看到，在转换过程中，会频繁的手动指定时区，主要原因是<code>LocalDateTime</code>并不带有时区信息，如果我们要转换成标准时间，就需要手动指定时区。<strong>所以为了避免转换过程中的错误，我们应该尽量使用时间戳来来传输时间。</strong></p><h4 id="与其他api的转换"><a href="#与其他api的转换" class="headerlink" title="与其他api的转换"></a>与其他api的转换</h4><ul><li>Timestamp <-> LocalDateTime</-></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Timestamp -&gt; LocalDateTime</span><br><span class="line">Timestamp timestamp = Timestamp.from(Instant.now());</span><br><span class="line">LocalDateTime localDateTime = timestamp.toLocalDateTime();</span><br><span class="line"></span><br><span class="line">// LocalDateTime -&gt; Timestamp 有两种方式</span><br><span class="line">// 1. 直接按本地默认时区转时区</span><br><span class="line">timestamp = Timestamp.valueOf(localDateTime);</span><br><span class="line">// 2. 指定时区转</span><br><span class="line">timestamp = Timestamp.from(localDateTime.toInstant(ZoneOffset.of(&quot;+08:00&quot;)));</span><br></pre></td></tr></table></figure><ul><li>Date <-> LocalDateTime</-></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Date -&gt; LocalDateTime</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">LocalDateTime localDateTime = date.toInstant().atZone(ZoneId.of(<span class="string">"Asia/Shanghai"</span>)).toLocalDateTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalDateTime -&gt; Date</span></span><br><span class="line">date = Date.from(localDateTime.toInstant(ZoneOffset.of(<span class="string">"+08:00"</span>)));</span><br></pre></td></tr></table></figure><p>更多例子<a href="https://github.com/WangJunnan/walm-common/blob/master/src/main/java/com/walm/common/util/DateTimeUtils.java" target="_blank" rel="noopener">DateTimeUtils.java</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后还是建议操作时间时使用时间戳，这样子没有时区的概念，也就不会产生歧义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;大多数时候我们在表示时间的概念时，可能并不会去特意关注时区这个概念，毕竟在国内时区都是统一的，我们只需要使用默认时区 北京时间 就可以了。是
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://wangjunnan.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring的@Configuration @Bean注解</title>
    <link href="http://wangjunnan.github.io/2019/09/03/Spring%E7%9A%84-Configuration-Bean%E6%B3%A8%E8%A7%A3/"/>
    <id>http://wangjunnan.github.io/2019/09/03/Spring的-Configuration-Bean注解/</id>
    <published>2019-09-03T08:47:31.000Z</published>
    <updated>2019-09-27T05:52:47.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>之前Spring 一直用的xml配置文件比较多，现在发现新公司用的注解比较多。也就是通过定义一个配置类(以@Configuration注解的类)内部在方法上注解 <a href="#"><a href="#">@Bean</a></a> 注解来完成Bean的依赖注入Spring容器。用注解来配置的话，其实就是减少了配置文件的工作，但总体来说代码可读性其实是会下降的。不过也省去了一大堆的xml配置文件</p><h2 id="直接看源码"><a href="#直接看源码" class="headerlink" title="直接看源码"></a>直接看源码</h2><p>下面就从源码层面来看看  通过注解配置有什么不同</p><p>之前有分析过Spring对Bean的解析，<strong>是通过把我们配置的Bean信息抽象成了一个BeanDefiniion对象。这个对象持有了我们配置的Bean的元数据</strong></p><p>那么其实 <a href="#"><a href="#">@Bean</a></a> 的注解的原理也是类似，也是通过将我们配置的Bean信息抽象成一个BeanDefiniion对象</p><p>这里我们分两种情况讨论，一种是 Spring 通过 xml文件配置实现注解配置，一种就是我们现在非常流行的 SpringBoot实现的注解配置。其实两者实现原理一致，只是配置入口略有不同。</p><p>先看 普通 Spring 应用的配置:</p><p>如果我们要在  普通 Spring 应用中实现注解配置。那么我们需要在Spring的配置文件中配置以下几个配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;context:annotation-config&gt;</span><br><span class="line"></span><br><span class="line">&lt;context:component-scan&gt;</span><br></pre></td></tr></table></figure><p>这两个配置的意思是什么呢？</p><p>我们直接看Spring是如何解析这两个标签的吧，通过在<code>META-INF/spring.handlers</code>目录下根据<code>spring.handlers</code>文件可以找到 Context 标签  解析入口类 <code>ContextNamespaceHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"property-placeholder"</span>, <span class="keyword">new</span> PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"property-override"</span>, <span class="keyword">new</span> PropertyOverrideBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"annotation-config"</span>, <span class="keyword">new</span> AnnotationConfigBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"component-scan"</span>, <span class="keyword">new</span> ComponentScanBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"load-time-weaver"</span>, <span class="keyword">new</span> LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"mbean-export"</span>, <span class="keyword">new</span> MBeanExportBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"mbean-server"</span>, <span class="keyword">new</span> MBeanServerBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了上面的解析源码，可以知道annotation-config由AnnotationConfigBeanDefinitionParser解析。component-scan由ComponentScanBeanDefinitionParser解析。这里就是Spring XML 注解配置的入口，下面我们来依次分析这两个解析类干了什么事情？</p><ul><li>ComponentScanBeanDefinitionParser</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</span><br><span class="line"></span><br><span class="line">String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line"></span><br><span class="line">ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line"></span><br><span class="line">ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里扫描了我们配置的 base-package 包下全部 beanDefinitions，并抽象成了 BeanDefinitionHolder类</span></span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将抽象的 beanDefinitions 全部注册进 Spring容器中，注 这里包含了被@Configuration注解的类</span></span><br><span class="line"></span><br><span class="line">registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AnnotationConfigBeanDefinitionParser</li></ul><p>主要逻辑在 AnnotationConfigUtils 工具类的 registerAnnotationConfigProcessors方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Object source = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一些 BeanFactoryPostProcessor 进Spring容器，会在getBean之前全部执行。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一般用来在容器实例化Bean前，对BeanDefinition做修改，或添加新的BeanDefinition等前置修改</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主要逻辑就在这里</span></span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line"></span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register component for the surrounding &lt;context:annotation-config&gt; element.</span></span><br><span class="line"></span><br><span class="line">CompositeComponentDefinition compDefinition = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line"></span><br><span class="line">parserContext.pushContainingComponent(compDefinition);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nest the concrete beans in the surrounding component.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123;</span><br><span class="line"></span><br><span class="line">parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(processorDefinition));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally register the composite component.</span></span><br><span class="line"></span><br><span class="line">parserContext.popAndRegisterContainingComponent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnnotationConfigUtils.class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加支持 annotation-config 配置的一些BeanFactoryPostProcessor 实现类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line"></span><br><span class="line">beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line"></span><br><span class="line">beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Configuration 注解解析</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @Autowired 注解解析</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Required 注解解析</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 JSR-250做支持 解析注解 @Resource @PostConstruct @PreDestroy </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line"></span><br><span class="line">AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"></span><br><span class="line"><span class="string">"Cannot load optional framework class: "</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> beanDefs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 annotation-config 配置其实就是添加了几个 BeanFactoryPostProcessor 实现类，以此来实现 Autowired Configuration @Resource @PostConstruct @PreDestroy 等注解的实现。其他的注解暂且不看，我们直接看今天的重点  Configuration 注解是如何解析，@Configuration是通过 BeanFactoryPostProcessor 的实现类 ConfigurationClassPostProcessor 类在Spring启动的时候执行的（具体BeanFactoryPostProcessor的执行时机可以看我另一篇博文[<a href> <a href="https://www.yuque.com/wangjunnan/pnhnfo/bx15ai" target="_blank" rel="noopener">链接](https://www.yuque.com/wangjunnan/pnhnfo/bx15ai)</a></a>）</p><ul><li>ConfigurationClassPostProcessor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否已经执行过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"></span><br><span class="line"><span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"></span><br><span class="line"><span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正式执行逻辑</span></span><br><span class="line"></span><br><span class="line">processConfigBeanDefinitions(registry);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有 BeanDefinition name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line"></span><br><span class="line">BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否已经处理过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line"></span><br><span class="line">ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 条件筛选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"></span><br><span class="line">configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栓选完为空  直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 @Order 注解排序</span></span><br><span class="line"></span><br><span class="line">configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 BeanName 生成策略</span></span><br><span class="line"></span><br><span class="line">SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line"></span><br><span class="line">sbr = (SingletonBeanRegistry) registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line"></span><br><span class="line">BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse each @Configuration class</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @Configuration 注解</span></span><br><span class="line"></span><br><span class="line">ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line"></span><br><span class="line">Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">parser.parse(candidates);</span><br><span class="line"></span><br><span class="line">parser.validate();</span><br><span class="line"></span><br><span class="line">Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line"></span><br><span class="line">configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取并解析注册 BeanDefinition</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line"></span><br><span class="line">registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line"></span><br><span class="line">alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">candidates.clear();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 处理新加入的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line"></span><br><span class="line">String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line"></span><br><span class="line">alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line"></span><br><span class="line">BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line"></span><br><span class="line">!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line"></span><br><span class="line">candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">candidateNames = newCandidateNames;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span></span><br><span class="line"></span><br><span class="line">((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的执行逻辑在ConfigurationClassParser 类的 parse 方法中</p><ul><li>ConfigurationClassParser</li></ul><p>核心解析方法是 doProcessConfigurationClass方法，下面直接看这个方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line"></span><br><span class="line">processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @PropertySource </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line"></span><br><span class="line">sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line"></span><br><span class="line">org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line"></span><br><span class="line">processPropertySource(propertySource);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">logger.warn(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line"></span><br><span class="line"><span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @ComponentScan </span></span><br><span class="line"></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line"></span><br><span class="line">sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line"></span><br><span class="line">!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line"></span><br><span class="line">BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">bdCand = holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"></span><br><span class="line">parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @Import annotations</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @Import</span></span><br><span class="line"></span><br><span class="line">processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @ImportResource</span></span><br><span class="line"></span><br><span class="line">AnnotationAttributes importResource =</span><br><span class="line"></span><br><span class="line">AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line"></span><br><span class="line">String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line"></span><br><span class="line">configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process individual @Bean methods</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @Bean</span></span><br><span class="line"></span><br><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line"></span><br><span class="line">configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process default methods on interfaces</span></span><br><span class="line"></span><br><span class="line">processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process superclass, if any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line"></span><br><span class="line">String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">"java"</span>) &amp;&amp;</span><br><span class="line"></span><br><span class="line">!<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的代码依次解析了 @PropertySource，@ComponentScan <a href="#"><a href="#">@Bean</a></a> <a href="#"><a href="#">@Import</a></a> 等注解。这里我们重点关注 <a href="#"><a href="#">@Bean</a></a> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取 @bean 注解修饰的  方法元数据信息</span></span><br><span class="line"></span><br><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装成 BeanMethod </span></span><br><span class="line"></span><br><span class="line">configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们回到 ConfigurationClassPostProcessor ，解析完 元数据之后，就是加载注册 BeanDefinition了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">TrackedConditionEvaluator trackedConditionEvaluator = <span class="keyword">new</span> TrackedConditionEvaluator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line"></span><br><span class="line">loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</span><br><span class="line"></span><br><span class="line">String beanName = configClass.getBeanName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.registry.removeBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析之前 解析 @bean 加入的 beanMethod信息</span></span><br><span class="line"></span><br><span class="line">loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line"></span><br><span class="line">loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看 loadBeanDefinitionsForBeanMethod 方法的实现，其实就是从BeanMethod中提取信息组装成 BeanDefinition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForBeanMethod</span><span class="params">(BeanMethod beanMethod)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ConfigurationClass configClass = beanMethod.getConfigurationClass();</span><br><span class="line"></span><br><span class="line">MethodMetadata metadata = beanMethod.getMetadata();</span><br><span class="line"></span><br><span class="line">String methodName = metadata.getMethodName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要跳过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line"></span><br><span class="line">configClass.skippedBeanMethods.add(methodName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (configClass.skippedBeanMethods.contains(methodName)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);</span><br><span class="line"></span><br><span class="line">Assert.state(bean != <span class="keyword">null</span>, <span class="string">"No @Bean annotation attributes"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑别名 名称</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(bean.getStringArray(<span class="string">"name"</span>)));</span><br><span class="line"></span><br><span class="line">String beanName = (!names.isEmpty() ? names.remove(<span class="number">0</span>) : methodName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册别名 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String alias : names) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.registry.registerAlias(beanName, alias);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Has this effectively been overridden before (e.g. via XML)?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否在 xml配置文件中  已经配置过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isOverriddenByExistingDefinition(beanMethod, beanName)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),</span><br><span class="line"></span><br><span class="line">beanName, <span class="string">"Bean name derived from @Bean method '"</span> + beanMethod.getMetadata().getMethodName() +</span><br><span class="line"></span><br><span class="line"><span class="string">"' clashes with bean name for containing configuration class; please make those names unique!"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConfigurationClassBeanDefinition beanDef = <span class="keyword">new</span> ConfigurationClassBeanDefinition(configClass, metadata);</span><br><span class="line"></span><br><span class="line">beanDef.setResource(configClass.getResource());</span><br><span class="line"></span><br><span class="line">beanDef.setSource(<span class="keyword">this</span>.sourceExtractor.extractSource(metadata, configClass.getResource()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里可以知道 @bean 配置是 通过 FactoryMethod 来初始化的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (metadata.isStatic()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static @Bean method</span></span><br><span class="line"></span><br><span class="line">beanDef.setBeanClassName(configClass.getMetadata().getClassName());</span><br><span class="line"></span><br><span class="line">beanDef.setFactoryMethodName(methodName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// instance @Bean method</span></span><br><span class="line"></span><br><span class="line">beanDef.setFactoryBeanName(configClass.getBeanName());</span><br><span class="line"></span><br><span class="line">beanDef.setUniqueFactoryMethodName(methodName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line"></span><br><span class="line">beanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置autowire属性</span></span><br><span class="line"></span><br><span class="line">Autowire autowire = bean.getEnum(<span class="string">"autowire"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (autowire.isAutowire()) &#123;</span><br><span class="line"></span><br><span class="line">beanDef.setAutowireMode(autowire.value());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置initMethod 初始化方法</span></span><br><span class="line"></span><br><span class="line">String initMethodName = bean.getString(<span class="string">"initMethod"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(initMethodName)) &#123;</span><br><span class="line"></span><br><span class="line">beanDef.setInitMethodName(initMethodName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置destroyMethod 销毁方法</span></span><br><span class="line"></span><br><span class="line">String destroyMethodName = bean.getString(<span class="string">"destroyMethod"</span>);</span><br><span class="line"></span><br><span class="line">beanDef.setDestroyMethodName(destroyMethodName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 scope</span></span><br><span class="line"></span><br><span class="line">ScopedProxyMode proxyMode = ScopedProxyMode.NO;</span><br><span class="line"></span><br><span class="line">AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">beanDef.setScope(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line"></span><br><span class="line">proxyMode = attributes.getEnum(<span class="string">"proxyMode"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (proxyMode == ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line"></span><br><span class="line">proxyMode = ScopedProxyMode.NO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace the original bean definition with the target one, if necessary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如有必要，将原始Bean定义替换为目标Bean定义</span></span><br><span class="line"></span><br><span class="line">BeanDefinition beanDefToRegister = beanDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (proxyMode != ScopedProxyMode.NO) &#123;</span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName), <span class="keyword">this</span>.registry,</span><br><span class="line"></span><br><span class="line">proxyMode == ScopedProxyMode.TARGET_CLASS);</span><br><span class="line"></span><br><span class="line">beanDefToRegister = <span class="keyword">new</span> ConfigurationClassBeanDefinition(</span><br><span class="line"></span><br><span class="line">(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"></span><br><span class="line">logger.debug(String.format(<span class="string">"Registering bean definition for @Bean method %s.%s()"</span>,</span><br><span class="line"></span><br><span class="line">configClass.getMetadata().getClassName(), beanName));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.registry.registerBeanDefinition(beanName, beanDefToRegister);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解析到这里为止，@Bean配置的Bean信息就被全部抽象成了一个 BeanDefinition对象，接下来的Bean加载等等一大堆逻辑走的就是Spring的同一套逻辑了。</p><p>以上是通过在配置文件中配置 <code>&lt;context:annotation-config&gt; &lt;context:component-scan&gt;</code>。</p><h2 id="Springboot怎么做的"><a href="#Springboot怎么做的" class="headerlink" title="Springboot怎么做的"></a>Springboot怎么做的</h2><p>那么Spring Boot并不需要配置文件，它又是在哪里配置了入口呢？</p><p>其实在之前的分析Spring boot的启动过程时 已经有提到了 <a href="https://www.yuque.com/wangjunnan/pnhnfo/qtapgd" target="_blank" rel="noopener"><a href="https://www.yuque.com/wangjunnan/pnhnfo/qtapgd" target="_blank" rel="noopener">链接</a></a> ，其实是在初始化 Spring容器的构造方法中进行了配置的加载，并且最终也是调用了 AnnotationConfigUtils 工具类的 registerAnnotationConfigProcessors方法</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>终于写完了，其实分析来分析去，不论是Spring Boot Spring mvc 其实最核心不变的还是 Spring Framework，只要把核心搞清楚了，下次Spring 又推出什么 Spring xxx 也能应付自如</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;之前Spring 一直用的xml配置文件比较多，现在发现新公司用的注解比较多。也就是通过定义一个配置类(以@Configuration注解的
      
    
    </summary>
    
      <category term="Spring" scheme="http://wangjunnan.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://wangjunnan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>MVC-HttpRequestHandler接口静态资源的关系</title>
    <link href="http://wangjunnan.github.io/2019/08/30/MVC-HttpRequestHandler%E6%8E%A5%E5%8F%A3%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://wangjunnan.github.io/2019/08/30/MVC-HttpRequestHandler接口静态资源的关系/</id>
    <published>2019-08-30T08:10:15.000Z</published>
    <updated>2019-09-27T05:52:47.704Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring Mvc，一般我们都会配置对静态资源的拦截，因为静态资源处理有别与普通请求，需要进行特殊配置。</p><p>比较常用的配置有这几种</p><ol><li>Tomcat defaultServelt 激活tomcat自带的defaultServelt 用来处理静态资源</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.js<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.css<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>&lt;mvc:resources/&gt;</code> Spring mvc自己提供的静态资源处理器</li></ol><p>例如做如下配置，就可以将<code>static</code>开头的路径全部访问至<code>static</code>目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/static/**"</span> <span class="attr">location</span>=<span class="string">"/static/"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>那么这个配置的实现原理是什么？</p><p>通过阅读源码其实可以知道实际上是 Spring mvc 自动帮我们注册了一个<code>SimpleUrlHandlerMapping</code>，在之前分析<code>SimpleUrlHandlerMapping</code>时也有提到它其实可以当成拦截器用，这里其实就是一个实例。注册了<code>HandlerMapping</code>必然要确定<code>handler</code>处理器，这里的<code>handler</code>处理器其实就是<code>HttpRequestHandler</code>接口的实现类（ResourceHttpRequestHandler）</p><ol start="3"><li>使用 <code>&lt;mvc:default-servlet-handler/&gt;</code> 激活Spring mvc提供的默认静态资源处理器</li></ol><p>使用这个配置其实原理与第二个配置非常相似，也是利用了<code>SimpleUrlHandlerMapping</code>，并且<code>handler</code>处理器也是<code>HttpRequestHandler</code>接口的实现类，只是把具体的实现类换成了<code>DefaultServletHttpRequestHandler</code>，相比第二种配置，此种配置无法自定义。</p><ul><li>写在后面</li></ul><p>不过我们要是使用Spring boot开发，也就省去了这一堆繁琐的配置，包括静态资源的配置也都是自动完成配置。只要按照约定将静态资源放置在classpath下的这几个目录下（<code>public</code>,<code>resource</code>,<code>static</code>），就不需要任何配置，不得不说，约定优于配置还是可以极大的提升开发效率的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Spring Mvc，一般我们都会配置对静态资源的拦截，因为静态资源处理有别与普通请求，需要进行特殊配置。&lt;/p&gt;
&lt;p&gt;比较常用的配置有这几种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Tomcat defaultServelt 激活tomcat自带的defaultServelt 用来
      
    
    </summary>
    
      <category term="Spring" scheme="http://wangjunnan.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://wangjunnan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>手写一个starter</title>
    <link href="http://wangjunnan.github.io/2019/08/28/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAstarter/"/>
    <id>http://wangjunnan.github.io/2019/08/28/手写一个starter/</id>
    <published>2019-08-28T08:47:15.000Z</published>
    <updated>2019-09-29T09:27:51.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前文说过，<code>Spring Boot</code>最大的优势在于自动配置，我么只需要引入一个个第三方提供的<code>starter</code>就可以快速集成第三方功能，既然<code>starter</code>这么方便，我们自己应该也可以写一个。</p><h2 id="快速写一个starter"><a href="#快速写一个starter" class="headerlink" title="快速写一个starter"></a>快速写一个starter</h2><ul><li>新建一个maven项目</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.walm&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;boot-test-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><ul><li>新建一个config类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">HelloWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新建一个提供服务的service类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最重要的是一步，需要让spring能够扫描到我们的 config HelloWorldConfig 类<ul><li>在resource 文件夹下新建一个 META-INF 文件夹</li><li>新建一个 spring.factories 文件</li></ul></li></ul><p>在spring.factories文件中配置我们的写的HelloWorldConfig类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.walm.boottest.HelloWorldConfig</span><br></pre></td></tr></table></figure><p>这样一个简单的 springboot  starter 就完成了，最后本地安装 install我们的starter jar包就可以在其他项目中引用了</p><ul><li>引用starter，只需要在项目引用 该jar包即可</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.walm&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;boot-test-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>下面我们简单分析一下 stater的原理</p><h2 id="starter-自动配置原理"><a href="#starter-自动配置原理" class="headerlink" title="starter 自动配置原理"></a>starter 自动配置原理</h2><p>首先自动配置的原理关键一定是在 spring.factories 文件是如何被加载到的这个点上去探究</p><p>需要从spring boot的启动过程一步一步的去看了</p><p>首先，我们启动一个spring-boot项目，肯定会有一个配置注解 <code>SpringBootApplication</code> 那么这个注解到底起什么作用呢？</p><ul><li>SpringBootApplication.class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration.class)</span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration.class)</span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base packages to scan for annotated components. Use &#123;<span class="doctag">@link</span> #scanBasePackageClasses&#125;</span></span><br><span class="line"><span class="comment"> * for a type-safe alternative to String-based package names.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> base packages to scan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">"basePackages"</span>)</span><br><span class="line">String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Type-safe alternative to &#123;<span class="doctag">@link</span> #scanBasePackages&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment"> * scan for annotated components. The package of each class specified will be scanned.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Consider creating a special no-op marker class or interface in each package that</span></span><br><span class="line"><span class="comment"> * serves no purpose other than being referenced by this attribute.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> base packages to scan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">"basePackageClasses"</span>)</span><br><span class="line">Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里着重看 EnableAutoConfiguration 这个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 @Import(AutoConfigurationImportSelector.class)这个注解，这里就是我们自动配置的入口<br>注意，解析Import注解其实是通过 BeanFactoryPostProcessor 接口来扩展的</p><p>下面我们来看下AutoConfigurationImportSelector.class 类的实现，AutoConfigurationImportSelector 实现了ImportSelector接口</p><ul><li>ImportSelector</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解析import注解的时候会调用指定ImportSelector 接口实现 的 selectImports方法。下面我们看下AutoConfigurationImportSelector的 selectImports方法实现</p><ul><li>selectImports</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// 获取  META-INF/spring.factories  文件中的配置信息</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">attributes);</span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写一个starter还是非常简单的，核心就是要让springboot自动扫描到我们的 配置类，核心逻辑其实就是通过扫描我们的自定义的META-INF/spring.factories文件来进行自动配置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;前文说过，&lt;code&gt;Spring Boot&lt;/code&gt;最大的优势在于自动配置，我么只需要引入一个个第三方提供的&lt;code&gt;starter
      
    
    </summary>
    
      <category term="Spring" scheme="http://wangjunnan.github.io/categories/Spring/"/>
    
      <category term="SpringBoot" scheme="http://wangjunnan.github.io/categories/Spring/SpringBoot/"/>
    
    
      <category term="Spring" scheme="http://wangjunnan.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://wangjunnan.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的启动过程</title>
    <link href="http://wangjunnan.github.io/2019/08/27/SpringBoot%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://wangjunnan.github.io/2019/08/27/SpringBoot的启动过程/</id>
    <published>2019-08-27T08:44:29.000Z</published>
    <updated>2019-09-29T09:32:00.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在我之前写的文章中有详细分析过<code>Spring</code>的启动过程，如何大家有深入阅读过<code>Spring Framework</code>的核心源码，那么阅读<code>Spring Boot</code>的源码会比较轻松。个人觉得<code>Spring Boot</code>核心的东西比较少，其核心还是<code>Spring Framework</code>。</p><h2 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h2><p>还是一步到位，直接看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 统计启动时间</span></span><br><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置 java.awt.headless 参数</span></span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 获取监听器</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">args);</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">            <span class="comment">// 创建 context容器</span></span><br><span class="line">context = createApplicationContext();</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">SpringBootExceptionReporter.class,</span><br><span class="line"><span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">            <span class="comment">// 准备容器</span></span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">printedBanner);</span><br><span class="line">            <span class="comment">// 刷新容器</span></span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>createApplicationContext<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line"><span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"Unable create a default ApplicationContext, "</span></span><br><span class="line">+ <span class="string">"please specify an ApplicationContextClass"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 这里会引入一些BeanFactoryProcess，比如 ConfigurationClassPostProcessor 解析Configuration注解的</span></span><br><span class="line"><span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注: 引入的BeanFactoryProcess 的逻辑在DEFAULT_SERVLET_WEB_CONTEXT_CLASS的构造方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看下 AnnotationConfigServletWebServerApplicationContext 的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigServletWebServerApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相当于xml中配置了 &lt;context:annotation-config&gt;</span></span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 相当于xml中配置了 &lt;context:component-scan&gt;</span></span><br><span class="line"><span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在看下 AnnotatedBeanDefinitionReader 的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@code</span> AnnotatedBeanDefinitionReader&#125; for the given registry and using</span></span><br><span class="line"><span class="comment"> * the given &#123;<span class="doctag">@link</span> Environment&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the &#123;<span class="doctag">@code</span> BeanFactory&#125; to load bean definitions into,</span></span><br><span class="line"><span class="comment"> * in the form of a &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> environment the &#123;<span class="doctag">@code</span> Environment&#125; to use when evaluating bean definition</span></span><br><span class="line"><span class="comment"> * profiles.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line">Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">Assert.notNull(environment, <span class="string">"Environment must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.registry = registry;</span><br><span class="line"><span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 在这里 注册了一堆的 BeanFactoryProcess </span></span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面主要prepareContext和refreshContext方法</p><ul><li>prepareContext</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">applyInitializers(context);</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">context.getBeanFactory().registerSingleton(<span class="string">"springApplicationArguments"</span>,</span><br><span class="line">applicationArguments);</span><br><span class="line"><span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">context.getBeanFactory().registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the sources</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">        <span class="comment">// 这里引入了 启动类</span></span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注： 这里的主要作用就是引入了启动类，加入到 BeanFactory中</strong></p><ul><li>refreshContext<ul><li>后面其实 就是 Spring 统一的一套了</li><li>可以看我的之前写的 Spring 源码解析系列</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Springboot的核心在于自动配置 快速集成 。一些原本需要在Spring xml文件配置的东西，Spring 只需要一个注解就帮我们都做了。不过前文也都说了，核心还是 Spring Framework。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在我之前写的文章中有详细分析过&lt;code&gt;Spring&lt;/code&gt;的启动过程，如何大家有深入阅读过&lt;code&gt;Spring Framewo
      
    
    </summary>
    
      <category term="Spring" scheme="http://wangjunnan.github.io/categories/Spring/"/>
    
      <category term="SpringBoot" scheme="http://wangjunnan.github.io/categories/Spring/SpringBoot/"/>
    
    
      <category term="Spring" scheme="http://wangjunnan.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://wangjunnan.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MVC源码解析-HandlerAdapter</title>
    <link href="http://wangjunnan.github.io/2019/08/25/MVC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-HandlerAdapter/"/>
    <id>http://wangjunnan.github.io/2019/08/25/MVC源码解析-HandlerAdapter/</id>
    <published>2019-08-25T08:08:54.000Z</published>
    <updated>2019-09-27T05:52:47.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上篇文章分析了<code>handerMapping</code>的实现。本篇文章会继续分析和<code>handerMapping</code>相辅相成的<code>handerAdapter</code>。</p><p><strong>什么是<code>handerAdapter</code>？</strong><br>在理解了<code>handerMapping</code>的基础上，我们应该发现了一个问题。就是每个<code>handerMapping</code>所匹配的到的hander实现是不一样的。比如<code>RequestMappingHandlerMapping</code>的hander的实现是一个<code>HandlerMethod</code>实现，而<code>BeanNameUrlHandlerMapping</code>的hander则是一个<code>Controller</code>接口实现类。所以如果我们要是不引入<code>handerAdapter</code>的话，就无法统一的去执行各自的hander</p><p>上文所说<code>handerAdapter</code>和<code>handerMapping</code>是相辅相成的。以下列出了几个的对应关系</p><ul><li><code>RequestMappingHandlerMapping</code> -&gt; <code>RequestMappingHandlerAdapter</code></li><li><code>BeanNameUrlHandlerMapping</code> -&gt; <code>SimpleControllerHandlerAdapter</code></li><li><code>SimpleUrlHandlerMapping</code> -&gt; <code>SimpleControllerHandlerAdapter</code></li><li><code>SimpleUrlHandlerMapping</code> -&gt; <code>HttpRequestHandlerAdapter</code></li></ul><p>其中<code>SimpleUrlHandlerMapping</code>比较特殊，可以对应多个<code>Adapter</code>，主要原因是<code>SimpleUrlHandlerMapping</code>中的<code>handler</code>类型也可以有多种，比较常见的有<code>Controller</code>接口实现类，<code>HttpRequestHandler</code>接口实现类。</p><h2 id="HandlerAdapter接口"><a href="#HandlerAdapter接口" class="headerlink" title="HandlerAdapter接口"></a>HandlerAdapter接口</h2><p>先看下HandlerAdapter接口的几个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 判断指定hander是否可以被当前Adapter支持</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler handler object to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether or not this object can use the given handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行hander方法</span></span><br><span class="line"><span class="comment"> * returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ModelAndView object with the name of the view and the required</span></span><br><span class="line"><span class="comment"> * model data, or &#123;<span class="doctag">@code</span> null&#125; if the request has been handled directly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与HttpServlet的&#123;<span class="doctag">@code</span> getLastModified&#125;方法的约定相同</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler handler to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the lastModified value for the given handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> javax.servlet.http.HttpServlet#getLastModified</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.servlet.mvc.LastModified#getLastModified</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是<code>supports</code>和<code>hander</code>方法</p><ol><li><code>supports</code>用于判断指定hander是否可以被当前Adapter支持</li><li><code>hander</code>方法用于执行指定的hander的核心逻辑</li></ol><p>下面简单来看下各个HandlerAdapter接口的实现类，看一下对这两个核心方法的实现</p><h2 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h2><ul><li>supports</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法比较简单，判断<code>handler</code>的类型是不是<code>HandlerMethod</code>，如果是的话，则说明该handler可以被该adapter所适配，那么就会直接返回该Adapter。</p><ul><li>hander</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">protected ModelAndView handleInternal(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">// 定义 ModelAndView</span><br><span class="line">ModelAndView mav;</span><br><span class="line">checkRequest(request);</span><br><span class="line"></span><br><span class="line">// 处于一个session时判断是否需要同步</span><br><span class="line">if (this.synchronizeOnSession) &#123;</span><br><span class="line">// 获取当前session</span><br><span class="line">HttpSession session = request.getSession(false);</span><br><span class="line">if (session != null) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">synchronized (mutex) &#123;</span><br><span class="line">   // 执行 handerMethod 实际逻辑</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// No HttpSession available -&gt; no mutex necessary</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// </span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">prepareResponse(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleControllerHandlerAdapter"><a href="#SimpleControllerHandlerAdapter" class="headerlink" title="SimpleControllerHandlerAdapter"></a>SimpleControllerHandlerAdapter</h2><ul><li>supports</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否是handler的类型是否是Controller</p><ul><li>handler</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的话，则直接执行Controller的handleRequest方法</p><h2 id="HttpRequestHandlerAdapter"><a href="#HttpRequestHandlerAdapter" class="headerlink" title="HttpRequestHandlerAdapter"></a>HttpRequestHandlerAdapter</h2><ul><li>supports</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpRequestHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>handler</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">((HttpRequestHandler) handler).handleRequest(request, response);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现逻辑与<code>SimpleControllerHandlerAdapter</code>类似</p><p>对于以上几个Adapter的匹配顺序，Spring会根据各个Adapter的Order值来进行排序，依次匹配直到找到合适的为止。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>HandlerAdapter</code>的核心逻辑就是承接不同的<code>HandlerMapping</code>做适配。本身的逻辑并不复杂，其引入的适配中间层设计模式是一个非常好的案例。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;上篇文章分析了&lt;code&gt;handerMapping&lt;/code&gt;的实现。本篇文章会继续分析和&lt;code&gt;handerMapping&lt;/co
      
    
    </summary>
    
      <category term="Spring" scheme="http://wangjunnan.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://wangjunnan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>MVC源码解析-HandlerMapping</title>
    <link href="http://wangjunnan.github.io/2019/08/20/MVC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-HandlerMapping/"/>
    <id>http://wangjunnan.github.io/2019/08/20/MVC源码解析-HandlerMapping/</id>
    <published>2019-08-20T08:07:09.000Z</published>
    <updated>2019-09-27T05:52:47.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>什么是Spring mvc 的 HanderMapping? </strong><br>**<br>我们知道当一个http请求到服务器时，我们需要根据请求的上下文url来匹配到对应的处理类，而HanderMapping做的就是这个事情，它定义了我们的请求和对应的处理类的映射关系。</p><p>Spring mvc提供了多种HanderMapping类型，比较常用的有 <code>RequestMappingHandlerMapping</code>,<code>BeanNameUrlHandlerMapping</code>,<code>SimpleUrlHandlerMapping</code></p><p>以下是这三个HanderMapping的继承结构：<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/149106/1568030225719-c9a755b8-c582-4c6d-8373-b7b078b6ad0b.jpeg#align=left&amp;display=inline&amp;height=528&amp;name=15680101158745.jpg&amp;originHeight=528&amp;originWidth=689&amp;size=67913&amp;status=done&amp;width=689" alt="15680101158745.jpg"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/149106/1568030238662-c338cb95-bf09-4657-bbeb-8dd96897e59f.jpeg#align=left&amp;display=inline&amp;height=624&amp;name=15680196478301.jpg&amp;originHeight=624&amp;originWidth=672&amp;size=70420&amp;status=done&amp;width=672" alt="15680196478301.jpg"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/149106/1568030249196-ed212f57-bff0-47ba-8dd6-f8fc907b3d33.jpeg#align=left&amp;display=inline&amp;height=571&amp;name=15680196756855.jpg&amp;originHeight=571&amp;originWidth=634&amp;size=59515&amp;status=done&amp;width=634" alt="15680196756855.jpg"></p><p>先来看一下这几个HandlerMapping的配置入口，如果是普通Spring Mvc应用的话，当我们在配置文件中配置了<code>annotation-driven</code>后，便会自动帮我们注入这几个类。具体的源码入口在<code>AnnotationDrivenBeanDefinitionParser</code>中，这里的逻辑非常简单，就是帮我们自动注入这几个常用类的<code>BeanDefinition</code>元数据（包括HandlerMapping，handlerAdapter，ExceptionResolver等等）</p><p>下面通过阅读源码依次分别看一下这几个HanderMapping的作用及实现原理</p><h2 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h2><p>我们先来看下 RequestMappingHandlerMapping 的用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestAPI &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/api/sayHello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value = &quot;/api/sayHello2&quot;)</span><br><span class="line">    public String hello2() &#123;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码，这是一个我们非常常用的用法，一个<code>Controller</code>定义多个处理方法，并且在方法上注解RequestMapping，如此做之后就可以实现一个<code>Controller</code>根据不同的路径分别可以处理多个请求。下面我们来看下其实现原理。<br>我比较好奇的是，<code>RequestMappingHandlerMapping</code>是如何将请求路径与处理方法进行初始化映射的？</p><p>通过观察<code>RequestMappingHandlerMapping</code>的继承体系，可以知道其实现了<code>InitializingBean</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">initHandlerMethods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 HandlerMethods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Looking for request mappings in application context: "</span> + getApplicationContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取容器中所有的Bean</span></span><br><span class="line">String[] beanNames = (<span class="keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</span><br><span class="line">BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :</span><br><span class="line">obtainApplicationContext().getBeanNamesForType(Object.class));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// An unresolvable bean type, probably from a lazy bean - let's ignore it.</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Could not resolve target class for bean with name '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断该Bean是否被 @Controller 或则 @RequestMapping 所注解</span></span><br><span class="line"><span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line"><span class="comment">// 初始化 HandlerMethods</span></span><br><span class="line">detectHandlerMethods(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要做了3件事情</p><ol><li>获取容器中所有的Bean</li><li>筛选出被<a href>@Controller </a> 或则 <a href>@RequestMapping </a> 所注解的Bean</li><li>根据筛选出的Bean初始化HandlerMethod</li></ol><p>可以看到这里有一个很重要的类叫做HandlerMethod，我们来看看这个类的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 目标Bean **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; beanType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对应的目标方法 **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method bridgedMethod;</span><br><span class="line"><span class="comment">/** 方法参数类型 **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MethodParameter[] parameters;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HttpStatus responseStatus;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String responseStatusReason;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HandlerMethod resolvedFromHandlerMethod;</span><br><span class="line"></span><br><span class="line">... 还提供了很多方法，像获取方法返回值等等</span><br></pre></td></tr></table></figure><p>对于这个类我们现在可以不用深入去理解，只需知道它封装了处理类的目标方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line">Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line"><span class="comment">// 获取目标Bean中被RequestMapping注解的方法</span></span><br><span class="line">Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">userType.getName() + <span class="string">"]: "</span> + method, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(methods.size() + <span class="string">" request handler methods found on "</span> + userType + <span class="string">": "</span> + methods);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册 HandlerMethod</span></span><br><span class="line">methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要做了两件事情</p><ol><li>获取目前Bean中被RequestMapping注解的方法</li><li>把获取到的Method 封装成HandlerMethod并完成注册</li></ol><p>到这里为止<code>RequestMappingHandlerMapping</code>就完成初始化了，下面再来看下当一个请求来时其实如何处理的，并选择正确的 HandlerMethod 处理的.</p><p><strong>当一个请求进来时，DispatcherServlet会分别调用每个HandlerMapping的getHandler的方法，直到有个HandlerMapping返回了一个hander</strong></p><p><code>getHandler方法</code>在抽象父类<code>AbstractHandlerMapping.class</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 具体调用逻辑，由子类实现</span></span><br><span class="line">Object handler = getHandlerInternal(request);</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">handler = getDefaultHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line"><span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">CorsConfiguration globalConfig = <span class="keyword">this</span>.globalCorsConfigSource.getCorsConfiguration(request);</span><br><span class="line">CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">CorsConfiguration config = (globalConfig != <span class="keyword">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看<code>RequestMappingHandlerMapping</code>的<code>getHandlerInternal</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 根据 request获取到 path</span></span><br><span class="line"><span class="comment">// 如请求是 localhost:8080/api/sayHello</span></span><br><span class="line"><span class="comment">// 则这里返回  /api/sayHello</span></span><br><span class="line">String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Looking up handler method for path "</span> + lookupPath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 获取到请求对应的 handlerMethod </span></span><br><span class="line">HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (handlerMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">logger.debug(<span class="string">"Returning handler method ["</span> + handlerMethod + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">"Did not find handler method for ["</span> + lookupPath + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<code>RequestMappingHandlerMapping</code>在整个MVC流程中所起的作用</p><h2 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h2><p>下面我们再简单看下<code>BeanNameUrlHandlerMapping</code>的使用和原理<br>顾名思义，<code>BeanNameUrlHandlerMapping</code>就是指通过BeanName和Url进行关联匹配，跟<code>RequestMappingHandlerMapping</code>不一样，<code>BeanNameUrlHandlerMapping</code>一个Bean就对应处理一个请求.<br>先来看个使用的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;/test2API&quot;)</span><br><span class="line">public class Test2API implements Controller &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;test2API&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此定义一个类，我们便能通过<code>/test2API</code>这个路径来访问这个类。<br>如何实现的？我们还是打开<code>BeanNameUrlHandlerMapping</code>看看其实现，与<code>RequestMappingHandlerMapping</code>不同的是，它没有实现<code>InitializingBean</code>接口，不过它实现了<code>ApplicationContextAware</code>接口，在Spring容器完成初始化的时候回调用这个唤醒接口，也就是在这里进行了<code>BeanNameUrlHandlerMapping</code>的初始化。</p><p>初始化逻辑在 AbstractDetectingUrlHandlerMapping.detectHandlers() 方法中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected void detectHandlers() throws BeansException &#123;</span><br><span class="line">ApplicationContext applicationContext = obtainApplicationContext();</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Looking for URL mappings in application context: &quot; + applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">String[] beanNames = (this.detectHandlersInAncestorContexts ?</span><br><span class="line">BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :</span><br><span class="line">applicationContext.getBeanNamesForType(Object.class));</span><br><span class="line"></span><br><span class="line">// Take any bean name that we can determine URLs for.</span><br><span class="line">for (String beanName : beanNames) &#123;</span><br><span class="line">// 获取BeanName或别名是 &quot;/&quot; 开头的 Bean名称</span><br><span class="line">String[] urls = determineUrlsForHandler(beanName);</span><br><span class="line">if (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">// URL paths found: Let&apos;s consider it a handler.</span><br><span class="line">// 把获取到的 urls 注册到 handler</span><br><span class="line">registerHandler(urls, beanName);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Rejected bean name &apos;&quot; + beanName + &quot;&apos;: no URL paths identified&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>determineUrlsForHandler</code>是<code>BeanNameUrlHandlerMapping</code>类仅有实现的一个方法，主要逻辑就是获取BeanName或别名是 “/“ 开头的 Bean名称。所以这里也可以知道在上文的使用例子中，BeanName我为何要以斜杠开头。</p><p>当一个请求来时<code>BeanNameUrlHandlerMapping</code>的处理逻辑类似，只不过匹配的容器换成了<code>handlerMap = new LinkedHashMap&lt;&gt;();</code>，匹配逻辑更加的简单直接。</p><h2 id="SimpleUrlHandlerMapping"><a href="#SimpleUrlHandlerMapping" class="headerlink" title="SimpleUrlHandlerMapping"></a>SimpleUrlHandlerMapping</h2><p>最后再看下 SimpleUrlHandlerMapping的用法及实现</p><p>定义一个<code>SimpleUrlHandlerMapping</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title">simpleUrlHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleUrlHandlerMapping simpleUrlHandlerMapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">        Map&lt;String, Object&gt; urlMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        urlMap.put(<span class="string">"/**"</span>, <span class="keyword">new</span> Test2API());</span><br><span class="line">        <span class="comment">// ... 可配置多个映射关系</span></span><br><span class="line">        simpleUrlHandlerMapping.setUrlMap(urlMap);</span><br><span class="line">        simpleUrlHandlerMapping.setOrder(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> simpleUrlHandlerMapping;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上配置会拦截所有的请求，然后转交给 Test2API处理（Test2API可以是Controller接口实现类，也可以是一个 HttpRequestHandler接口实现类），可以看到这里<code>SimpleUrlHandlerMapping</code>起的作用非常像一个拦截器起的作用，其实也确实是这样，像对静态资源的拦截就可以采用<code>SimpleUrlHandlerMapping</code>来实现。</p><p>具体实现其实跟上文的两种mapping实现类似，简单看下源码</p><p>初始注册逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.initApplicationContext();</span><br><span class="line">registerHandlers(<span class="keyword">this</span>.urlMap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlers</span><span class="params">(Map&lt;String, Object&gt; urlMap)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (urlMap.isEmpty()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Neither 'urlMap' nor 'mappings' set on SimpleUrlHandlerMapping"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">urlMap.forEach((url, handler) -&gt; &#123;</span><br><span class="line"><span class="comment">// 确保路径是以斜杠开头的</span></span><br><span class="line"><span class="keyword">if</span> (!url.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">url = <span class="string">"/"</span> + url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 去除空格</span></span><br><span class="line"><span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">handler = ((String) handler).trim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">registerHandler(url, handler);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑还是比较简单的，就是将我们手动配置的多个映射关系进行初始注册，以备后面逻辑使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说HanderMapping的职责是非常清晰的，就是存储并匹配请求url和处理类的映射关系。整个处理流程的源码相对来说也比较直观，易阅读。读完其源码对MVC的url匹配流程会有更加深刻的认识</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;什么是Spring mvc 的 HanderMapping? &lt;/strong&gt;&lt;br&gt;**&lt;br&gt;我们知道当一个http请
      
    
    </summary>
    
      <category term="Spring" scheme="http://wangjunnan.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://wangjunnan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务在积分商城里的应用</title>
    <link href="http://wangjunnan.github.io/2019/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%9C%A8%E7%A7%AF%E5%88%86%E5%95%86%E5%9F%8E%E9%87%8C%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://wangjunnan.github.io/2019/07/10/分布式事务在积分商城里的应用/</id>
    <published>2019-07-10T08:56:22.000Z</published>
    <updated>2019-09-27T05:52:47.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近在做会员体系的时候，涉及到了积分商城订单体系，既然设计到订单体系，因为现在的项目架构体系基本都是微服务分布式的，所以必然会涉及到分布式事务。事务问题在早些时候都是单机部署的时代依靠数据库本身提供的事务机制非常容易解决，但是一旦设计到分布式，各个独立的服务是无法感知其他事务执行状态的，所以我们需要借助一些其他手段来保证分布式事务</p><h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><ul><li><p>CAP</p><ul><li>C（一致性）一致性是指数据的原子性，在经典的数据库中通过事务来保障，事务完成时，无论成功或回滚，数据都会处于一致的状态，在分布式环境下，一致性是指多个节点数据是否一致；</li><li>A（可用性）服务一直保持可用的状态，当用户发出一个请求，服务能在一定的时间内返回结果；</li><li>P（分区容错性）机器故障、网络故障、机房停电等异常情况下仍然能够满足一致性和可用性，分布式应用一般都满足分区容错性<br>分布式事务我们要解决的就是数据的一致性问题</li></ul></li><li><p>一致性模型</p><ul><li>基本可用（Basically Available）</li><li>软状态（Soft State）</li><li><p>最终一致性（Eventually Consistent）</p><p>其中最终一致性又可分为：会话一致性 单调一致性等等</p></li></ul></li></ul><h2 id="2PC-Two-Three-Phase-Commit"><a href="#2PC-Two-Three-Phase-Commit" class="headerlink" title="2PC (Two/Three Phase Commit)"></a>2PC (Two/Three Phase Commit)</h2><p>2PC 我们又把它叫做两阶段提交，在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写入磁盘等等）。因此，二阶段提交的算法思路可以概括为： 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>二阶段提交算法的成立基于以下假设：</p><ol><li>该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Participants)。且节点之间可以进行网络通信。</li><li>所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li></ol><h3 id="第一阶段-提交请求阶段"><a href="#第一阶段-提交请求阶段" class="headerlink" title="第一阶段(提交请求阶段)"></a>第一阶段(提交请求阶段)</h3><ol><li>协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。</li><li>参与者节点执行询问发起为止的所有事务操作，并将<code>Undo</code>信息和<code>Redo</code>信息写入日志。</li><li>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li></ol><p>有时候，第一阶段也被称作投票阶段，即各参与者投票是否要继续接下来的提交操作。</p><h3 id="第二阶段-提交执行阶段"><a href="#第二阶段-提交执行阶段" class="headerlink" title="第二阶段(提交执行阶段)"></a>第二阶段(提交执行阶段)</h3><ul><li>成功<br>  当协调者节点从所有参与者节点获得的相应消息都为”同意”时：<ol><li>协调者节点向所有参与者节点发出”正式提交”的请求。</li><li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”完成”消息。</li><li>协调者节点收到所有参与者节点反馈的”完成”消息后，完成事务。</li></ol></li><li>失败<br>  如果任一参与者节点在第一阶段返回的响应消息为”终止”，或者 协调者节点在第一阶段的询问超    时之前无法获取所有参与者节点的响应消息时：<ol><li>协调者节点向所有参与者节点发出”回滚操作”的请求。</li><li>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”回滚完成”消息。</li><li>协调者节点收到所有参与者节点反馈的”回滚完成”消息后，取消事务。</li></ol></li></ul><p>有时候，第二阶段也被称作完成阶段，因为无论结果怎样，协调者都必须在此阶段结束当前事务</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>二阶段提交算法的最大缺点就在于: <strong>它的执行过程中间，节点都处于阻塞状态</strong>。即节点之间在等待对方的响应消息时，它将什么也做不了。特别是，当一个节点在已经占有了某项资源的情况下，为了等待其他节点的响应消息而陷入阻塞状态时，当第三个节点尝试访问该节点占有的资源时，这个节点也将连带陷入阻塞状态。</p><h2 id="TCC-补偿型"><a href="#TCC-补偿型" class="headerlink" title="TCC 补偿型"></a>TCC 补偿型</h2><p>上面大篇幅的介绍了2PC提交，但实际的应用中我们基本都不会使用这种方案，原因在上面的缺点中已经说明了，2PC这种传统的分布式事务解决方案性能实在是太差了，在互联网大并发的背景下显然是不行的，这就引申出了TCC补偿性分布式事务解决方案</p><p>TCC是(<code>Try-Confirm-Cancel</code>)的简称，从名字我们知道TCC有三个阶段</p><ol><li>Try<br>Try阶段主要做资源的预留，锁定操作</li><li>Confirm<br>如果Try预留资源成功，则执行Confirm操作，对资源做最终的提交</li><li>Cancel<br>如果Try预留资源失败，则执行Cancel取消对资源的锁定</li></ol><p>通过上文的描述，可以发现TCC与2PC非常相似，但实际上两者在解决分布式事务的层面上不一样的，2PC主要还是借助数据库层面的事务来协调解决，相对于数据库事务的<code>rollback</code>，TCC在逻辑层面的Cancel操作，代价要小的多。并且TCC事务引入了中间状态（也就是资源的锁定），只要全部资源都锁定成功，我们就认为最终是执行成功的（最终一致性）</p><p>下图是积分下单用TCC事务解决的典型场景<br><img src="http://img.souche.com/f2e/d6344431308a0bf0524dee25a67a7ed4.jpg" alt></p><h3 id="TCC是如何解决最终一致性的？"><a href="#TCC是如何解决最终一致性的？" class="headerlink" title="TCC是如何解决最终一致性的？"></a>TCC是如何解决最终一致性的？</h3><p>当我们在<code>Try</code>阶段预留资源成功的话，那么我们就认为最终这个事务是肯定可以完成的，即使因为某些原因(数据库down了等的)<code>Confirm</code>执行失败，TCC事务框架会不停的重试调用它的<code>Confirm</code>逻辑，务必会保证其最终一致性</p><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>订单系统</p><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>事务消息的应用场景是，事务参与方的资源已经锁定，只需要保持最终一致性的场景。比较典型的实例是银行转账，当A账户完成账户扣减后，B账户不需要锁定账户，只需要保证最终B账户可以增加指定金额</p><p><img src="http://img.souche.com/f2e/43a4b89a08f32771eb7815782d749a8a.jpg" alt></p><h3 id="为何需要先发送-Prepare消息？"><a href="#为何需要先发送-Prepare消息？" class="headerlink" title="为何需要先发送 Prepare消息？"></a>为何需要先发送 Prepare消息？</h3><p>试想一种场景，本地事务执行成功，准备发送消息的时候断网了，这时候就会造成数据不一致的情况</p><h3 id="commit-or-rollback-消息发送失败？"><a href="#commit-or-rollback-消息发送失败？" class="headerlink" title="commit or rollback 消息发送失败？"></a>commit or rollback 消息发送失败？</h3><p>这时候需要消息中间件提供消息回查功能，也就是当间隔一段时间之后，Prepare消息没有收到 commit or rollback消息，需要发起消息回查，并且由业务方判断最终消息是否需要投递</p><p>对于事务消息的解决方案，阿里的<code>RocketMq</code>也提供了解决方案<br><img src="http://img.souche.com/f2e/1ec3ad72a09958fad49b6cbfb08949db.jpg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，每种分布式事务解决方案都有其应用场景，但目前业界比较主流的还是TCC和事务消息，TCC事务需要业务实现<code>Try-Confirm-Cancel</code>逻辑，需要在Try阶段提前锁定资源，相对于事务消息来说成本较高，但是事务消息的适用场景也是有限的，如下单扣减库存这个场景因为需要提前锁定库存，事务消息就不适用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;最近在做会员体系的时候，涉及到了积分商城订单体系，既然设计到订单体系，因为现在的项目架构体系基本都是微服务分布式的，所以必然会涉及到分布式事
      
    
    </summary>
    
      <category term="分布式" scheme="http://wangjunnan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://wangjunnan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="事务" scheme="http://wangjunnan.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>git 你真的会用吗</title>
    <link href="http://wangjunnan.github.io/2019/06/21/git-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E5%90%97/"/>
    <id>http://wangjunnan.github.io/2019/06/21/git-你真的会用吗/</id>
    <published>2019-06-21T02:26:10.000Z</published>
    <updated>2019-09-27T05:52:47.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录原由"><a href="#记录原由" class="headerlink" title="记录原由"></a>记录原由</h2><p>最近因为公司新来的同事，在使用<code>Git</code>时犯了一些非常低级的错误，导致团队为了解决这些问题浪费了很多时间。究其原因其实还是对于<code>Git</code>内部实现不清晰，仅仅知道敲几个git命令，但是却不知道敲了这个命令<code>Git</code>会发生什么！这里根据<a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">git官方文档</a>节选了一些重要概念分享出来。</p><h2 id="几个重要概念"><a href="#几个重要概念" class="headerlink" title="几个重要概念"></a>几个重要概念</h2><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><ol><li>工作区状态<ul><li>就是修改了文件还没有做 <code>git add</code>的文件状态</li></ul></li><li>暂存区状态<ul><li>已经<code>git add</code>但还未<code>git commit</code>的文件状态</li></ul></li><li>已提交状态<ul><li>已经<code>git commit</code>的文件状态，也就是真正存储到<code>git</code>仓库</li></ul></li></ol><h3 id="Branch指针和HEAD指针"><a href="#Branch指针和HEAD指针" class="headerlink" title="Branch指针和HEAD指针"></a>Branch指针和HEAD指针</h3><p><code>Git</code>的分支特性是其最强大最独特的功能，也正是因为这个特性让<code>git</code>得以在众多的版本控制系统中脱颖而出，在理解<code>branch</code>之前，有必要先对<code>git commit</code>命令做一个简单的介绍</p><ul><li>当使用<code>git commit</code>进行提交操作时，<code>Git</code>便会创建一个提交对象，这个对象会包含一个指向本次提交的指针，指针指向本次<code>commit</code>的快照。指针也就是我们通常所说的<code>commit id(长度为 40 的 SHA-1 值字符串)</code>。如此一来，<code>Git</code>就可以在需要的时候根据<code>commit id</code>来回退版本</li></ul><p><code>Branch</code>的本质其实仅仅是指向提交对象的<strong>某一个可变指针</strong>。所以根据这个概念，我们可以知道<code>master</code>并不是一个特殊的分支，他跟我们众多自定义的分支没有任何不同，唯一区别是它是<code>Git</code>的默认分支(初始化的时候总得有一个默认分支)</p><p>下面的图是单个<code>master</code>分支时的结构，这里<code>master</code>仅仅是一个指向<code>f30ab</code>提交对象的指针</p><p><img src="http://img.souche.com/f2e/037ab2a225f8b9457af9a40324313f84.jpg" alt></p><p>执行 <code>$ git branch testing</code>创建一个 <code>testing</code>分支，会在当前所在的提交对象上创建一个名为<code>testing</code>的指针，也就是<code>testing</code>分支<br><img src="http://img.souche.com/f2e/0efbc0ed98b12c7aadfe4a97d82d2315.jpg" alt></p><p>注意：此时两个指针指向了相同的提交<br>那么<code>Git</code>是如何来知道当前处于哪个分支的呢？<br>这就引出了<code>Git</code>中的另一个特殊的指针<code>HEAD</code>，<code>HEAD</code>用来指向当前所在的分支，也就是一个用来指向分支指针的指针（有点拗口），就像下图这样，当前是在<code>master</code>分支，因为<code>git branch</code>并不会移动<code>HEAD</code>指针切换分支</p><p><img src="http://img.souche.com/f2e/bc84a1c0611edbcf64756ad321f0d84c.jpg" alt></p><p>执行 <code>$ git checkout testing</code>命令才会将<code>HEAD</code>指针指向<code>testing</code>分支<br><img src="http://img.souche.com/f2e/d09338fd78877491ec49f7fcb191a491.jpg" alt></p><p>当我们在<code>testing</code>分支上继续提交几个commit之后，<code>testing</code>指针和<code>HEAD</code>指针都会跟着向前移动，但是<code>master</code>指针并不会移动，依旧指向<code>f30ab</code>这个提交<br><img src="http://img.souche.com/f2e/8b8a8539aa7dc810a9a9f371f8751bc3.jpg" alt></p><p>现在执行<code>git checkout master</code>切回<code>master</code>分支，<code>HEAD</code>指针会重新指向<code>master</code>，也就是说现在又回到了一个旧的版本，这也是<code>Git</code>的神奇之处<br><img src="http://img.souche.com/f2e/a172111db3abe0d8c6f82c7b3a99607f.jpg" alt></p><p>接下来我们在<code>master</code>分支上做一些修改，提交一个commit，<code>HEAD</code>和<code>master</code>指针会继续向前移动，并且这个项目的提交（快照版本）已经产生了分叉<br><img src="http://img.souche.com/f2e/237c20e005bac4135577ffd143eeb033.jpg" alt></p><blockquote><p>保存分支信息的目录在<code>.git/refs/heads</code>下，也可以在这个目录下查看或修改分支指针</p></blockquote><h2 id="merge-命令"><a href="#merge-命令" class="headerlink" title="merge 命令"></a>merge 命令</h2><p>在上文的例子中，项目有两个分支，且已经产生了分叉，这时候需要把<code>testing</code>分支上的内容合并至<code>master</code>时需要用到<code>merge</code>命令<br>在<code>master</code>执行<code>git merge testing</code>，会生成一个新的提交<code>9c67a</code>，并且<code>HEAD</code>和<code>master</code>指针继续向前移动</p><p><img src="http://img.souche.com/f2e/0c40f40917743bcc75b4871ad7a76bf8.jpg" alt></p><h2 id="reset-命令"><a href="#reset-命令" class="headerlink" title="reset 命令"></a>reset 命令</h2><p>假如上面的<code>merge</code>操作有问题，需要撤销，可以使用<code>reset</code>命令，但首先需要明确回退的版本是哪一个，例如要回退的版本是<code>c2b9e</code>，执行<code>git reset --hard c2b9e</code>后，<code>HEAD</code>和<code>master</code>指针会回退到版本<code>c2b9e</code></p><p><img src="http://img.souche.com/f2e/cfd70efa478ee439cc8db564681b22c2.jpg" alt></p><h2 id="…"><a href="#…" class="headerlink" title="…"></a>…</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记录原由&quot;&gt;&lt;a href=&quot;#记录原由&quot; class=&quot;headerlink&quot; title=&quot;记录原由&quot;&gt;&lt;/a&gt;记录原由&lt;/h2&gt;&lt;p&gt;最近因为公司新来的同事，在使用&lt;code&gt;Git&lt;/code&gt;时犯了一些非常低级的错误，导致团队为了解决这些问题浪费了很多时
      
    
    </summary>
    
      <category term="git" scheme="http://wangjunnan.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://wangjunnan.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 泛型 你真的理解了吗？</title>
    <link href="http://wangjunnan.github.io/2019/06/19/JAVA-%E6%B3%9B%E5%9E%8B-%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E4%BA%86%E5%90%97%EF%BC%9F/"/>
    <id>http://wangjunnan.github.io/2019/06/19/JAVA-泛型-你真的理解了吗？/</id>
    <published>2019-06-19T08:16:53.000Z</published>
    <updated>2019-09-27T05:52:47.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录原由"><a href="#记录原由" class="headerlink" title="记录原由"></a>记录原由</h2><p>之前虽然泛型一直在使用，但使用的过程中总是没有那么得心应手，有些细节还是过于模糊。究其原因其实是一直都没有系统深入的去理解过，最近花了一点时间去深入的理解了一下java的泛型机制，也希望借这次记录能够彻底的理解java的泛型</p><h2 id="为什么要有泛型"><a href="#为什么要有泛型" class="headerlink" title="为什么要有泛型"></a>为什么要有泛型</h2><p><strong>泛型的本质是把 类型参数化</strong>，什么是类型参数化？举个例子，我们常用的集合类，要是没有类型参数化的话，我们就得实现装不同类型的集合类，会大大降低代码的可重用性！</p><p>例如我们要设计一个装苹果的盘子和一个装香蕉的盘子，要怎么设计呢？非常简单，最简单的方式就是设计两个盘子类，一个是苹果盘子，一个香蕉盘子，就像下面的代码一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplePlant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Apple apple;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Apple <span class="title">getApple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApple</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.apple = apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BananaPlant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Banana banana;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Banana <span class="title">getBanana</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> banana;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBanana</span><span class="params">(Banana banana)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.banana = banana;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码的确能够满足我们的需求，但就像上文所说的，这样的代码降低了代码的可重用性，那么我们要怎么优化呢，聪明的程序员们马上想到了，可以用<code>Object</code>来代替盘子里所指代的具体类型，就像下面这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectPlant</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObject</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看似完美解决了代码不可重用的问题，但同时也隐含了很多其他问题，例如在我们取数据的时候，取出来的只能是<code>Object</code>类型，需要我们强转类型，而往盘子中加入数据的时候，也没有任何验证，有可能往放苹果的盘子中加入了香蕉也说不定，因为编译器并没有做任何限制，只要是<code>Object</code>类型，都可以验证通过。</p><p>上面的问题在Java 1.5引入了泛型之后得到了完美的解决，下面让我们来看看用泛型如何优雅的解决上述问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plant</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个泛型类，它表示了一个可以<code>T</code>类型的篮子，而这个<code>T</code>类型需要到我们真正使用的时候才会去指定</p><p>例如现在我们要定义两种盘子，可以这样声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plant&lt;Apple&gt; applePlant = <span class="keyword">new</span> Plant&lt;&gt;();</span><br><span class="line">Plant&lt;Banana&gt; bananaPlant = <span class="keyword">new</span> Plant&lt;&gt;();</span><br><span class="line">Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">Banana banana = <span class="keyword">new</span> Banana();</span><br><span class="line">applePlant.set(banana); <span class="comment">// 编译报错</span></span><br><span class="line">bananaPlant.set(apple); <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><p>上面的代码之所以实际类型<code>new Plant&lt;&gt;()</code>的<code>&lt;&gt;</code>中没有指明具体类型，是因为Java7之后加了类型自动推断，也就不需要两侧都加上泛型类型</p><p>可以看到使用了泛型之后，既提高了代码的可重用性，在实际使用时也对类型进行了约束，装苹果的盘子是装不了香蕉的！</p><p>不过要注意的是，java的泛型约束是在编译时生效的，一旦编译成了class字节码文件后，一切都打回原形了，泛型信息会被擦除，所以我们把<code>JAVA</code>的泛型称为伪泛型，跟<code>C#</code>等语言的真泛型有着本质区别，在<code>C#</code>中，<code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code> 就是两种不同的类型</p><p>如下面字节码文件的最后一行<code>invokevirtual</code>命令的方法描述符<code>Method setT:(Ljava/lang/Object;)V</code>，可知泛型类型已经被擦除成了<code>Object</code>类型，也就是在字节码层面实际上与我们直接用<code>Object</code>来实现是一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: new           #3                  // class com/sunshine/common/test/Plant</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #4                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: aload_1</span><br><span class="line">         9: new           #5                  // class com/sunshine/common/test/Apple</span><br><span class="line">        12: dup</span><br><span class="line">        13: invokespecial #6                  // Method com/sunshine/common/test/Apple.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        16: invokevirtual #7                  // Method setT:(Ljava/lang/Object;)V</span><br></pre></td></tr></table></figure><h2 id="泛型进阶"><a href="#泛型进阶" class="headerlink" title="泛型进阶"></a>泛型进阶</h2><h3 id="使用-lt-T-extends-gt-定义泛型类"><a href="#使用-lt-T-extends-gt-定义泛型类" class="headerlink" title="使用 &lt;T extends ?&gt; 定义泛型类"></a>使用 <code>&lt;T extends ?&gt;</code> 定义泛型类</h3><p>头一次看到上面两个符号，是不是有点懵逼？它们在代码里也非常常见，那么它们究竟是表示什么意思呢？<br>还是通过上文的<code>plant</code>盘子来举例吧，举一种情况，我们只希望这个盘子用来装一些水果，而不希望它被用来装肉，那么我们该怎么做呢？<br>现在的情况是，它既可以实例化成一个装香蕉的盘子，也可以被实例化成一个装肉的盘子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plant&lt;Apple&gt; applePlant = <span class="keyword">new</span> Plant&lt;&gt;(); <span class="comment">// </span></span><br><span class="line">Plant&lt;Meat&gt; meatPlant = <span class="keyword">new</span> Plant&lt;&gt;(); <span class="comment">// 都是Ok的</span></span><br></pre></td></tr></table></figure><p>现在让我们来重新设计一个盘子类，通过<code>&lt;T extends Firut&gt;</code>来限制泛型，其实如果我们直接用<code>&lt;T&gt;</code>的编译成字节码后也会自动编译成<code>&lt;T extends Object&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirutPlant</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Firut</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FirutPlant&lt;Apple&gt; appleFirutPlant = <span class="keyword">new</span> FirutPlant&lt;&gt;(); <span class="comment">// OK</span></span><br><span class="line">FirutPlant&lt;Firut&gt; firutPlant = <span class="keyword">new</span> FirutPlant&lt;&gt;(); <span class="comment">// OK</span></span><br><span class="line">FirutPlant&lt;Meat&gt; meatFirutPlant = <span class="keyword">new</span> FirutPlant&lt;&gt;(); <span class="comment">// 编译无法通过</span></span><br></pre></td></tr></table></figure><p>通过上面的代码可知我们成功的限制了泛型，水果盘子就只能装水果，盘子中的类型只能是水果或则它的子类型。</p><h3 id="lt-extends-T-gt-lt-super-T-gt"><a href="#lt-extends-T-gt-lt-super-T-gt" class="headerlink" title="&lt;? extends T&gt; &lt;? super T&gt;"></a><code>&lt;? extends T&gt; &lt;? super T&gt;</code></h3><p>注意这里的T是泛型参数，跟上面的<t extends ?> T不一样</t></p><p>看完上面的 <code>&lt;T extends ?&gt;</code>，接下来我们再来看<code>&lt;? extends T&gt; &lt;? super T&gt;</code>，可能这里你会非常疑惑，哇 这两个有什么区别？其实简单理解的话，<code>&lt;T extends ?&gt;</code>是在类文件层面就限制了泛型的范围，而<code>&lt;? extends T&gt; &lt;? super T&gt;</code>是在使用泛型的时候再去做限制。明白了这个之后接下来我们就来看下<code>&lt;? extends T&gt; &lt;? super T&gt;</code>的使用。</p><p>让我们回到<code>Firut.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plant</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在不在定义泛型类的时候做限制，(使用<code>&lt;T&gt;</code>，其实这里还是相当于<code>&lt;T extends Object&gt;</code>)，而是在使用的是去做限制</p><p>下面我们来看下<code>&lt;? extends T&gt;</code>的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Plant&lt;Apple&gt; applePlant = new Plant&lt;Apple&gt;();</span><br><span class="line">applePlant.setT(new Apple());</span><br><span class="line">// 使用 &lt;? extends T&gt;</span><br><span class="line">Plant&lt;? extends Firut&gt; plant = applePlant;</span><br><span class="line"></span><br><span class="line">plant.setT(new Apple()); // 无法存 编译报错</span><br><span class="line">plant.setT(new Firut()); // 无法存 编译报错</span><br><span class="line">Firut apple = plant.getT(); // 可以获取</span><br></pre></td></tr></table></figure><p>可以看到当<code>&lt;? extends T&gt;</code>做为接收参数时，因为其必然是<code>Firut</code>的子类，这里实例类型是<code>Apple</code>，所以<code>getT()</code>方法仍然可以使用，因为会进行一次隐式的类型转换（向上转型是安全的），但是<code>setT()</code>方法是失效的，这是因为编译器不能确定你一定会往里面添加<code>Apple</code>类型，因为你还可以往里面添加<code>Banana</code>类型，显然<code>Banana</code>类型无法强转<code>Apple</code>类型，所以这里的<code>setT()</code>方法是失效的</p><p>下面我们来看下<code>&lt;? super T&gt;</code>的使用<br>有了上面<code>&lt;? extends T&gt;</code>的使用经验，顾明思议，<code>&lt;? super T&gt;</code>必然表示<code>T</code>的全部父类型，还是再来看下<code>&lt;? super T&gt;</code>的使用吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Plant&lt;Firut&gt; firutPlant = <span class="keyword">new</span> Plant&lt;&gt;();</span><br><span class="line">Plant&lt;? <span class="keyword">super</span> Apple&gt; plant = firutPlant;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plant.setT(<span class="keyword">new</span> Apple()); <span class="comment">// 可以存成功，不过这里只能存 Apple类型</span></span><br><span class="line">Apple apple = plant.getT(); <span class="comment">// 编译报错</span></span><br><span class="line"></span><br><span class="line">Firut firut = firutPlant.getT();</span><br></pre></td></tr></table></figure><p>上面可以存成功的原因和上面<code>&lt;? extends T&gt;</code>可以取成功的原因一样，也是因为存在一个隐式的向上转型，而获取失败的原因 也很容易理解，因为实际类型肯定是<code>Apple</code>的父类（这里是Firut），所以要将<code>Firut</code>转成<code>Apple</code>显然是不可行的！</p><h3 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;?&gt;"></a>&lt;?&gt;</h3><p><code>&lt;?&gt;</code>其实等价与<code>&lt;? extends Object&gt;</code>，这样子我相信就比较好理解了，跟<code>&lt;? extends T&gt;</code>类似，也是取可以，存被限制</p><p><code>&lt;T&gt;</code>一般都是在定义泛型类或则泛型方法时出现，实际使用时都以<code>?</code>或具体类型替代<code>T</code></p><h3 id="Type-与-Class-的区别和联系"><a href="#Type-与-Class-的区别和联系" class="headerlink" title="Type 与 Class 的区别和联系"></a>Type 与 Class 的区别和联系</h3><p>说起泛型，不得不提JDK在1.5之后引入的<code>Type</code>类型，显然<code>Type</code>是<code>Java</code>为了实现泛型而引入的。那么<code>Type</code>到底是什么呢，它表示的范围有多大？<br>其实我们可以直接理解把<code>Class</code>当成是<code>Type</code>的子集，<code>Class</code>对应着jdk1.5之前不是泛型的原始类型</p><p><code>Type</code>下包含了几种不同的类型</p><ul><li><code>Class</code> 原始类型，我这里直接理解成我们常用的<code>Class</code>类型，<code>Class</code>是<code>Type</code>的直接子类</li><li><code>ParameterizedType</code> 参数化类型类似 <code>List&lt;String&gt; list</code> 获取list的类型</li><li><code>TypeVariable</code> 类似 <code>T t</code></li><li><code>GenericArrayType</code> 类似 <code>List&lt;String&gt;[]</code> 或则 <code>List&lt;T&gt; []</code><ul><li><code>GenericArrayType</code> 接口只有一个方法<code>getGenericComponentType</code>，用户返回<code>ParameterizedType</code>或则<code>TypeVariable</code>类型</li></ul></li><li><code>WildcardType</code> 类似 <code>&lt;? super T&gt;</code> 要得到这个类型，首先需要得到<code>ParameterizedType</code>类型，然后通过<code>getActualTypeArguments</code>方法获取<code>WildcardType</code>类型</li></ul><p>说了这么多，还是通过实际的代码来详细解释吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOne</span><span class="params">(Plant&lt;Apple&gt; plant, </span></span></span><br><span class="line"><span class="function"><span class="params">                        Plant&lt;Apple&gt; [] plants, </span></span></span><br><span class="line"><span class="function"><span class="params">                        Plant&lt;? extends Apple&gt; applePlant)</span> </span>&#123;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">testOne</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写段测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Method [] methods = TypeTest.class.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getName().equals(<span class="string">"testOne"</span>)) &#123;</span><br><span class="line">        Type [] parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        System.out.println(<span class="string">"methodOne start --------&gt; "</span>);</span><br><span class="line">        <span class="keyword">for</span> (Type type : parameterTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Class ---- "</span> + type.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                System.out.println(<span class="string">"ParameterizedType ---- "</span> + type.getTypeName());</span><br><span class="line">                Type ytpe3[] = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type type2 : ytpe3) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (type2 <span class="keyword">instanceof</span> WildcardType) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"ParameterizedType-WildcardType  ---- "</span> + type2.getTypeName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">                System.out.println(<span class="string">"GenericArrayType ---- "</span> + type.getTypeName());</span><br><span class="line">                Type type2 = ((GenericArrayType) type).getGenericComponentType();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">                System.out.println(<span class="string">"TypeVariable ---- "</span> + type.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">"testTwo"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        Type [] parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        System.out.println(<span class="string">"methodTwo start --------&gt; "</span>);</span><br><span class="line">        <span class="keyword">for</span> (Type type : parameterTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">                System.out.println(<span class="string">"TypeVariable ---- "</span> + type.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methodTwo start --------&gt; </span><br><span class="line">TypeVariable ---- T</span><br><span class="line">methodOne start --------&gt; </span><br><span class="line">ParameterizedType ---- com.sunshine.common.test.Plant&lt;com.sunshine.common.test.Apple&gt;</span><br><span class="line">GenericArrayType ---- com.sunshine.common.test.Plant&lt;com.sunshine.common.test.Apple&gt;[]</span><br><span class="line">ParameterizedType ---- com.sunshine.common.test.Plant&lt;? extends com.sunshine.common.test.Apple&gt;</span><br><span class="line">ParameterizedType-WildcardType  ---- ? extends com.sunshine.common.test.Apple</span><br></pre></td></tr></table></figure><h2 id="什么情况可以拿到泛型类型"><a href="#什么情况可以拿到泛型类型" class="headerlink" title="什么情况可以拿到泛型类型"></a>什么情况可以拿到泛型类型</h2><p>先看可以拿到泛型的情形，与上面的例子一样，我们可以获取方法入参，超类的参数化类型，举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperPlant</span> <span class="title">extend</span> <span class="title">Plant</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;Apple&gt; apples)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取父类参数化类型</span></span><br><span class="line">    Type type = SuperPlant.class.getGenericSuperclass();</span><br><span class="line">    Method[] methods = SuperPlant.class.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">// 获取方法参数化类型</span></span><br><span class="line">            Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现以上代码是可以获取到泛型类型。通过<code>getGenericSuperclass</code>获取到父类的参数化类型，method的<code>getGenericParameterTypes</code>获取到入参的参数化类型数组。</p><p>再看一种情况<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Plant&lt;Firut&gt; firutPlant = <span class="keyword">new</span> Plant&lt;&gt;();</span><br><span class="line">  <span class="comment">// 这里可以拿到 firutPlant 对象的泛型吗?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子中，我们是拿不到 firutPlant 的泛型的，因为JAVA 在将其编译成字节码的时候，实际上会变成 <code>Plant&lt;Object&gt;</code>类型，泛型会被擦除。</p><p><strong>所以我们其实是无法在运行时通过泛型对象本身拿到泛型类型的，那么有没有黑科技可以拿到运行时泛型本身的泛型信息？上面有提到，我们拿泛型可以通过子类来获取父类的泛型</strong><br>我们依据这个思路将上面例子修改一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Type type = <span class="keyword">new</span> Plant&lt;Firut&gt;() &#123;&#125;.getClass().getGenericSuperclass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是将Plant改成了匿名类方式实现，这种方式可以拿到Plant的泛型信息吗？答案是可以的<br>这里通过<code>getGenericSuperclass</code>拿到的就是Plant<firut> 的泛型类型信息。其实这种方式在很多框架源码里很常见，通过匿名类方式获取参数类型，感兴趣的可以看下<code>Gson</code>的<code>TypeToken</code>的实现，也是一样的原理。</firut></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记录原由&quot;&gt;&lt;a href=&quot;#记录原由&quot; class=&quot;headerlink&quot; title=&quot;记录原由&quot;&gt;&lt;/a&gt;记录原由&lt;/h2&gt;&lt;p&gt;之前虽然泛型一直在使用，但使用的过程中总是没有那么得心应手，有些细节还是过于模糊。究其原因其实是一直都没有系统深入的去理解过
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://wangjunnan.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码方法表</title>
    <link href="http://wangjunnan.github.io/2019/04/25/Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8/"/>
    <id>http://wangjunnan.github.io/2019/04/25/Java字节码方法表/</id>
    <published>2019-04-25T07:50:02.000Z</published>
    <updated>2019-09-27T05:52:47.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>因为字段表和方法表的结构类似，所以我们直接分析Java字节码的方法表内容，理解了方法表，自然就理解了字段表</p><h2 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h2><p>方法表在<code>Class</code>文件中的位置是在字段表之后的，具体的结构我们根据下表再来回顾一下</p><table><thead><tr><th>类型</th><th>名称</th><th>数量 </th></tr></thead><tbody><tr><td>u2</td><td>access_flas</td><td>1 </td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>属性表</td><td>attributes_count</td></tr></tbody></table><p>还是跟上篇文章一样，我们写一个简单的Java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> String sayStr = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> sayStr;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"> System.out.println(test.sayHello());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>javap</code>翻译字节码文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class com.ymm.agent.Test</span><br><span class="line"></span><br><span class="line"> minor version: 0</span><br><span class="line"></span><br><span class="line"> major version: 52</span><br><span class="line"></span><br><span class="line"> flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line"></span><br><span class="line"> this_class: #3 // com/ymm/agent/Test</span><br><span class="line"></span><br><span class="line"> super_class: #8  // java/lang/Object</span><br><span class="line"></span><br><span class="line"> interfaces: 0, fields: 0, methods: 3, attributes: 1</span><br><span class="line"></span><br><span class="line">Constant pool:</span><br><span class="line"></span><br><span class="line"> #1 = Methodref #8.#27  // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line"> #2 = String  #28 // hello world</span><br><span class="line"></span><br><span class="line"> #3 = Class #29 // com/ymm/agent/Test</span><br><span class="line"></span><br><span class="line"> #4 = Methodref #3.#27  // com/ymm/agent/Test.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line"> #5 = Fieldref  #30.#31 // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line"> #6 = Methodref #3.#32  // com/ymm/agent/Test.sayHello:()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> #7 = Methodref #33.#34 // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"> #8 = Class #35 // java/lang/Object</span><br><span class="line"></span><br><span class="line"> #9 = Utf8  &lt;init&gt;</span><br><span class="line"></span><br><span class="line"> #10 = Utf8  ()V</span><br><span class="line"></span><br><span class="line"> #11 = Utf8  Code</span><br><span class="line"></span><br><span class="line"> #12 = Utf8  LineNumberTable</span><br><span class="line"></span><br><span class="line"> #13 = Utf8  LocalVariableTable</span><br><span class="line"></span><br><span class="line"> #14 = Utf8  this</span><br><span class="line"></span><br><span class="line"> #15 = Utf8  Lcom/ymm/agent/Test;</span><br><span class="line"></span><br><span class="line"> #16 = Utf8  sayHello</span><br><span class="line"></span><br><span class="line"> #17 = Utf8  ()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> #18 = Utf8  sayStr</span><br><span class="line"></span><br><span class="line"> #19 = Utf8  Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> #20 = Utf8  main</span><br><span class="line"></span><br><span class="line"> #21 = Utf8  ([Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"> #22 = Utf8  args</span><br><span class="line"></span><br><span class="line"> #23 = Utf8  [Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> #24 = Utf8  test</span><br><span class="line"></span><br><span class="line"> #25 = Utf8  SourceFile</span><br><span class="line"></span><br><span class="line"> #26 = Utf8  Test.java</span><br><span class="line"></span><br><span class="line"> #27 = NameAndType #9:#10  // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line"> #28 = Utf8  hello world</span><br><span class="line"></span><br><span class="line"> #29 = Utf8  com/ymm/agent/Test</span><br><span class="line"></span><br><span class="line"> #30 = Class #36 // java/lang/System</span><br><span class="line"></span><br><span class="line"> #31 = NameAndType #37:#38 // out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line"> #32 = NameAndType #16:#17 // sayHello:()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> #33 = Class #39 // java/io/PrintStream</span><br><span class="line"></span><br><span class="line"> #34 = NameAndType #40:#41 // println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"> #35 = Utf8  java/lang/Object</span><br><span class="line"></span><br><span class="line"> #36 = Utf8  java/lang/System</span><br><span class="line"></span><br><span class="line"> #37 = Utf8  out</span><br><span class="line"></span><br><span class="line"> #38 = Utf8  Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line"> #39 = Utf8  java/io/PrintStream</span><br><span class="line"></span><br><span class="line"> #40 = Utf8  println</span><br><span class="line"></span><br><span class="line"> #41 = Utf8  (Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> public com.ymm.agent.Test();</span><br><span class="line"></span><br><span class="line"> descriptor: ()V</span><br><span class="line"></span><br><span class="line"> flags: (0x0001) ACC_PUBLIC</span><br><span class="line"></span><br><span class="line"> Code:</span><br><span class="line"></span><br><span class="line"> stack=1, locals=1, args_size=1</span><br><span class="line"></span><br><span class="line"> 0: aload_0</span><br><span class="line"></span><br><span class="line"> 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line"> 4: return</span><br><span class="line"></span><br><span class="line"> LineNumberTable:</span><br><span class="line"></span><br><span class="line"> line 9: 0</span><br><span class="line"></span><br><span class="line"> LocalVariableTable:</span><br><span class="line"></span><br><span class="line"> Start Length Slot Name  Signature</span><br><span class="line"></span><br><span class="line"> 0  5  0 this  Lcom/ymm/agent/Test;</span><br><span class="line"></span><br><span class="line"> public java.lang.String sayHello();</span><br><span class="line"></span><br><span class="line"> descriptor: ()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> flags: (0x0001) ACC_PUBLIC</span><br><span class="line"></span><br><span class="line"> Code:</span><br><span class="line"></span><br><span class="line"> stack=1, locals=2, args_size=1</span><br><span class="line"></span><br><span class="line"> 0: ldc  #2 // String hello world</span><br><span class="line"></span><br><span class="line"> 2: astore_1</span><br><span class="line"></span><br><span class="line"> 3: aload_1</span><br><span class="line"></span><br><span class="line"> 4: areturn</span><br><span class="line"></span><br><span class="line"> LineNumberTable:</span><br><span class="line"></span><br><span class="line"> line 12: 0</span><br><span class="line"></span><br><span class="line"> line 13: 3</span><br><span class="line"></span><br><span class="line"> LocalVariableTable:</span><br><span class="line"></span><br><span class="line"> Start Length Slot Name  Signature</span><br><span class="line"></span><br><span class="line"> 0  5  0 this  Lcom/ymm/agent/Test;</span><br><span class="line"></span><br><span class="line"> 3  2  1 sayStr  Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> public static void main(java.lang.String[]);</span><br><span class="line"></span><br><span class="line"> descriptor: ([Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"> flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line"> Code:</span><br><span class="line"></span><br><span class="line"> stack=2, locals=2, args_size=1</span><br><span class="line"></span><br><span class="line"> 0: new  #3 // class com/ymm/agent/Test</span><br><span class="line"></span><br><span class="line"> 3: dup</span><br><span class="line"></span><br><span class="line"> 4: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line"> 7: astore_1</span><br><span class="line"></span><br><span class="line"> 8: getstatic  #5 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line"> 11: aload_1</span><br><span class="line"></span><br><span class="line"> 12: invokevirtual #6 // Method sayHello:()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> 15: invokevirtual #7 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"> 18: return</span><br><span class="line"></span><br><span class="line"> LineNumberTable:</span><br><span class="line"></span><br><span class="line"> line 17: 0</span><br><span class="line"></span><br><span class="line"> line 18: 8</span><br><span class="line"></span><br><span class="line"> line 19: 18</span><br><span class="line"></span><br><span class="line"> LocalVariableTable:</span><br><span class="line"></span><br><span class="line"> Start Length Slot Name  Signature</span><br><span class="line"></span><br><span class="line"> 0 19  0 args  [Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> 8 11  1 test  Lcom/ymm/agent/Test;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SourceFile: &quot;Test.java&quot;</span><br></pre></td></tr></table></figure><p>通过上文的<code>interfaces: 0, fields: 0, methods: 3, attributes: 1</code>，我们可以知道该文件一共包含<code>3</code>个方法，分别对应着<code>无参构造</code>,<code>sayHello</code>,<code>main</code>三个方法</p><p>好了，现在让我们直接略过前面的一大推常量池项，</p><p>直接阅读我们自己写的<code>sayHello</code>方法的字节码内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public java.lang.String sayHello();</span><br><span class="line"></span><br><span class="line"> descriptor: ()Ljava/lang/String; /* 方法描述符 */</span><br><span class="line"></span><br><span class="line"> flags: (0x0001) ACC_PUBLIC /* 访问标识 */</span><br><span class="line"></span><br><span class="line"> Code: /* code属性  也就是我们写的具体代码翻译成的字节码指令内容 */</span><br><span class="line"></span><br><span class="line"> stack=1, locals=2, args_size=1 /* 分别指操作数栈深度；本地变量所需的存储空间（slot为单位）；参数个数 */</span><br><span class="line"></span><br><span class="line"> 0: ldc  #2 // String hello world /*将一个常量加载到操作数栈*/</span><br><span class="line"></span><br><span class="line"> 2: astore_1 /* 将一个数值从操作数栈存储到局部变量表 */</span><br><span class="line"></span><br><span class="line"> 3: aload_1 /* 将一个数值从局部变量表加载到操作数栈 */</span><br><span class="line"></span><br><span class="line"> 4: areturn /* 将栈顶第一个元素返回 */</span><br><span class="line"></span><br><span class="line"> LineNumberTable: /* 字节码与java代码行数对应关系 一般用于调试 */</span><br><span class="line"></span><br><span class="line"> line 12: 0</span><br><span class="line"></span><br><span class="line"> line 13: 3</span><br><span class="line"></span><br><span class="line"> LocalVariableTable: /* 局部变量表 */</span><br><span class="line"></span><br><span class="line"> Start Length Slot Name  Signature</span><br><span class="line"></span><br><span class="line"> 0  5  0 this  Lcom/ymm/agent/Test;</span><br><span class="line"></span><br><span class="line"> 3  2  1 sayStr  Ljava/lang/String;</span><br></pre></td></tr></table></figure><p>根据上表我们知道方法表的第一个内容的是<code>access_flas</code>，占一个字节。表中的<code>access_flas</code>其实就对应着上文中的  <code>flags: (0x0001) ACC_PUBLIC</code>，标识这个方法是<code>public</code>的，接下在的<code>name_index</code>和<code>descriptor_index</code>，在上文中的体现分别对应着<code>sayHello</code>和<code>()Ljava/lang/String;</code>。</p><p>这里解释一下描述符的概念，在介绍<code>Class文件结构</code>的文章中有提到，这里再提一遍:</p><p><strong>描述符的作用是用来描述字段的数据类型，方法的参数列表和返回值</strong>，根据描述符规则，基本数据类型（byte,char,int,long,float,double,short,boolean）以及代表无返回值的<code>void</code>类型都用一个大写字符来表示，而对象类型则用<code>L</code>加对象的全限定名来表示</p><p>最重要的内容其实还是在<code>attribute_info</code>属性表中的<code>code</code>内容，也就是我们写的具体代码翻译成的字节码指令内容，这块内容是我们阅读字节码文件的重中之重。下面我们就来阅读一下上文的字节码内容</p><ol><li><p>ldc #2 将常量池中索引为2的字符串加载到操作数栈顶</p></li><li><p>astore_1 将一个数值从操作数栈存储到局部变量表</p></li><li><p>aload_1 将一个数值从局部变量表加载到操作数栈</p></li><li><p>areturn 将栈顶第一个元素返回</p></li></ol><p>可以看到上面的四个步骤的操作其实都是基于栈的操作，这里提一下java虚拟机栈的栈帧结构</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-0b89369329932afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>关于字节码子令集可以参考<a href="https://blog.csdn.net/zqz_zqz/article/details/79484757" target="_blank" rel="noopener"><a href="https://blog.csdn.net/zqz_zqz/article/details/79484757" target="_blank" rel="noopener">java字节码子令集</a></a></p><h2 id="有趣的例子-—"><a href="#有趣的例子-—" class="headerlink" title="有趣的例子 —"></a>有趣的例子 —</h2><p>下面我们再来看一个有趣的例子，大家思考一下这个执行这个方法的返回值会是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line"> public int inc() &#123;</span><br><span class="line"></span><br><span class="line"> int x;</span><br><span class="line"></span><br><span class="line"> try &#123;</span><br><span class="line"></span><br><span class="line"> x = 1;</span><br><span class="line"></span><br><span class="line"> return x;</span><br><span class="line"></span><br><span class="line"> &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line"> x = 2;</span><br><span class="line"></span><br><span class="line"> return x;</span><br><span class="line"></span><br><span class="line"> &#125; finally &#123;</span><br><span class="line"></span><br><span class="line"> x = 3;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码非常简单，我想大家应该也都知道正确答案，当没有出现异常的时候，返回值为1，出现异常的话则为2（当然这里不会抛异常）。可是如果我们在finally快里加句代码<code>System.out.prinln(&quot;do it&quot;)</code>，然后再执行这个方法，其实是可以看到<code>do it</code>被打印了，也就是说在执行<code>return</code>之前，finally快中的代码是被执行了的，那么这里就有一个有趣的问题了，为何返回仍然是2而不是3呢？</p><p>下面我们就从字节码文件中来找出答案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int inc();</span><br><span class="line"></span><br><span class="line"> descriptor: ()I</span><br><span class="line"></span><br><span class="line"> flags: (0x0001) ACC_PUBLIC</span><br><span class="line"></span><br><span class="line"> Code:</span><br><span class="line"></span><br><span class="line"> stack=1, locals=5, args_size=1</span><br><span class="line"></span><br><span class="line"> 0: iconst_1 // 将int = 1的值压入栈顶</span><br><span class="line"></span><br><span class="line"> 1: istore_1 // 弹出栈顶元素，存入位置为1的局部变量表</span><br><span class="line"></span><br><span class="line"> 2: iload_1 // 从位置为1的局部变量中取出元素压入栈顶</span><br><span class="line"></span><br><span class="line"> 3: istore_2 // 弹出栈顶元素，存入位置2的局部变量中</span><br><span class="line"></span><br><span class="line"> 4: iconst_3 // 将int = 3的值压入栈顶 （这里执行finally块中的代码了）</span><br><span class="line"></span><br><span class="line"> 5: istore_1 // 弹出栈顶元素，存入位置1的局部变量中</span><br><span class="line"></span><br><span class="line"> 6: iload_2 // 从位置为2的局部变量中取出元素压入栈顶</span><br><span class="line"></span><br><span class="line"> 7: ireturn // 返回栈顶元素2 (哈哈哈  看到没有，这里返回的是2，没有异常的话，这里方法就返回了)</span><br><span class="line"></span><br><span class="line"> 8: astore_2 // 将栈顶的异常引用，存入位置2的局部变量中  （这里就是异常捕获的代码了）</span><br><span class="line"></span><br><span class="line"> 9: iconst_2 // 将int = 2的值压入栈顶</span><br><span class="line"></span><br><span class="line"> 10: istore_1 // 弹出栈顶元素，存入位置1的局部变量中</span><br><span class="line"></span><br><span class="line"> 11: iload_1 // 从位置为1的局部变量中取出元素压入栈顶</span><br><span class="line"></span><br><span class="line"> 12: istore_3 // 弹出栈顶元素，存入位置3的局部变量中</span><br><span class="line"></span><br><span class="line"> 13: iconst_3 // 将int = 3的值压入栈顶</span><br><span class="line"></span><br><span class="line"> 14: istore_1 // 弹出栈顶元素，存入位置1的局部变量中</span><br><span class="line"></span><br><span class="line"> 15: iload_3 // 从位置为3的局部变量中取出元素压入栈顶</span><br><span class="line"></span><br><span class="line"> 16: ireturn // 返回栈顶元素 2</span><br><span class="line"></span><br><span class="line"> 17: astore 4 // 将栈顶异常引用存入位置为4的局部变量表中</span><br><span class="line"></span><br><span class="line"> 19: iconst_3 // 将int = 3的值压入栈顶</span><br><span class="line"></span><br><span class="line"> 20: istore_1 // 弹出栈顶元素，存入位置1的局部变量中</span><br><span class="line"></span><br><span class="line"> 21: aload  4 将位置为4的局部变量引用压入栈顶</span><br><span class="line"></span><br><span class="line"> 23: athrow // 将栈顶的异常抛出</span><br><span class="line"></span><br><span class="line"> Exception table: // 异常表</span><br><span class="line"></span><br><span class="line"> from to target type</span><br><span class="line"></span><br><span class="line"> 0  4  8  Class java/lang/Exception</span><br><span class="line"></span><br><span class="line"> 0  4 17  any</span><br><span class="line"></span><br><span class="line"> 8 13 17  any</span><br><span class="line"></span><br><span class="line"> 17 19 17  any</span><br></pre></td></tr></table></figure><p>如果你已经看懂了上面的字节码，你应该会豁朗开朗。原因其实就是在于这里开辟了两个局部变量，<code>finally</code>块中的代码也确实执行了，只是将变量存入了局部变量表中的另一个位置，并且通过这个例子，也可以发现，无论什么情况<code>finally</code>块中的代码都会执行。</p><h2 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h2><p>好了，本文到这里就差不多结束了。对于字节码的探索个人觉的还是非常有意思的，之后应该也会探索更多有意思的东西</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;因为字段表和方法表的结构类似，所以我们直接分析Java字节码的方法表内容，理解了方法表，自然就理解了字段表&lt;/p&gt;
&lt;h2 id=&quot;方法表&quot;
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JVM" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/"/>
    
      <category term="java字节码" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
    
      <category term="JVM" scheme="http://wangjunnan.github.io/tags/JVM/"/>
    
      <category term="java字节码" scheme="http://wangjunnan.github.io/tags/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>使用Java NIO实现一个HTTP服务器</title>
    <link href="http://wangjunnan.github.io/2019/04/19/%E4%BD%BF%E7%94%A8Java-NIO%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://wangjunnan.github.io/2019/04/19/使用Java-NIO实现一个HTTP服务器/</id>
    <published>2019-04-19T03:04:30.000Z</published>
    <updated>2019-09-27T05:52:47.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>一直以来都想写一个自己的http服务器，这次趁着稍微空闲了一些，赶紧码了一个<code>mini</code>版的。在这里跟大家分享一下编写的整个思路，总体来说，整个应用非常简单，目前也只是实现了最基本的静态资源访问，但对于想学习<code>Http</code>协议的同学来说，应该还是有所帮助</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>先简单介绍一下<code>HTTP</code>协议，<code>HTTP</code>协议是构建于<code>TCP/IP</code>协议之上的一个应用层协议，并且是无连接无状态的。</p><h3 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h3><p>http的请求报文由三部分组成</p><ul><li><p>状态行  <code>&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</code> method包含<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>等</p></li><li><p>请求头</p></li><li><p>消息主体</p></li></ul><p>下面是典型的http请求报文示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /static/home.html HTTP/1.1</span><br><span class="line"></span><br><span class="line">Host: localhost:8080</span><br><span class="line"></span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line"></span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36</span><br><span class="line"></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3</span><br><span class="line"></span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line"></span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br></pre></td></tr></table></figure><h3 id="http响应报文"><a href="#http响应报文" class="headerlink" title="http响应报文"></a>http响应报文</h3><p>响应报文跟请求报文类似，也由三部分组成</p><ul><li><p>状态行  这里需要关注下响应的各个状态所代表的含义，以及浏览器识别这些状态码会相应的做哪些事情</p></li><li><p>响应头</p></li><li><p>响应正文</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">Server: cloud http v1.0</span><br><span class="line"></span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...</span><br></pre></td></tr></table></figure><p><strong>##</strong> <strong>动手</strong></p><p>前面简单介绍了一下http协议的基本信息，下面就是源码实现了，我这里直接使用了Java NIO作为底层通信支撑，在实际的生产代码中，大多会选择封装良好的<code>netty</code>来作为稳定的底层通信</p><p>这里先放上项目源码 <a href="https://github.com/WangJunnan/cloudhttp" target="_blank" rel="noopener"><a href="https://github.com/WangJunnan/cloudhttp" target="_blank" rel="noopener">CloudHttp</a></a></p><h3 id="定义Request和Response"><a href="#定义Request和Response" class="headerlink" title="定义Request和Response"></a>定义Request和Response</h3><ul><li>Request</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * method</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * http协议版本</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String httpVersion;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 请求uri</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String uri;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 请求相对路径</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 请求头信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, String&gt; headers;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 请求参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, String&gt; attribute;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Response</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String protocol = <span class="string">"HTTP/1.1"</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, String&gt; headers;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> ByteArrayOutputStream outPutStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.code = HttpCode.STATUS_200.getCode();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.msg = HttpCode.STATUS_200.getMsg();</span><br><span class="line"></span><br><span class="line"> headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> headers.put(<span class="string">"Content-Type"</span>, <span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"> headers.put(<span class="string">"Server"</span>, <span class="string">"cloud http v1.0"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义请求响应解析类  <code>HttpParser</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(HttpParser.class);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * &lt;p&gt;解析http请求体&lt;/p&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buffers</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Request <span class="title">decodeReq</span><span class="params">(<span class="keyword">byte</span> [] buffers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> Request request = <span class="keyword">new</span> Request();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (buffers != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"> String resString = <span class="keyword">new</span> String(buffers);</span><br><span class="line"></span><br><span class="line"> logger.info(resString);</span><br><span class="line"></span><br><span class="line"> String[] headers = resString.trim().split(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (headers.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"> String firstline = headers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 按空格分割字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 method uri 协议版本</span></span><br><span class="line"></span><br><span class="line"> String mainInfo [] = firstline.split(<span class="string">"\\s+"</span>);</span><br><span class="line"></span><br><span class="line"> request.setMethod(mainInfo[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> request.setUri(URLDecoder.decode(mainInfo[<span class="number">1</span>], <span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_HttpParser_URLDecode, uri = &#123;&#125;"</span>, mainInfo[<span class="number">1</span>], e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> request.setHttpVersion(mainInfo[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解析header</span></span><br><span class="line"></span><br><span class="line"> Map&lt;String, String&gt; headersMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; headers.length; i++) &#123;</span><br><span class="line"></span><br><span class="line"> String entryStr = headers[i];</span><br><span class="line"></span><br><span class="line"> String entry [] = entryStr.trim().split(<span class="string">":"</span>);</span><br><span class="line"></span><br><span class="line"> headersMap.put(entry[<span class="number">0</span>].trim(), entry[<span class="number">1</span>].trim());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> request.setHeaders(headersMap);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解析参数</span></span><br><span class="line"></span><br><span class="line"> String uri = request.getUri();</span><br><span class="line"></span><br><span class="line"> Map&lt;String, String&gt; attribute = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> request.setPath(uri);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (StringUtils.isNotEmpty(uri)) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> indexOfParam = uri.indexOf(<span class="string">"?"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (indexOfParam &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 设置path</span></span><br><span class="line"></span><br><span class="line"> request.setPath(uri.substring(<span class="number">0</span>, indexOfParam));</span><br><span class="line"></span><br><span class="line"> String queryString = uri.substring(indexOfParam + <span class="number">1</span>, uri.length());</span><br><span class="line"></span><br><span class="line"> String paramEntrys [] = queryString.split(<span class="string">"&amp;"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (String paramEntry : paramEntrys) &#123;</span><br><span class="line"></span><br><span class="line"> String [] entry = paramEntry.split(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (entry.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"> String key = entry[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"> String value = entry.length &gt; <span class="number">1</span> ? entry[<span class="number">1</span>] : <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"> attribute.put(key, value);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> request.setAttribute(attribute);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> request;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * &lt;p&gt;返回http响应字节流&lt;/p&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encodeResHeader(Response response) &#123;</span><br><span class="line"></span><br><span class="line"> StringBuilder resBuild = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"> resBuild.append(response.getProtocol() + <span class="string">" "</span> + response.getCode() + <span class="string">" "</span> + response.getMsg());</span><br><span class="line"></span><br><span class="line"> resBuild.append(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line"> Map&lt;String, String&gt; headers = response.getHeaders();</span><br><span class="line"></span><br><span class="line"> headers.entrySet().forEach(entry -&gt; &#123;</span><br><span class="line"></span><br><span class="line"> resBuild.append(entry.getKey());</span><br><span class="line"></span><br><span class="line"> resBuild.append(<span class="string">": "</span>);</span><br><span class="line"></span><br><span class="line"> resBuild.append(entry.getValue());</span><br><span class="line"></span><br><span class="line"> resBuild.append(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> resBuild.append(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line"> String resString = resBuild.toString();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> [] bytes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> bytes = resString.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_encodeResHeader"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> bytes;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Java-nio-启动服务器"><a href="#使用Java-nio-启动服务器" class="headerlink" title="使用Java nio 启动服务器"></a>使用Java nio 启动服务器</h3><ul><li>NioServer</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> <span class="keyword">implements</span> <span class="title">Server</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(NioServer.class);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Thread serverThread;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">boolean</span> running = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> NioServer server;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> CloudService cloudService;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService requestWork = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NioServer <span class="title">getServerInstance</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">synchronized</span> (NioServer.class) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"> server = <span class="keyword">new</span> NioServer();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> server;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">NioServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.cloudService = <span class="keyword">new</span> CloudService();</span><br><span class="line"></span><br><span class="line"> port = Integer.valueOf(CloudHttpConfig.getValue(<span class="string">"port"</span>, <span class="string">"8080"</span>));</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (running) &#123;</span><br><span class="line"></span><br><span class="line"> logger.info(<span class="string">"服务器已经启动"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> serverThread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"> serverThread.start();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> serverSocketChannel.close();</span><br><span class="line"></span><br><span class="line"> serverThread.stop();</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_NioServer_stop"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打开ServerSocketChannel通道</span></span><br><span class="line"></span><br><span class="line"> serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//得到ServerSocket对象</span></span><br><span class="line"></span><br><span class="line"> serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line"> Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"> serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"> serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line"> selector.select();</span><br><span class="line"></span><br><span class="line"> Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line"> SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (selectedKeys.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line"> key = selectedKeys.next();</span><br><span class="line"></span><br><span class="line"> selectedKeys.remove();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line"> accept(key);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line"> read(key);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line"></span><br><span class="line"> write(key);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_NioServer_run"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> ServerSocketChannel serverSocketChannel = (ServerSocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line"> SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line"> socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"> socketChannel.register(key.selector(), SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_NioServer_accept"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Request <span class="title">read</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> Request request = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> readNum = socketChannel.read(readBuffer);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (readNum == -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"> socketChannel.close();</span><br><span class="line"></span><br><span class="line"> key.cancel();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> readBuffer.flip();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> [] buffers = <span class="keyword">new</span> <span class="keyword">byte</span>[readBuffer.limit()];</span><br><span class="line"></span><br><span class="line"> readBuffer.get(buffers);</span><br><span class="line"></span><br><span class="line"> readBuffer.clear();</span><br><span class="line"></span><br><span class="line"> request = HttpParser.decodeReq(buffers);</span><br><span class="line"></span><br><span class="line"> requestWork.execute(<span class="keyword">new</span> RequestWorker(request, key, cloudService));</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_NioServer_read"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> request;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"> ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(buffer == <span class="keyword">null</span> || !buffer.hasRemaining()) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line"> socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(!buffer.hasRemaining())&#123;</span><br><span class="line"></span><br><span class="line"> key.interestOps(SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"> buffer.clear();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> socketChannel.close();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理请求的-RequestWork类"><a href="#处理请求的-RequestWork类" class="headerlink" title="处理请求的 RequestWork类"></a>处理请求的 RequestWork类</h3><p>对于每一个进入的请求。都会单独启动一个线程来进行处理</p><ul><li>RequestWorker</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RequestWorker.class);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Request request;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> SelectionKey key;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> SocketChannel channel;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> CloudService cloudService;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">RequestWorker</span><span class="params">(Request request, SelectionKey key, CloudService cloudService)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.request = request;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.key = key;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.channel = (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.cloudService = cloudService;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> Response response = <span class="keyword">new</span> Response();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> cloudService.doService(request, response);</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (ViewNotFoundException e) &#123;</span><br><span class="line"></span><br><span class="line"> response.setCode(HttpCode.STATUS_404.getCode());</span><br><span class="line"></span><br><span class="line"> response.setMsg(HttpCode.STATUS_404.getMsg());</span><br><span class="line"></span><br><span class="line"> ByteArrayOutputStream outputStream = response.getOutPutStream();</span><br><span class="line"></span><br><span class="line"> InputStream inputStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"404.html"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> bytes [] = <span class="keyword">new</span> <span class="keyword">byte</span> [<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> ((len = inputStream.read(bytes)) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"> outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_requestWork_write404"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> [] resHeader = HttpParser.encodeResHeader(response);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> [] body = response.getOutPutStream().toByteArray();</span><br><span class="line"></span><br><span class="line"> ByteBuffer byteBuffer = ByteBuffer.allocate(resHeader.length + body.length);</span><br><span class="line"></span><br><span class="line"> byteBuffer.put(resHeader);</span><br><span class="line"></span><br><span class="line"> byteBuffer.put(body);</span><br><span class="line"></span><br><span class="line"> byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将输出流绑定至附件</span></span><br><span class="line"></span><br><span class="line"> key.attach(byteBuffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册写事件</span></span><br><span class="line"></span><br><span class="line"> key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line"></span><br><span class="line"> key.selector().wakeup();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义Servlet接口"><a href="#定义Servlet接口" class="headerlink" title="定义Servlet接口"></a>定义Servlet接口</h3><ul><li>CloudServlet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CloudServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 判断当前请求是否匹配 handler</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Request request)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 执行初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Request request, Response response)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 执行请求</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">doService</span><span class="params">(Request request, Response response)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>StaticViewServlet 定义一个处理静态资源的<code>StaticViewServlet</code>实现<code>CloudServlet</code>接口</li></ul><p>该静态资源处理器会自动拦截<code>static</code>路径下的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticViewServlet</span> <span class="keyword">implements</span> <span class="title">CloudServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(StaticViewServlet.class);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String staticRootPath;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Pattern p = Pattern.compile(<span class="string">"^/static/\\S+"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> String path = request.getPath();</span><br><span class="line"></span><br><span class="line"> Matcher matcher = p.matcher(path);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> matcher.matches();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> staticRootPath = CloudHttpConfig.getValue(<span class="string">"static.resource.path"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> String path = request.getPath();</span><br><span class="line"></span><br><span class="line"> String fileRelativePath = path.substring(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> String absolutePath = staticRootPath + <span class="string">"/"</span> + fileRelativePath;</span><br><span class="line"></span><br><span class="line"> RandomAccessFile randomAccessFile = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> randomAccessFile = <span class="keyword">new</span> RandomAccessFile(absolutePath, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"> FileChannel fileChannel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line"> ByteBuffer htmBuffer = ByteBuffer.allocate((<span class="keyword">int</span>)fileChannel.size());</span><br><span class="line"></span><br><span class="line"> fileChannel.read(htmBuffer);</span><br><span class="line"></span><br><span class="line"> htmBuffer.flip();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> [] htmByte = <span class="keyword">new</span> <span class="keyword">byte</span>[htmBuffer.limit()];</span><br><span class="line"></span><br><span class="line"> htmBuffer.get(htmByte);</span><br><span class="line"></span><br><span class="line"> response.getOutPutStream().write(htmByte);</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> ViewNotFoundException();</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_StaticViewServlet_doService 异常"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义-CloudService"><a href="#定义-CloudService" class="headerlink" title="定义 CloudService"></a>定义 CloudService</h3><p><code>CloudService</code>是用于盛放<code>Servlet</code>的容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> List&lt;CloudServlet&gt; cloudServlets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">CloudService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> cloudServlets.add(<span class="keyword">new</span> StaticViewServlet());</span><br><span class="line"></span><br><span class="line"> cloudServlets.add(<span class="keyword">new</span> MappingUrlServlet());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> CloudServlet servlet = doSelect(request);</span><br><span class="line"></span><br><span class="line"> servlet.init(request, response);</span><br><span class="line"></span><br><span class="line"> servlet.doService(request, response);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> CloudServlet <span class="title">doSelect</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (CloudServlet cloudServlet : cloudServlets) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (cloudServlet.match(request)) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> cloudServlet;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> MappingUrlServlet();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后-编写启动类"><a href="#最后-编写启动类" class="headerlink" title="最后  编写启动类"></a>最后  编写启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudHttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 启动服务器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> NioServer.getServerInstance().start();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> startServer();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li><p>启动服务器</p></li><li><p>浏览器访问  <code>http://localhost:8080/static/home.html</code></p></li></ol><p>响应页面</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-aa1ea0a3a1d1f266.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h2><p>本文只是一个示例，仅仅实现了静态资源访问。做为自娱自乐的项目 +——=</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;一直以来都想写一个自己的http服务器，这次趁着稍微空闲了一些，赶紧码了一个&lt;code&gt;mini&lt;/code&gt;版的。在这里跟大家分享一下编写
      
    
    </summary>
    
      <category term="NIO" scheme="http://wangjunnan.github.io/categories/NIO/"/>
    
      <category term="HTTP" scheme="http://wangjunnan.github.io/categories/NIO/HTTP/"/>
    
    
      <category term="NIO" scheme="http://wangjunnan.github.io/tags/NIO/"/>
    
      <category term="HTTP" scheme="http://wangjunnan.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码常量池</title>
    <link href="http://wangjunnan.github.io/2019/04/17/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <id>http://wangjunnan.github.io/2019/04/17/Java字节码常量池/</id>
    <published>2019-04-17T07:48:48.000Z</published>
    <updated>2019-09-27T05:52:47.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上篇文章简单介绍了<code>java Class</code> 字节码文件的基本格式。本文我们直接通过阅读字节码文件来进一步理解字节码中的常量池结构</p><p>首先我们新建一个最简单的Java文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后使用文本编辑器打开，可以看到<code>Class</code>文件最原始的16进制格式。最明显的<code>Class</code>文件的魔数<code>cafe babe</code>一眼就能看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">cafe babe 0000 0034 0022 0a00 0600 1409</span><br><span class="line">0015 0016 0800 170a 0018 0019 0700 1a07</span><br><span class="line">001b 0100 063c 696e 6974 3e01 0003 2829</span><br><span class="line">5601 0004 436f 6465 0100 0f4c 696e 654e</span><br><span class="line">756d 6265 7254 6162 6c65 0100 124c 6f63</span><br><span class="line">616c 5661 7269 6162 6c65 5461 626c 6501</span><br><span class="line">0004 7468 6973 0100 144c 636f 6d2f 796d</span><br><span class="line">6d2f 6167 656e 742f 5465 7374 3b01 0004</span><br><span class="line">6d61 696e 0100 1628 5b4c 6a61 7661 2f6c</span><br><span class="line">616e 672f 5374 7269 6e67 3b29 5601 0004</span><br><span class="line">6172 6773 0100 135b 4c6a 6176 612f 6c61</span><br><span class="line">6e67 2f53 7472 696e 673b 0100 0a53 6f75</span><br><span class="line">7263 6546 696c 6501 0009 5465 7374 2e6a</span><br><span class="line">6176 610c 0007 0008 0700 1c0c 001d 001e</span><br><span class="line">0100 0b68 656c 6c6f 2077 6f72 6c64 0700</span><br><span class="line">1f0c 0020 0021 0100 1263 6f6d 2f79 6d6d</span><br><span class="line">2f61 6765 6e74 2f54 6573 7401 0010 6a61</span><br><span class="line">7661 2f6c 616e 672f 4f62 6a65 6374 0100</span><br><span class="line">106a 6176 612f 6c61 6e67 2f53 7973 7465</span><br><span class="line">6d01 0003 6f75 7401 0015 4c6a 6176 612f</span><br><span class="line">696f 2f50 7269 6e74 5374 7265 616d 3b01</span><br><span class="line">0013 6a61 7661 2f69 6f2f 5072 696e 7453</span><br><span class="line">7472 6561 6d01 0007 7072 696e 746c 6e01</span><br><span class="line">0015 284c 6a61 7661 2f6c 616e 672f 5374</span><br><span class="line">7269 6e67 3b29 5600 2100 0500 0600 0000</span><br><span class="line">0000 0200 0100 0700 0800 0100 0900 0000</span><br><span class="line">2f00 0100 0100 0000 052a b700 01b1 0000</span><br><span class="line">0002 000a 0000 0006 0001 0000 0009 000b</span><br><span class="line">0000 000c 0001 0000 0005 000c 000d 0000</span><br><span class="line">0009 000e 000f 0001 0009 0000 0037 0002</span><br><span class="line">0001 0000 0009 b200 0212 03b6 0004 b100</span><br><span class="line">0000 0200 0a00 0000 0a00 0200 0000 0b00</span><br><span class="line">0800 0c00 0b00 0000 0c00 0100 0000 0900</span><br><span class="line">1000 1100 0000 0100 1200 0000 0200 13</span><br></pre></td></tr></table></figure><h2 id="如何从上面的文件中找到常量池所在的位置呢"><a href="#如何从上面的文件中找到常量池所在的位置呢" class="headerlink" title="如何从上面的文件中找到常量池所在的位置呢"></a>如何从上面的文件中找到常量池所在的位置呢</h2><p>在上篇文章中我们已经分析过<code>Class</code>文件文件格式了，常量池的位置紧随在版本号之后，也就是从第9个字节开始就是常量池的内容了，下面就让我们一起来看下常量池的具体内容</p><h3 id="constant-pool-count-u2"><a href="#constant-pool-count-u2" class="headerlink" title="constant_pool_count u2"></a>constant_pool_count u2</h3><p>从第9个字节开始往后的两个字节，是<code>constant_pool_count</code>，我们把它叫做常量计数器，比较特殊的是它的下标是从1开始的，也就是说真正的常量池数量是<code>constant_pool_count - 1</code>个，那好现在让我们来看看上面的那个普通<code>Class</code>文件包含了多少个常量表（<code>cp_info</code>）</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-1e1c7e2eecf80bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常量计数"></p><p>可以看到<code>constant_pool_count</code>标识位是<code>0022</code>，转为10进制就是34。也就是说包含<code>34 - 1 = 33</code>个常量表内容</p><h3 id="cp-info"><a href="#cp-info" class="headerlink" title="cp_info"></a>cp_info</h3><p>上文经过分析我们已经确定了字节码文件包含的常量表个数，那么接下来我们要具体怎么看呢？</p><p>下面让我们来具体分析下<code>cp_info</code>的结构</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-e45775e88817026d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以看到每个<code>cp_info</code>的第一个字节位都是<code>tag</code>，用于标识常量表所属的具体类型，上篇文章我们说过，常量表之所以非常复杂，就是因为它的类型众多，有多大14种类型。那么这些类型的区分就是通过<code>tag</code>来区分。我们会逐个分析这14种类型</p><p>先来看下这14常量池类型</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-5f84affafe924089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>还是回到上述字节码的16进制文件，我们接着往下看</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-e413777a45543d46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以看到<code>tag = 10</code>，根据上文我们列出的细分类型可以确定这第一个出现的常量表类型是<code>constant_Methodref_info</code>。那好现在我们再去具体的看下<code>constant_Methodref_info</code>表的具体内容</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-10a980be4439b580.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="constant_Methodref_info.png"></p><p>可以看到紧跟在<code>tag</code>之后其实是两项index索引值，分别指向<code>constant_Class_info</code>和<code>constant_NameAndType_info</code>。</p><p>继续往下阅读，可以知道具体的索引值分别为<code>0006</code>，<code>0014</code>。也就是指向常量池的第6项和第20项</p><p>下面为了方便阅读，我们直接使用<code>javap -v Test</code>命令生成方便我们阅读的字节码文件，当然如果有兴趣的话，直接阅读源文件也是oK的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class com.ymm.agent.Test</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #5                          // com/ymm/agent/Test</span><br><span class="line">  super_class: #6                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #23            // hello world</span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/ymm/agent/Test</span><br><span class="line">   #6 = Class              #27            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/ymm/agent/Test;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               Test.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               hello world</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/ymm/agent/Test</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.ymm.agent.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">.... 省略其他字节码</span><br></pre></td></tr></table></figure><p>通过<code>javap</code> 生成的字节码文件，看起来就舒服多了。现在继续回到第一个常量池项<code>constant_Methodref_info</code>，可以知道它是由<code>constant_Class_info</code>，<code>constant_NameAndType_info</code>两项的索引值组成，根据索引值<code>6</code>,<code>20</code>我们可以找到具体常量池项内容。</p><p>先找到索引值为<code>6</code>的<code>constant_Class_info</code>的内容，可以发现其具体内容也是指向了一个索引值<code>27</code>，继续找索引值为<code>27</code>常量项</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-5c7eb023de534a0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>找到索引值为<code>27</code>的常量项，可以发现是一个<code>constant_utf8_info</code>类型的字符串(java/lang/Object)，这也就是我们之前提到的类的全限定名称</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-22a9e1eb96234b8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>到目前为止大家应该已经找到了阅读常量池的感觉了，那么我们去查看索引项为<code>20</code>的<code>constant_NameAndType_info</code>的方法也是一样的</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-4332f33c24364301.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><code>constant_NameAndType_info</code>指向索引值为<code>7</code>和<code>8</code>的内容</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-0e0729faf2be3012.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以知道方法名称为<code>init</code>，类型为<code>void</code>方法</p><p>到目前为止我们大概可以知道此常量池的第一项表示其实是一个无参的构造方法，并且是编译器为我们自动生成的</p><p>其实大多数复杂的常量池内容最终都会索引到一个<code>constant_utf8_info</code>字符串类型，用于描述类全限定名，方法或字段名称及描述符等等 ..</p><h2 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h2><p>本篇文章我们只是通过一个示例来阅读<code>Class</code>文件的常量池内容，具体的常量池结构在上篇文章中我们都有列出，并且阅读的方法也是与本文类似。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;上篇文章简单介绍了&lt;code&gt;java Class&lt;/code&gt; 字节码文件的基本格式。本文我们直接通过阅读字节码文件来进一步理解字节码中的
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JVM" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/"/>
    
      <category term="java字节码" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
    
      <category term="JVM" scheme="http://wangjunnan.github.io/tags/JVM/"/>
    
      <category term="java字节码" scheme="http://wangjunnan.github.io/tags/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java Class文件结构</title>
    <link href="http://wangjunnan.github.io/2019/04/04/Java-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://wangjunnan.github.io/2019/04/04/Java-Class文件结构/</id>
    <published>2019-04-04T07:47:26.000Z</published>
    <updated>2019-09-27T05:52:47.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们都知道java是跨平台的，原因就在于各个平台的java虚拟机可以载入和执行同一种平台无关的字节码文件，也就是说java虚拟机不与包括Java在内的任何语言绑定，只于<code>Class</code>文件这种二进制格式文件所关联。</p><p>基于这样的设计，到目前为止已经出现了很多基于Java虚拟机的语言</p><p>如<code>groovy</code>最终都会编译成<code>class</code>文件</p><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p>一个Class文件唯一对应一个类或接口</p><p>现在让我们来看下<code>Class</code>文件的基本结构</p><p>Class文件以8位字节为基本单位的二进制文件，<strong>各个数据项目严格的按照顺序紧凑的排列在<code>Class</code>文件之中，中间没有任何分隔符，这使得整个<code>Class</code>文件中存储的内容几乎全部是运行时的必要数据</strong></p><p><code>Class</code>文件的二进制文件只有两种数据类型：无符号数和表，后面的解析都会以这两种数据类型为基础</p><ul><li>无符号数</li></ul><p>无符号数是最基本的数据类型，以<code>u1</code>,<code>u2</code>,<code>u4</code>,<code>u8</code>来分别代表1个字节，2个字节，4个字节，8个字节的无符号数，无符号数用来描述数字，索引引用，数量值，以及以UTF-8编码的字符串</p><ul><li>表</li></ul><p>表则是由多个无符号数或<strong>其他表组成的复合数据结构</strong>，表的名称一般以<code>_info</code>结尾。<strong>所以整个<code>Class</code>文件其实就是一张特殊的表</strong></p><p>下面表中所列的就是一个<code>Class</code>按顺序排列的数据结构</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic 魔数 标识Class文件</td><td>1</td></tr><tr><td>u2</td><td>minor_version 次版本号</td><td>1</td></tr><tr><td>u2</td><td>major_version 主版本号</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count 常量表集合数量</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool 常量表</td><td>constant_pool_count - 1</td></tr><tr><td>u2</td><td>access_flag 访问标识</td><td>1</td></tr><tr><td>u2</td><td>this_class 类索引</td><td>1</td></tr><tr><td>u2</td><td>super_class 父类索引</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count 接口索引数量</td><td>1</td></tr><tr><td>u2</td><td>interfaces 接口索引</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count 字段表集合数量</td><td>1</td></tr><tr><td>field_info</td><td>fields 字段表</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count 方法表集合数量</td><td>1</td></tr><tr><td>method_info</td><td>methods 方法表</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count 属性表集合数量</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes 属性表</td><td>attributes_count</td></tr></tbody></table><p>下面依次来解读表中每个类型</p><h3 id="魔数和版本号"><a href="#魔数和版本号" class="headerlink" title="魔数和版本号"></a>魔数和版本号</h3><p>头4个字节称为<code>Class</code>文件的魔数，魔数的作用是标识此文件能被Java虚拟机接受的<code>Class</code>文件，其实不止<code>Class</code>文件有魔数这个概念，包括其他很多文件格式出于安全的考虑也都会有魔数这个概念，魔数都是固定不变的，如<code>Class</code>文件的魔数就是<code>cafebabe</code></p><p>紧接着魔数之后的是版本号，第5 6个字节表示的是次版本号，第7 8个字节表示的是主版本号。版本号都是向下兼容的</p><h3 id="常量池表"><a href="#常量池表" class="headerlink" title="常量池表"></a>常量池表</h3><p>读懂常量池表对于阅读Class字节码非常重要，下面我们将以大篇幅分析常量池表</p><p>常量池是<code>Class</code>文件中出现的第一个表结构类型，同时也是占用<code>Class</code>文件最大空间的类型之一。由于常量池表的数量不是固定的，所以在常量池的入口有一项<code>u2</code>类型的数据，来代表常量池的数量。并且常量池比较特殊，容量计数是从1开始而不是从0开始，所以实际的常量池数量是<code>constant_pool_count - 1</code></p><p>常量池中主要存放两大类变量: 字面量和符号引用。字面量类似常量的概念，而符号引用则引至编译原理的概念，包括三类(类和接口的全限定名，字段的名称和描述符，方法的名称和描述符)，这里要注意的是，Java在<code>javac</code>编译的时候不会进行<code>Class</code>文件的动态连接，<strong>只有在运行时才会进行具体的<code>Class</code>文件的解析操作</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-9a9644b61564b4b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常量池分类类型"></p><h4 id="常量池表结构"><a href="#常量池表结构" class="headerlink" title="常量池表结构"></a>常量池表结构</h4><p>上文两大类的常量池类型细分之后，到JDK1.7之后增加到了14种。之所以说常量池是最复杂的结构，就是因为这14种不同的类型都有不同的表结构，下面我们来简单看下这14种结构</p><p>每种常量类型的起始位都有一个<code>u1</code>类型的tag标识符，用于标识当前的常量类型</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-100be34bc99676c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="截图至深入理解java虚拟机"><br><img src="http://upload-images.jianshu.io/upload_images/2717496-16c3df5c9fded87b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="截图至深入理解java虚拟机"></p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>访问标志用于识别类或接口层面的信息，标识是否为<code>public</code>，<code>abstract</code>，<code>final</code>，<code>注解</code>，<code>枚举</code>等</p><h3 id="类索引-父类索引-接口索引"><a href="#类索引-父类索引-接口索引" class="headerlink" title="类索引 父类索引 接口索引"></a>类索引 父类索引 接口索引</h3><p>类索引和父类索引都是一个<code>u2</code>类型的数据，而接口索引则是一组<code>u2</code>类型的集合，所以接口索引入口的第一项为一个<code>u2</code>类型的计数，表示有几个接口索引</p><p>类索引和接口索引的具体值是一个<code>u2</code>的数据项，并且指向一个<code>CONSTANT_Class_info</code>常量池表类型在常量池中的偏移量</p><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表用于描述接口或类中声明的变量，包括<strong>类级变量和实际级变量，不包括在方法内部声明的局部变量</strong></p><p>包含的信息主要有这几种: <code>字段作用域(private,protact,public)</code>，<code>是否static修饰</code>，<code>可变性</code>，<code>volatile 修饰</code>，<code>可否被序列化</code>，<code>字段类型(基本类型，引用，数组)</code>，<code>字段名称</code></p><p>字段表结构</p><table><thead><tr><th>类型</th><th>名称</th><th>数量 </th></tr></thead><tbody><tr><td>u2</td><td>access_flas</td><td>1 </td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>属性表</td><td>attributes_count</td></tr></tbody></table><h4 id="access-flas"><a href="#access-flas" class="headerlink" title="access_flas"></a>access_flas</h4><p>我们来看下字段<code>access_flas</code>访问标识可选的类型</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否public </td></tr><tr><td>ACC_PRIVARE</td><td>0x0002</td><td>字段是否private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否volatile</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>是否 transient</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为枚举类型</td></tr></tbody></table><p>看个例子，如果<code>access_flas</code>为<code>0x0019</code>，则标识了<code>ACC_PUBLIC</code>，<code>ACC_STATIC</code>，<code>ACC_FINAL</code>三种类型</p><h4 id="name-index和descriptor-index"><a href="#name-index和descriptor-index" class="headerlink" title="name_index和descriptor_index"></a>name_index和descriptor_index</h4><p>跟在<code>access_flas</code>之后是<code>name_index(简单名称)</code>和<code>descriptor_index(描述符)</code>。包括之前出现的<code>全限定名</code>，这里解释一下这几个名称。全限定名称一般来说是指<code>org/xxx/TestClass</code>这种类型的名称，可以理解为类的路径，简单名称就更加容易理解了，例如方法<code>inc()</code>的简单名称值的就是<code>inc</code></p><p>描述符相对于上面的两种稍复杂一些，<strong>描述符的作用是用来描述字段的数据类型，方法的参数列表和返回值</strong>，根据描述符规则，基本数据类型（byte,char,int,long,float,double,short,boolean）以及代表无返回值的<code>void</code>类型都用一个大写字符来表示，而对象类型则用<code>L</code>加对象的全限定名来表示</p><p>具体的列在了下表中</p><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>float</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>S</td><td>short</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>V</td><td>void</td></tr><tr><td>L</td><td>对象类型 如 Ljava/lang/Object</td></tr></tbody></table><p>对于数组类型，每一纬度使用一个前置的<code>[</code>来表示，如定义一个<code>java.lang.String []</code>的数组类型，将被记录为<code>[[Ljava/lang/String;</code></p><p>用描述符来描述方法时，按照先参数列表后返回值的顺序描述，参数列表严格按照顺序放在<code>()</code>内，如方法<code>void inc()</code>的描述符为<code>()V</code>，方法<code>int inc(int i, double)</code>的描述符为<code>(ID)I</code></p><p>在描述符之后，紧跟着是一个属性表集合，属性表集合可以为空，</p><h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><p><strong>方法表的组成与属性表的组成是完全一致的</strong>，访问标识符的取值略有不同</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>方法是否public </td></tr><tr><td>ACC_PRIVARE</td><td>0x0002</td><td>方法是否private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>方法是否protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>方法是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>方法是否final</td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>方法是否同步</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>方法是否由编译器产生的桥接方法</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>方法是否接受不定蚕食</td></tr><tr><td>ACC_NATIVE</td><td>0x0100</td><td>方法是否为native</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>方法是否为abstract</td></tr><tr><td>ACC_STRICTFP</td><td>0x0800</td><td>方法是否为strictfp</td></tr><tr><td>SYNTHETIC</td><td>0x1000</td><td>方法由编译器自动产生</td></tr></tbody></table><p>那么这里大家可能会有疑问，方法里的java代码去哪了呢？ 答案就是在方法表的属性表集合中，有一个<code>code</code>属性，那里存放了编译成字节码的Java代码。对于属性表，在下文会提到</p><h3 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h3><p>属性表，前文已经提到了多次。包括<code>Class</code>文件本身，<code>方法表</code>，<code>字段表</code>都有携带自己的属性表集合，用于描述专有场景信息</p><p>并且属性表与<code>Class</code>文件其他数据项要求不同，各个属性不要求严格的顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息</p><p>下面我们来看几个关键属性</p><h4 id="code-属性"><a href="#code-属性" class="headerlink" title="code 属性"></a>code 属性</h4><p>java程序方法体中的代码<code>javac</code>编译器处理后，最终变为字节码子令存储在<code>Code</code>属性内</p><h4 id="Exceptions-属性"><a href="#Exceptions-属性" class="headerlink" title="Exceptions 属性"></a>Exceptions 属性</h4><p>列举方法可能会抛出的异常</p><h4 id="LineNumberTable-属性"><a href="#LineNumberTable-属性" class="headerlink" title="LineNumberTable 属性"></a>LineNumberTable 属性</h4><p>描述java源码行数和字节码行数的对应关系，前者是字节码行，后者是源码行</p><h4 id="LocalVariableTable-属性"><a href="#LocalVariableTable-属性" class="headerlink" title="LocalVariableTable 属性"></a>LocalVariableTable 属性</h4><p>描述栈局部变量和源码中定义的变量的关系.这项是可选的，可使用<code>javac -g:none</code>或<code>javac -g:vars</code>命令关闭生成这项信息</p><h4 id="SourceFile-属性"><a href="#SourceFile-属性" class="headerlink" title="SourceFile 属性"></a>SourceFile 属性</h4><p>用于记录Class源码文件的文件名称，这个属性是可选的。可使用<code>javac -g:none</code>或<code>javac -g:source</code>命令关闭生成这项信息</p><h4 id="ConstantValue-属性"><a href="#ConstantValue-属性" class="headerlink" title="ConstantValue 属性"></a>ConstantValue 属性</h4><p>通知虚拟机为静态变量赋值</p><h4 id="InnerClasses-属性"><a href="#InnerClasses-属性" class="headerlink" title="InnerClasses 属性"></a>InnerClasses 属性</h4><p>用于记录内部类与宿主类之间的关系</p><h4 id="Deprecated-Synthetic-属性"><a href="#Deprecated-Synthetic-属性" class="headerlink" title="Deprecated Synthetic 属性"></a>Deprecated Synthetic 属性</h4><p><code>Deprecated</code> 标识某个类，字段或方法过期<br><code>Synthetic</code> 标识此字段不由Java源码直接产生，由编译器自动添加</p><h4 id="StackMapTable-属性"><a href="#StackMapTable-属性" class="headerlink" title="StackMapTable 属性"></a>StackMapTable 属性</h4><p>这个属性会在虚拟机加载完字节码后的验证阶段被使用</p><h4 id="Signature-属性"><a href="#Signature-属性" class="headerlink" title="Signature 属性"></a>Signature 属性</h4><p><code>Signature</code>在<code>JDK1.5</code>之后被添加，用于记录泛型签名信息。之所以要用这么一个属性去记录泛型信息，是因为Java语言的泛型采用的是擦除法实现的伪泛型，在<code>Code</code>属性中，泛型信息在编译之后统统都被擦除掉了。使用的擦除法的原因是这样子实现比较简单，只需要修改<code>javac</code>编译器就可以实现了，运行时也可以节省一些空间。坏处就是运行时无法拿到泛型信息。<code>Signature</code>就是为了弥补这个缺陷而设置的，现在的Java API反射能够获取到的泛型信息也来自这个属性</p><h4 id="BootStrapMathods-属性"><a href="#BootStrapMathods-属性" class="headerlink" title="BootStrapMathods 属性"></a>BootStrapMathods 属性</h4><p><code>BootStrapMathods</code>是JDK 1.7之后增加到规范中的，这个属性用于保存<code>invokedynamic</code>指令引用的引导方法限定符。本篇文章暂不赘述这个指令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;我们都知道java是跨平台的，原因就在于各个平台的java虚拟机可以载入和执行同一种平台无关的字节码文件，也就是说java虚拟机不与包括Ja
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JVM" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/"/>
    
      <category term="java字节码" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
    
      <category term="JVM" scheme="http://wangjunnan.github.io/tags/JVM/"/>
    
      <category term="java字节码" scheme="http://wangjunnan.github.io/tags/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载机制</title>
    <link href="http://wangjunnan.github.io/2019/04/02/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://wangjunnan.github.io/2019/04/02/Java类加载机制/</id>
    <published>2019-04-02T07:35:40.000Z</published>
    <updated>2019-09-27T05:52:47.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>介绍一下java类加载的过程</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到java虚拟机内存中开始，被分为7个阶段，包括<code>加载</code>，<code>验证</code>，<code>准备</code>，<code>解析</code>，<code>初始化</code>，<code>使用</code>，<code>卸载</code></p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-793f9be59d3a7ea2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这里我们暂且主要看加载阶段和初始化阶段，java虚拟机主要是做了三件事情</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ol><li>通过类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的<code>Class</code>对象</li></ol><p>注意这里虚拟机并没有规定类的二进制字节流的来源，所以我们其实通过自定义类加载器来实现从其他途径（如网络中获取）中获取Class文件的二进制字节流</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化阶段是类加载的最后一个阶段，可以理解成<code>初始静态块及静态变量</code>，在准备阶段，静态变量已经赋了初始值，初始化阶段赋的就是具体的值。</p><p><strong>初始化的必要条件，并且有且只有这5种情况才会触发类的初始化</strong></p><ol><li>遇到<code>new</code>,<code>getstatic</code>,<code>putstatic</code>,<code>invokestatic</code>这四个字节码时，如果还未执行类的初始化则会执行初始化</li><li>使用<code>java.lang.reflect</code>包进行反射调用时，如果还没有进行初始化，则会执行初始化</li><li>当初始化一个类时，发现其父类还没有初始化，则会初始化其父类</li><li>当虚拟机启动时，用户需要指定一个主类，这个主类会被初始化</li><li>使用jdk7动态语言支持时，会执行初始化</li></ol><p>以上5中场景，称为对一个类的主动引用。除这5种方式之外，任何其他引用都被称为被动引用，并且都不会触发类的初始化。</p><p>下面举三种情况来说明被动引用</p><ul><li>通过子类引用父类静态字段，不会触发父类的初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class BoshiCat extends Cat &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;BoshiCat init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Cat &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Cat init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int value = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(BoshiCat.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 输出 10</span><br></pre></td></tr></table></figure><ul><li>通过数组来引用类，不会触发引用类的初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Cat []  cats = new Cat[10];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出 10</span><br></pre></td></tr></table></figure><ul><li>引用<code>static final</code>修饰的常量，因为常量在编译阶段就被写进了常量池</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Cat init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static final int value = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Cat.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 输出 10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;介绍一下java类加载的过程&lt;/p&gt;
&lt;h2 id=&quot;类加载的时机&quot;&gt;&lt;a href=&quot;#类加载的时机&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JVM" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/"/>
    
    
      <category term="JVM" scheme="http://wangjunnan.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock可重入锁源码分析</title>
    <link href="http://wangjunnan.github.io/2019/03/25/ReentrantLock%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://wangjunnan.github.io/2019/03/25/ReentrantLock可重入锁源码分析/</id>
    <published>2019-03-25T08:19:02.000Z</published>
    <updated>2019-09-27T05:52:47.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>ReentrantLock</code>可重入锁，也是日常使用除了<code>synchronized</code>关键字最多的锁。从字面上理解可重入的意思就是<strong>同一个线程</strong>可以重复加锁，当然<code>synchronized</code>关键字也是支持可重入的，其实它们的主要功能也是类似的，但是相比较来说，<code>ReentrantLock</code>功能更灵活丰富，例如<code>ReentrantLock</code>支持设置公平锁或非公平锁，支持分组唤醒需要唤醒的线程们，而不是像<code>synchronized</code>要么随机唤醒一个线程要么唤醒全部线程。</p><p>整个<code>ReentrantLock</code>的实现基于<code>AQS</code>独占锁，这个在上篇文章已经详细分析过</p><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><ul><li>ReentrantLock.class</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/2717496-de0aa2e9894c7a7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-94b5fd02f6a75420.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><code>ReentrantLock</code>实现了<code>Lock</code>接口，但是通过查看源码可知<code>ReentrantLock</code>的具体实现其实都委托给了<code>NonfairSyns（非公平锁）</code>或则<code>FairSync（公平锁）</code>两个类实现，<code>NonfairSyns</code>和<code>FairSync</code>继承了抽象静态类<code>Sync</code>，<code>Sync</code>则是<code>AQS</code>的子类</p><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 非公平锁"></a>公平锁 非公平锁</h2><p><code>ReentrantLock</code>支持公平锁，那么什么是公平锁呢？简单的理解就是多个线程获取锁的顺序应该是按照时间的先后，先来的先获取。也就是说公平锁绝对满足先进先出的队列形式。</p><p>我们从<code>AQS</code>同步队列来理解的话，可以认为<code>公平锁</code>每次都是从同步队列中的第一个节点获取到锁，而非公平锁则不一定，有可能占据锁的线程刚释放锁，同步队列中的线程还未来得及获取到锁，就被新请求锁的线程获取了。当然这里要注意，对于已经加入<code>AQS</code>同步队列的线程来说，无论<code>公平锁</code>还是<code>非公平锁</code>都是一样的，按照队列先后顺序获取。</p><p>下面我们来看下<code>ReentrantLock</code>的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ReentrantLock</code>无参构造默认是非公平锁</li><li>可以通过设置参数将<code>ReentrantLock</code>设置为公平锁</li></ul><p>从代码层面看实现区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平锁获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公平锁获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到很明显的区别，<code>非公平锁</code>获取锁，只要当前没有持锁线程，新加入的线程都有机会获取到锁</p><h2 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h2><p>上文说过，可重入的概念只针对同一个线程，那么<code>ReentrantLock</code>是如何实现同一个线程可重入的呢？</p><p>这就又要涉及到<code>AQS state</code>的概念，在<code>AQS</code>内部维护了一个状态值<code>state</code>，当有一个线程获取到锁，<code>state</code>值就会<code>+1</code>，对于独占锁来说，不同的线程要想获取锁，<code>state</code>值必须为0。下面我们就通过源码来看看<code>ReentrantLock</code>是如何实现可重入性的</p><p>以非公平锁为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前获取锁的线程为0，则直接获取</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 调用AQS模板方法，会调用子类的tryAcquire</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平方法尝试获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果当前获取锁的线程为0，则直接获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前获取锁的线程为当前请求线程，则将state + 1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先会判断<code>state</code>状态是否为0(也就是当时还没有持锁线程)，如果为0的话则直接获取锁</li><li><code>state</code>状态不为0.则判断与当前持锁线程是否为同一个线程，是的话，则<code>state</code>自增1.获取锁成功</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，<code>ReentrantLock</code>和<code>synchronized</code>非常相似，但是也还是比较大的区别，<code>ReentrantLock</code>的功能更丰富灵活，<code>synchronized</code>只支持非公平锁，<code>ReentrantLock</code>可以支持<code>公平锁</code>，并且<code>ReentrantLock</code>支持<code>Condition</code>等，可以批量分组唤醒等待线程。</p><p>`</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;可重入锁，也是日常使用除了&lt;code&gt;synchronized&lt;/code&gt;关键字最多的
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发" scheme="http://wangjunnan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java AQS 源码解析</title>
    <link href="http://wangjunnan.github.io/2019/03/12/Java-AQS-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://wangjunnan.github.io/2019/03/12/Java-AQS-源码解析/</id>
    <published>2019-03-12T08:21:26.000Z</published>
    <updated>2019-09-27T05:52:47.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>AQS</code>全称<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>，是Java 并发包中的一个抽象类，我们一般把它叫做抽象队列同步器，如我们常用的可重入锁<code>ReentrantLock</code>的内部实现就是基于<code>AQS</code>，理解<code>AQS</code>的内部源码实现对于我们深入理解使用java并发包中的各个功能非常重要。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>AQS</code>内部维护了一个双向链表队列来管理多个线程。简单介绍一下就是，当有一个新的线程去尝试获取锁，这是如果获取失败，<code>AQS</code>则会将此线程封装成一个<code>Node</code>节点，并将此节点加入到内部维护的队列中。</p><p>上面简单的描述了线程获取锁的过程，那么<code>AQS</code>是使用什么来确认当前线程是否可以尝试获取锁呢？</p><p>其实<code>AQS</code>内部为了一个<code>volatile int state</code>变量来表示当前资源是否已经被其他线程占有，对于独占锁来说，只有当<code>state = 0</code>时才说明该资源当前没有线程占有，后续线程可以开始争抢改资源，后续线程需要通过<code>CAS</code>操作来确保修改<code>state</code>变量成功才能成功抢占该资源。</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-b08b642e54d9c66a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><p><code>AQS</code>内部提供了三组核心方法用来实现一个同步组件。三组方法从字面意思上区分可以分为两种类型：独占锁相关，共享锁相关</p><ol><li>访问<code>state</code>有三种方法</li></ol><ul><li><p><code>getState()</code>  获取同步状态</p></li><li><p><code>setState()</code>  设置同步状态（非<code>CAS</code>操作）</p></li><li><p><code>compareAndSetState()</code>  通过<code>CAS</code>操作修改</p></li></ul><ol start="2"><li>一组抽象方法，需要子类实现，主要是获取同步锁并判断是否成功的操作</li></ol><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean tryAcquire(int arg)</td><td>独占式获取同步状态</td></tr><tr><td>boolean tryRelease(int arg)</td><td>独占式释放同步状态</td></tr><tr><td>int tryAcquireShared(int arg)</td><td>共享式获取同步状态</td></tr><tr><td>boolean tryReleaseShared(int arg)</td><td>共享式释放同步状态</td></tr><tr><td>boolean isHeldExclusively()</td><td>检测当前线程是否获取独占锁</td></tr></tbody></table><ol start="3"><li>模板方法，用于子类直接调用</li></ol><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void acquire(int arg)</td><td>获取独占锁。会调用<code>tryAcquire</code>方法，如果未获取成功，则会进入同步队列等待</td></tr><tr><td>void acquireInterruptibly(int arg)</td><td>响应中断版的 <code>acquire</code></td></tr><tr><td>boolean tryAcquireNanos(int arg,long nanos)</td><td>超时+响应中断版的 acquire</td></tr><tr><td>void acquireShared(int arg)</td><td>获取共享锁。共享式获取同步状态，同一时刻可能会有多个线程获得同步状态。比如<strong>读写锁的读锁</strong>就是就是调用这个方法获取同步状态的</td></tr><tr><td>void acquireSharedInterruptibly(int arg)</td><td>响应中断版的<code>acquireShared</code></td></tr><tr><td>boolean tryAcquireSharedNanos(int arg,long nanos)</td><td>超时+响应中断版的<code>acquireShared</code></td></tr><tr><td>boolean release(int arg)</td><td>独占式释放同步状态</td></tr><tr><td>boolean releaseShared(int arg)</td><td>释放共享锁</td></tr><tr><td>Collection getQueuedThreads()</td><td>获取同步队列上的线程集合</td></tr></tbody></table><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>上文有提到，进入同步队列的线程会被封装成一个<code>Node</code>节点，下面我们先来看下<code>Node.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span>  <span class="keyword">final</span>  <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 用于标记一个节点在共享模式下等待</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 用于标记一个节点在独占模式下等待</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 等待状态：取消状态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 等待状态：通知(指示后继线程需要阻塞)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 等待状态：条件等待</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 等待状态：传播</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 等待状态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 前驱节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 后继节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 节点对应的线程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 等待队列中的后继节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> Node nextWaiter;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 当前节点是否处于共享模式等待</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 获取前驱节点，如果为空的话抛出空指针异常</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line"></span><br><span class="line"> Node p = prev;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Node() &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * addWaiter会调用此构造函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> Node(Thread thread, Node mode) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.thread = thread;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Condition会用到此构造函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.thread = thread;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释几个重要的属性</p><table><thead><tr><th>属性</th><th>意义</th></tr></thead><tbody><tr><td>prev</td><td>前置节点</td></tr><tr><td>next</td><td>后置节点</td></tr><tr><td>CANCELLED</td><td>状态值 表示节点被取消</td></tr><tr><td>SIGNAL</td><td>状态值  表示后置节点需要被阻塞</td></tr><tr><td>CONDITION</td><td>状态值 表示节点进入 CONDITION</td></tr><tr><td>PROPAGATE</td><td>状态值 共享锁传播状态</td></tr></tbody></table><h2 id="独占锁的获取"><a href="#独占锁的获取" class="headerlink" title="独占锁的获取"></a>独占锁的获取</h2><p>在<code>AQS</code>中包含了<code>head</code>和<code>tail</code>两个Node引用，其中<code>head</code>在逻辑上的含义是当前持有锁的线程，<code>tail</code>指示队尾节点。<code>head</code>和<code>tail</code>可以相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 获取独占锁，该方法会首先调用tryAcquire（由子类实现）来获取锁，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 如果获取成功会直接返回，失败则会将当前抢锁失败的线程封装为Node节点加入队尾</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line"></span><br><span class="line"> acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line"></span><br><span class="line"> selfInterrupt();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 增加一个</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速执行一次加入队列尾部的操作，如果失败的话则执行 enq</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取队尾节点</span></span><br><span class="line"></span><br><span class="line"> Node pred = tail;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取队尾的前驱节点</span></span><br><span class="line"></span><br><span class="line"> node.prev = pred;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CAS设置新的队尾，有可能失败</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line"></span><br><span class="line"> pred.next = node;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果还没有队尾（初始状态），或则入队失败，则执行下面的方法</span></span><br><span class="line"></span><br><span class="line"> enq(node);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过CAS 自旋设置新的队尾</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line"> Node t = tail;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 队尾节点为空，说明是初始状态，必须初始化头尾节点</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line"></span><br><span class="line"> tail = head;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 这里注意一个细节</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// node.prev = t 操作是设置当前节点的前驱节点为现在的队尾节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是该操作没有放到compareAndSetTail操作成功以后，也就是说代码为何不这样写</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// if (compareAndSetTail(t, node)) &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// node.prev = t;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// t.next = node;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// return t;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这样子写的话，队尾节点在某一瞬间会是一个孤立的节点，但是如果先</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 node.prev = t 就把当前节点的前驱指向了还未设置前的队尾，这样子当我们从后往前遍历的时候，就不会出现队列断裂的情况</span></span><br><span class="line"></span><br><span class="line"> node.prev = t;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line"></span><br><span class="line"> t.next = node;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 节点加入队列之后操作，这里分两种情况</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 1\. 如果当前节点的前驱节点为head 头节点，则尝试获取锁，并设置新的头节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 2\. 阻塞自己</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环尝试获取锁</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取前驱节点</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前驱节点为head节点 则尝试获取锁</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line"></span><br><span class="line"> setHead(node);</span><br><span class="line"></span><br><span class="line"> p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line"></span><br><span class="line"> failed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> interrupted;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否需要阻塞自己</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line"></span><br><span class="line"> parkAndCheckInterrupt())</span><br><span class="line"></span><br><span class="line"> interrupted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果抛异常失败，则调用 cancelAcquire 取消该节点</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (failed)</span><br><span class="line"></span><br><span class="line"> cancelAcquire(node);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果前驱节点的 waitStatus 为 -1，则说明当前线程需要阻塞</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * This node has already set status asking a release</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// waitStatus大于0，说明前驱节点为取消状态，需要重新设置前驱节点</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向前寻找waitStatus&lt;=0的节点，并设置为新的前驱节点</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line"> node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> pred.next = node;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 如果前驱节点状态为 0 -2 -3，则设置前驱节点 WaitStatus = -1，并重新循环</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 调用 LockSupport.park(this) 阻塞当前线程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 取消节点，也就是当前线程放弃获取锁</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取前驱节点，会跳过状态为取消状态的节点 Skip cancelled predecessors</span></span><br><span class="line"></span><br><span class="line"> Node pred = node.prev;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"> node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取后继节点</span></span><br><span class="line"></span><br><span class="line"> Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置节点状态为取消</span></span><br><span class="line"></span><br><span class="line"> node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前节点是队尾节点，则设置前驱节点为队尾，并设置前驱节点的后继节点为null</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line"></span><br><span class="line"> compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> ws;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果前驱节点不是头结点，且前驱节点的 WaitStatus = -1</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line"></span><br><span class="line"> ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line"></span><br><span class="line"> (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line"></span><br><span class="line"> pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"> Node next = node.next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将前置节点和后继节点相连</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"> compareAndSetNext(pred, predNext, next);</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 唤醒后继节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里为何要唤醒后继节点？</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为如果当前节点的前置节点为head节点，但是此时head节点的状态为0（当前节点还未来得及设置前置节点状态为 -1），这时head节点释放了锁因为状态还为0，所以不会去唤醒后继线程。这时队列就失去活性了！所以这里需要唤醒后继线程</span></span><br><span class="line"></span><br><span class="line"> unparkSuccessor(node);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> node.next = node; <span class="comment">// help GC</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 唤醒后继节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 如果节点 waitStatus &lt; 0，则尝试将状态设为0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"> compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 获取当前节点的后继节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 如果 s!=null 且 s未被取消 则直接唤醒</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> Node s = node.next;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"> s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从尾节点向前查找离node最近的非取消节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意这里为何要从后向前查找</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 enq方法中有段注释，如果从前往后的话，有可能出现队列断裂</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"> s = t;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line"> LockSupport.unpark(s.thread);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文基本完成了对独占锁获取锁的流程的分析，这里简单画个图来更清晰的展示整个获取锁的过程：</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-376c9c2663fd07fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="独占锁的释放"><a href="#独占锁的释放" class="headerlink" title="独占锁的释放"></a>独占锁的释放</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">final</span>  <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果释放锁成功</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"></span><br><span class="line"> Node h = head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 且当前持锁的头结点状态不等于0，就去唤醒后继线程</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 思考这里等于0 为何不行？</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为当 waitStatus == 0时，说明后继线程还在运行中，还未来得及将waitStatus 状态设为-1</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 与上文unparkSuccessor方法一致</span></span><br><span class="line"></span><br><span class="line"> unparkSuccessor(h);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁与独占锁最大的区别在于，共享锁允许多个线程持有锁，而独占锁在同一时间只有一个线程可以获取到锁</p><h3 id="共享锁的获取"><a href="#共享锁的获取" class="headerlink" title="共享锁的获取"></a>共享锁的获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 获取共享锁</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果tryAcquireShared(arg) &lt; 0表示获取共享锁失败</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取失败的原因一般是由于该资源正由独占锁占有</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"> doAcquireShared(arg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加入到队列尾部</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一旦共享获取成功，设置新的头结点，并且唤醒后继线程</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"> setHeadAndPropagate(node, r);</span><br><span class="line"></span><br><span class="line"> p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (interrupted)</span><br><span class="line"></span><br><span class="line"> selfInterrupt();</span><br><span class="line"></span><br><span class="line"> failed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 判断是否需要阻塞</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line"></span><br><span class="line"> parkAndCheckInterrupt())</span><br><span class="line"></span><br><span class="line"> interrupted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (failed)</span><br><span class="line"></span><br><span class="line"> cancelAcquire(node);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 在获取共享锁成功后，设置head节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 跟据调用tryAcquireShared返回的状态以及节点本身的等待状态来判断是否要需要唤醒后继线程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> Node h = head;</span><br><span class="line"></span><br><span class="line"> setHead(node);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * propagate是tryAcquireShared的返回值，这是决定是否传播唤醒的依据之一。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * h.waitStatus为SIGNAL或者PROPAGATE时也根据node的下一个节点共享来决定是否传播唤醒，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 思考，这里为什么不能只用propagate &gt; 0来决定是否可以传播</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 因为此时有可能有其他线程释放了锁，但propagate还未更新，所以还需要判断h.waitStatus &lt; 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line"></span><br><span class="line"> (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"> Node s = node.next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后继节点为共享锁类型</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line"></span><br><span class="line"> doReleaseShared();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 这是共享锁中的核心唤醒函数，主要做的事情就是唤醒下一个线程或者设置传播状态。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line"> Node h = head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果队列中存在后继线程。</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"> unparkSuccessor(h);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果h节点的状态为0，需要设置为PROPAGATE用以保证唤醒的传播。</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line"> !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line"></span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (h == head)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享锁的释放"><a href="#共享锁的释放" class="headerlink" title="共享锁的释放"></a>共享锁的释放</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line"></span><br><span class="line"> if (tryReleaseShared(arg)) &#123;</span><br><span class="line"></span><br><span class="line"> // 与上文doReleaseShared一样</span><br><span class="line"></span><br><span class="line"> doReleaseShared();</span><br><span class="line"></span><br><span class="line"> return true;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>AQS</code>的整体理念相对比较容易理解，但是<code>AQS</code>真正难懂的其实是它的细节，因为一个很简单的问题一旦被放在并发环境中就会变的非常抽象，难以理解。要理解<code>AQS</code>的细节实现，还是需要多看，我是前前后后看了有一周，对于有些细节还是略模糊。</p><p>本篇文章参考了</p><p><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;AQS&lt;/code&gt;全称&lt;code&gt;java.util.concurrent.locks.AbstractQueuedSynch
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发" scheme="http://wangjunnan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java CAS</title>
    <link href="http://wangjunnan.github.io/2019/03/02/Java-CAS/"/>
    <id>http://wangjunnan.github.io/2019/03/02/Java-CAS/</id>
    <published>2019-03-02T08:15:23.000Z</published>
    <updated>2019-09-27T05:52:47.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在介绍<code>CAS</code>之前，我们有必要先理解线程安全的三大特性</p><ul><li>原子性: 对于涉及共享变量访问的操作，该操作从其执行线程以外的任意线程来看是不可分割的，从而可以让各个线程依次串行访问，但是原子性并不保证可见性</li><li>可见性: 修改共享变量时，立即将工作内存中的值同步到主存中，并使该修改对其他线程可见</li><li>有序性: 禁止读取共享变量后的代码、修改共享变量前的代码重排序</li></ul><p><code>CAS</code>即<code>compare and swap</code>的缩写，中文翻译成比较并交换。是一种用于在多线程环境下实现同步功能的机制。调用<code>Java CAS</code>需要三个操作数</p><ol><li>内存中值的内存位置</li><li>预期值</li><li>新值</li></ol><p>具体实现是通过值的内存位置取到内存中的值并与预期值比较，若相等，则将内存位置处的值替换为新值，若不相等，则不做任何操作返回false。如果大家有了解过悲观锁和乐观锁，可以发现<code>CAS</code>其实是一种乐观锁的实现。</p><h2 id="使用CAS的目的"><a href="#使用CAS的目的" class="headerlink" title="使用CAS的目的"></a>使用CAS的目的</h2><p>对于实现线程安全，我们用的比较多的应该是<code>synchronized</code>关键字，<code>synchronized</code>其实是一种悲观锁，锁被占用的情况会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。<code>CAS</code>是一种乐观锁，每次取数据都不会加锁，更新的时候会进行数据比对，有冲突的话则会自旋重试。可以看到在读操作频繁，更新频率低，冲突概率低的情况下，用<code>CAS</code>的话会更加合理。当然JDK1.6之后，Java对<code>synchronized</code>关键字来了一大波优化（自旋锁，锁消除，锁粗化，偏向锁，轻量级锁），一般情况下使用<code>synchronized</code>是非常稳定的。</p><h2 id="CAS的底层实现"><a href="#CAS的底层实现" class="headerlink" title="CAS的底层实现"></a>CAS的底层实现</h2><p>现在的CPU都是多核心的，多个核心通过总线来操作内存。那么这里就存在一个问题，就是如果多个核心同时操作一块内存区域，会发生什么问题呢？是的，这里数据就会出现混乱。不过这里我们可以从<code>intel</code>的使用手册中找到答案，对指令加<code>lock</code>前缀可以保证操作的原子性，可见性以及有序性。好了，底层的就不多说了，我们直接去看一下<code>java.util.concurrent.atomic</code>包下的原子类 <code>AtomicInteger</code>的源码实现</p><h2 id="AtomicInteger源码"><a href="#AtomicInteger源码" class="headerlink" title="AtomicInteger源码"></a>AtomicInteger源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 6214790243416807050L;</span><br><span class="line"></span><br><span class="line">    // setup to use Unsafe.compareAndSwapInt for updates</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    // value值的内存位置</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取value的内存位置</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  // value值 volatile 修饰 保证可见性</span><br><span class="line">    private volatile int value;</span><br><span class="line"></span><br><span class="line">    public AtomicInteger(int initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AtomicInteger() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取value在内存中当前的值</span><br><span class="line">     *</span><br><span class="line">     * @return the current value</span><br><span class="line">     */</span><br><span class="line">    public final int get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 比较并替换 实现在unsafe.compareAndSwapInt中</span><br><span class="line">     * @param expect 期望值</span><br><span class="line">     * @param update 新值</span><br><span class="line">     */</span><br><span class="line">    public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 自增 实现在unsafe.getAndAddInt中</span><br><span class="line">     */</span><br><span class="line">    public final int incrementAndGet() &#123;</span><br><span class="line">     return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Unsafe.class</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapInt(Object o, long valueOffset, int expected, int value);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取当前值 并加1，返回的是加1前的值</span><br><span class="line"> */</span><br><span class="line">public final int getAndAddInt(Object o, long valueOffset, int addValue) &#123;</span><br><span class="line">    int currentValue;</span><br><span class="line">    do &#123;</span><br><span class="line">        currentValue = this.getIntVolatile(o, valueOffset);</span><br><span class="line">        // 比较当前内存的值和预期值currentValue是否一致，一致的话则设置新值。但是因为当前内存中的值有可能被其他线程修改，会有和预期值不一致的情况，所以这里会循环直到 compareAndSwapInt 返回成功为止，这里的操作也称为CAS自旋</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(o, valueOffset, currentValue, value + addValue));</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AtomicInteger</code>是<code>Java</code>对<code>Integer</code>类型原子性操作的实现，可以看到底层都是调用了CAS <code>compareAndSwapInt</code>native方法。<br>这里主要看一下<code>compareAndSwapInt(Object o, long valueOffset, int expect, int update)</code>的四个参数</p><ul><li>o 当前操作的对象</li><li>valueOffset 操作值所在的内存位置 </li><li>expect 期望值</li><li>update 新值</li></ul><p>具体实现是将内存位置处的数值与预期数值相比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。<br><code>CAS自旋</code>指的是替换新值失败时会进入循环，重新获取期望值，直到期望值和内存位置处的数值相等。</p><h2 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h2><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>提到<code>CAS</code>存在的问题，就不得不提<code>ABA</code>问题，什么是<code>ABA</code>问题呢？<br>举个例子，A是个共享变量，原值是<code>10</code>，线程1从内存中拿到了A，此时值为<code>10</code>，当线程1要对变量A进行<code>CAS</code>操作前，因为其他线程的操作，A从<code>10</code>变为了<code>11</code>，又从<code>11</code>变回了<code>10</code>。此时线程1对变量A执行<code>CAS</code>操作照道理应该是要失败的，但实际却是成功的。这是因为经过了上面的流程，在线程1看来，变量A没有发生任何变化，所以它执行<code>CAS</code>操作是会成功的。</p><p>要解决<code>ABA</code>问题，通常的解决方案给对象加上版本号，每经过一次<code>CAS</code>操作就更新一次版本号</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的目的主要是让自己对java并发包的基础<code>CAS</code>有个简单的了解，以便进行后续的源码分析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在介绍&lt;code&gt;CAS&lt;/code&gt;之前，我们有必要先理解线程安全的三大特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性: 对于涉及共享变量访问的操
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发" scheme="http://wangjunnan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
