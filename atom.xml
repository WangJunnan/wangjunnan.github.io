<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王俊男的技术杂谈</title>
  
  <subtitle>喋喋不休</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangjunnan.github.io/"/>
  <updated>2019-11-18T02:51:54.313Z</updated>
  <id>http://wangjunnan.github.io/</id>
  
  <author>
    <name>王俊男</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sentinel源码解析四（流控策略和流控效果）</title>
    <link href="http://wangjunnan.github.io/2019/11/18/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E5%9B%9B%EF%BC%88%E6%B5%81%E6%8E%A7%E7%AD%96%E7%95%A5%E5%92%8C%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C%EF%BC%89/"/>
    <id>http://wangjunnan.github.io/2019/11/18/Sentinel源码解析四（流控策略和流控效果）/</id>
    <published>2019-11-18T02:50:25.000Z</published>
    <updated>2019-11-18T02:51:54.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在分析Sentinel的上一篇文章中，我们知道了它是基于滑动窗口做的流量统计，那么在当我们能够根据流量统计算法拿到流量的实时数据后，下一步要做的事情自然就是基于这些数据做流控。在介绍<code>Sentinel</code>的流控模型之前，我们先来简单看下 Sentinel 后台是如何去定义一个流控规则的</p><p><img src="http://img.souche.com/f2e/71089fbdf4dc7ab9b2b0afc01b99baf7.jpg" alt></p><p>对于上图的配置<code>Sentinel</code>把它抽象成一个<code>FlowRule</code>类，与其属性一一对应</p><ul><li>resource 资源名</li><li>limitApp 限流来源，默认为default不区分来源</li><li>grade    限流类型，有QPS和并发线程数两种类型</li><li>count    限流阈值</li><li>strategy 流控策略  1. 直接 2. 关联 3.链路 </li><li>controlBehavior   流控效果 1.快速失败 2.预热启动 3.排队等待 4. 预热启动排队等待</li><li>warmUpPeriodSec   流控效果为预热启动时的预热时长（秒）</li><li>maxQueueingTimeMs 流控效果为排队等待时的等待时长 （毫秒）</li></ul><p>下面我们来看下选择流控策略和流控效果的核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">passLocalCheck</span><span class="params">(FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> acquireCount,<span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据流控策略选择需要流控的Node维度节点                              </span></span><br><span class="line">    Node selectedNode = selectNodeByRequesterAndStrategy(rule, context, node);</span><br><span class="line">    <span class="keyword">if</span> (selectedNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取配置的流控效果 控制器 （1. 直接拒绝 2. 预热启动 3. 排队 4. 预热启动排队等待）</span></span><br><span class="line">    <span class="keyword">return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码比较简单流程也很清晰，首先根据我们配置的流控策略获取到合适维度的 Node 节点（Node节点是Sentinel做流量统计的基本单位），然后再获取到规则中配置的流控效果控制器（1. 直接拒绝 2. 预热启动 3. 排队等待 4.预热启动排队等待）。</p><h2 id="流控策略"><a href="#流控策略" class="headerlink" title="流控策略"></a>流控策略</h2><p>下面我们来看下选择流控策略的源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">selectNodeByRequesterAndStrategy</span><span class="params">(<span class="comment">/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取限流来源 limitApp</span></span><br><span class="line">    String limitApp = rule.getLimitApp();</span><br><span class="line">    <span class="comment">// 获取限流策略</span></span><br><span class="line">    <span class="keyword">int</span> strategy = rule.getStrategy();</span><br><span class="line">    <span class="comment">// 获取当前 上下文的 来源</span></span><br><span class="line">    String origin = context.getOrigin();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果规则配置的限流来源 limitApp 等于 当前上下文来源</span></span><br><span class="line">    <span class="keyword">if</span> (limitApp.equals(origin) &amp;&amp; filterOrigin(origin)) &#123;</span><br><span class="line">    <span class="comment">// 且配置的流控策略是 直接关联策略</span></span><br><span class="line">        <span class="keyword">if</span> (strategy == RuleConstant.STRATEGY_DIRECT) &#123;</span><br><span class="line">            <span class="comment">// 直接返回当前来源 origin 节点</span></span><br><span class="line">            <span class="keyword">return</span> context.getOriginNode();</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">// 配置的策略为关联或则链路</span></span><br><span class="line">        <span class="keyword">return</span> selectReferenceNode(rule, context, node);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果规则配置的限流来源 limitApp 等于 default </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (RuleConstant.LIMIT_APP_DEFAULT.equals(limitApp)) &#123;</span><br><span class="line">    <span class="comment">// 且配置的流控策略是 直接关联策略</span></span><br><span class="line">        <span class="keyword">if</span> (strategy == RuleConstant.STRATEGY_DIRECT) &#123;</span><br><span class="line">            <span class="comment">// 直接返回当前资源的 clusterNode</span></span><br><span class="line">            <span class="keyword">return</span> node.getClusterNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 配置的策略为关联或则链路</span></span><br><span class="line">        <span class="keyword">return</span> selectReferenceNode(rule, context, node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果规则配置的限流来源 limitApp 等于 other，且当前上下文origin不在流控规则策略中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (RuleConstant.LIMIT_APP_OTHER.equals(limitApp)</span><br><span class="line">        &amp;&amp; FlowRuleManager.isOtherOrigin(origin, rule.getResource())) &#123;</span><br><span class="line">        <span class="comment">// 且配置的流控策略是 直接关联策略</span></span><br><span class="line">        <span class="keyword">if</span> (strategy == RuleConstant.STRATEGY_DIRECT) &#123;</span><br><span class="line">            <span class="keyword">return</span> context.getOriginNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 配置的策略为关联或则链路</span></span><br><span class="line">        <span class="keyword">return</span> selectReferenceNode(rule, context, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">selectReferenceNode</span><span class="params">(FlowRule rule, Context context, DefaultNode node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 关联资源名称 （如果策略是关联 则是关联的资源名称，如果策略是链路 则是上下文名称）</span></span><br><span class="line">    String refResource = rule.getRefResource();</span><br><span class="line">    <span class="keyword">int</span> strategy = rule.getStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtil.isEmpty(refResource)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 策略是关联</span></span><br><span class="line">    <span class="keyword">if</span> (strategy == RuleConstant.STRATEGY_RELATE) &#123;</span><br><span class="line">    <span class="comment">// 返回关联的资源ClusterNode</span></span><br><span class="line">        <span class="keyword">return</span> ClusterBuilderSlot.getClusterNode(refResource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 策略是链路</span></span><br><span class="line">    <span class="keyword">if</span> (strategy == RuleConstant.STRATEGY_CHAIN) &#123;</span><br><span class="line">    <span class="comment">// 当前上下文名称不是规则配置的name 直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (!refResource.equals(context.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No node.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑判断比较多，我们稍微理一下整个过程</p><ul><li><code>LimitApp</code>的作用域只在配置的流控策略为<code>RuleConstant.STRATEGY_DIRECT</code>（直接关联）时起作用。其有三种配置，分别为<code>default</code>，<code>origin_name</code>，<code>other</code><ul><li>default 如果配置为default，表示统计不区分来源，当前资源的任何来源流量都会被统计（其实就是选择 Node 为 clusterNode 维度）</li><li>origin_name 如果配置为指定名称的 origin_name，则只会对当前配置的来源流量做统计</li><li>other 如果配置为other 则会对其他全部来源生效<strong>但不包括第二条配置的来源</strong></li></ul></li><li>当策略配置为 RuleConstant.STRATEGY_RELATE 或 RuleConstant.STRATEGY_CHAIN 时<ul><li>STRATEGY_RELATE 关联其他的指定资源，如资源A想以资源B的流量状况来决定是否需要限流，这时资源A规则配置可以使用 STRATEGY_RELATE 策略</li><li>STRATEGY_CHAIN 对指定入口的流量限流，因为流量可以有多个不同的入口（EntranceNode）</li></ul></li><li>对于上面几个节点之间的关系不清楚的可以去看我这篇文章开头的总览图 <a href="https://www.cnblogs.com/taromilk/p/11750962.html" target="_blank" rel="noopener">Sentinel源码解析一（流程总览）</a></li></ul><h2 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h2><p>关于流控效果的配置有四种，我们来看下它们的初始化代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * class com.alibaba.csp.sentinel.slots.block.flow.FlowRuleUtil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TrafficShapingController <span class="title">generateRater</span><span class="params">(<span class="comment">/*@Valid*/</span> FlowRule rule)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 只有Grade为统计 QPS时 才可以选择除默认流控效果外的 其他流控效果控制器</span></span><br><span class="line">    <span class="keyword">if</span> (rule.getGrade() == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (rule.getControlBehavior()) &#123;</span><br><span class="line">        <span class="comment">// 预热启动</span></span><br><span class="line">            <span class="keyword">case</span> RuleConstant.CONTROL_BEHAVIOR_WARM_UP:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WarmUpController(rule.getCount(), rule.getWarmUpPeriodSec(),</span><br><span class="line">                    ColdFactorProperty.coldFactor);</span><br><span class="line">            <span class="comment">// 超过 阈值 排队等待 控制器</span></span><br><span class="line">            <span class="keyword">case</span> RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RateLimiterController(rule.getMaxQueueingTimeMs(), rule.getCount());</span><br><span class="line">            <span class="keyword">case</span> RuleConstant.CONTROL_BEHAVIOR_WARM_UP_RATE_LIMITER:</span><br><span class="line">            <span class="comment">// 上面两个的结合体</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WarmUpRateLimiterController(rule.getCount(), rule.getWarmUpPeriodSec(),</span><br><span class="line">                    rule.getMaxQueueingTimeMs(), ColdFactorProperty.coldFactor);</span><br><span class="line">            <span class="keyword">case</span> RuleConstant.CONTROL_BEHAVIOR_DEFAULT:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// Default mode or unknown mode: default traffic shaping controller (fast-reject).</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认控制器 超过 阈值 直接拒绝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultController(rule.getCount(), rule.getGrade());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以比较清晰的看到总共对应有四种流控器的初始化</p><h3 id="直接拒绝"><a href="#直接拒绝" class="headerlink" title="直接拒绝"></a>直接拒绝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取当前qps</span></span><br><span class="line">    <span class="keyword">int</span> curCount = avgUsedTokens(node);</span><br><span class="line">    <span class="comment">// 判断是否已经大于阈值</span></span><br><span class="line">    <span class="keyword">if</span> (curCount + acquireCount &gt; count) &#123;</span><br><span class="line">    <span class="comment">// 如果当前流量具有优先级，则会提前去获取未来的通过资格</span></span><br><span class="line">        <span class="keyword">if</span> (prioritized &amp;&amp; grade == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class="line">            <span class="keyword">long</span> currentTime;</span><br><span class="line">            <span class="keyword">long</span> waitInMs;</span><br><span class="line">            currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);</span><br><span class="line">            <span class="keyword">if</span> (waitInMs &lt; OccupyTimeoutProperty.getOccupyTimeout()) &#123;</span><br><span class="line">                node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class="line">                node.addOccupiedPass(acquireCount);</span><br><span class="line">                sleep(waitInMs);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// PriorityWaitException indicates that the request will pass after waiting for &#123;@link @waitInMs&#125;.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> PriorityWaitException(waitInMs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种策略比较简单粗暴，超过流量阈值的会直接拒绝。不过这里有一个小细节，如果入口流量prioritized为true，也就是优先级比较高，则会通过占用未来时间窗口的名额来实现。这个在上一篇文章有介绍到 <a href></a></p><h3 id="预热启动"><a href="#预热启动" class="headerlink" title="预热启动"></a>预热启动</h3><p><code>WarmUpController</code> 主要是用来防止流量的突然上升，使系统本在稳定状态下能处理的，但是由于许多资源没有预热，导致处理不了了。<strong>注意这里的预热并不是指系统启动之后的一次性预热，而是指系统在运行的任何时候流量从低峰到突增的预热阶段</strong>。</p><p>下面我们来看下<code>WarmUpController</code>的具体实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WarmUpController 构造方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count 当前qps阈值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> warmUpPeriodInSec 预热时长 秒</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> coldFactor 冷启动系数 默认为3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec, <span class="keyword">int</span> coldFactor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (coldFactor &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cold factor should be larger than 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.coldFactor = coldFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余Token的警戒值，小于警戒值系统就进入正常运行期</span></span><br><span class="line">    warningToken = (<span class="keyword">int</span>)(warmUpPeriodInSec * count) / (coldFactor - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 系统最冷时候的剩余Token数</span></span><br><span class="line">    maxToken = warningToken + (<span class="keyword">int</span>)(<span class="number">2</span> * warmUpPeriodInSec * count / (<span class="number">1.0</span> + coldFactor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统预热的速率(斜率)</span></span><br><span class="line">    slope = (coldFactor - <span class="number">1.0</span>) / count / (maxToken - warningToken);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> passQps = (<span class="keyword">long</span>) node.passQps();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> previousQps = (<span class="keyword">long</span>) node.previousPassQps();</span><br><span class="line">    <span class="comment">// 计算当前的 剩余 token 数</span></span><br><span class="line">    syncToken(previousQps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class="line">    <span class="keyword">long</span> restToken = storedTokens.get();</span><br><span class="line">    <span class="keyword">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class="line">    <span class="comment">// 计算剩余token超出警戒值的值</span></span><br><span class="line">        <span class="keyword">long</span> aboveToken = restToken - warningToken;</span><br><span class="line">        <span class="comment">// 计算当前允许通过的最大 qps</span></span><br><span class="line">        <span class="keyword">double</span> warningQps = Math.nextUp(<span class="number">1.0</span> / (aboveToken * slope + <span class="number">1.0</span> / count));</span><br><span class="line">        <span class="keyword">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不在预热阶段，则直接判断当前qps是否大于阈值</span></span><br><span class="line">        <span class="keyword">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是构造方法，主要关注2个重要参数</p><ol><li>warningToken 剩余token的警戒值</li><li>maxToken  剩余的最大token数，如果剩余token数等于maxToken，则说明系统处于最冷阶段</li></ol><p>要理解这两个参数的含义，可以参考令牌桶算法，每通过一个请求，就会从令牌桶中取走一个令牌。那么试想一下，当令牌桶中的令牌达到最大值是，是不是意味着系统目前处于最冷阶段，因为桶里的令牌始终处于一个非常饱和的状态。这里的令牌最大值对应的就是<code>maxToken</code>，而<code>warningToken</code>，则是对应了一个警戒值，当桶中的令牌数减少到一个指定的值时，说明系统已经度过了预热阶段</p><p>当一个请求进来时，首先需要计算当前桶中剩余的token数，具体逻辑在<code>syncToken</code>方法中<br>当系统剩余Token大于warningToken时，说明系统仍处于预热阶段，故需要调整当前所能通过的最大qps阈值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">syncToken</span><span class="params">(<span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 获取秒级别时间（去除毫秒）</span></span><br><span class="line">    currentTime = currentTime - currentTime % <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">long</span> oldLastFillTime = lastFilledTime.get();</span><br><span class="line">    <span class="keyword">if</span> (currentTime &lt;= oldLastFillTime) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">    <span class="comment">// 判断是否需要往桶中添加令牌</span></span><br><span class="line">    <span class="keyword">long</span> newValue = coolDownTokens(currentTime, passQps);</span><br><span class="line">    <span class="comment">// 设置新的token数</span></span><br><span class="line">    <span class="keyword">if</span> (storedTokens.compareAndSet(oldValue, newValue)) &#123;</span><br><span class="line">    <span class="comment">// 如果设置成功的话则减去上次通过的qps数量，就得到当前的实际token数</span></span><br><span class="line">        <span class="keyword">long</span> currentValue = storedTokens.addAndGet(<span class="number">0</span> - passQps);</span><br><span class="line">        <span class="keyword">if</span> (currentValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            storedTokens.set(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lastFilledTime.set(currentTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取当前时间</li><li>coolDownTokens 方法会判断是否需要往桶中放 token，并返回最新的token数</li><li>如果返回了最新的token数，则将当前剩余的token数减去已经通过的qps，得到最新的剩余token数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">coolDownTokens</span><span class="params">(<span class="keyword">long</span> currentTime, <span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">    <span class="keyword">long</span> newValue = oldValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加令牌的几种情况</span></span><br><span class="line">    <span class="comment">// 1. 系统初始启动阶段，oldvalue = 0，lastFilledTime也等于0，此时得到一个非常大的newValue，会取maxToken为当前token数量值</span></span><br><span class="line">    <span class="comment">// 2. 系统处于预热阶段 且 当前qps小于 count / coldFactor</span></span><br><span class="line">    <span class="comment">// 3. 系统处于完成预热阶段</span></span><br><span class="line">    <span class="keyword">if</span> (oldValue &lt; warningToken) &#123;</span><br><span class="line">        newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldValue &gt; warningToken) &#123;</span><br><span class="line">        <span class="keyword">if</span> (passQps &lt; (<span class="keyword">int</span>)count / coldFactor) &#123;</span><br><span class="line">            newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(newValue, maxToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看一下会添加令牌的几种情况</p><ol><li>系统初始启动阶段，oldvalue = 0，lastFilledTime也等于0，此时得到一个非常大的newValue，会取maxToken为当前token数量值</li><li>系统处于完成预热阶段，需要补充 token 使其稳定在一个范围内</li><li>系统处于预热阶段 且 当前qps小于 count / coldFactor</li></ol><p>前2种情况比较好理解，这里主要解释一下第三种情况，为何 当前<code>qps</code>小于<code>count / coldFactor</code>时，需要往桶中添加Token？试想一下如果没有这一步会怎么样，如果没有这一步在比较低的qps情况下补充Token，系统最终也会慢慢度过预热阶段，但实际上这么低的qps(<code>小于 count / coldFactor时</code>)不应该完成预热。所以这里才会在 qps低于<code>count / coldFactor</code>时补充剩余token数，<strong>来让系统在低qps情况下始终处于预热状态下</strong></p><h3 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h3><p>排队等待的实现相对预热启动实现比较简单</p><p>首先会通过我们的配置，计算出相邻两个请求允许通过的最小时间，然后会记录最近一个通过的时间。两者相加即是下一次请求允许通过的最小时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (acquireCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 计算相隔两个请求 需要相隔多长时间</span></span><br><span class="line">    <span class="keyword">long</span> costTime = Math.round(<span class="number">1.0</span> * (acquireCount) / count * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本次期望通过的最小时间</span></span><br><span class="line">    <span class="keyword">long</span> expectedTime = costTime + latestPassedTime.get();</span><br><span class="line">    <span class="comment">// 如果当前时间大于期望时间，说明qps还未超过阈值，直接通过</span></span><br><span class="line">    <span class="keyword">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class="line">       </span><br><span class="line">        latestPassedTime.set(currentTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时间小于于期望时间，请求过快了，需要排队等待指定时间</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算等待时间</span></span><br><span class="line">        <span class="keyword">long</span> waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 等待时长大于我们设置的最大时长，则不通过</span></span><br><span class="line">        <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则则排队等待，占用下通过时间</span></span><br><span class="line">            <span class="keyword">long</span> oldTime = latestPassedTime.addAndGet(costTime);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">                waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class="line">                <span class="comment">// 判断等待时间是否已经大于最大值</span></span><br><span class="line">                <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                <span class="comment">// 大于则将上一步加的值重新减去</span></span><br><span class="line">                    latestPassedTime.addAndGet(-costTime);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// in race condition waitTime may &lt;= 0</span></span><br><span class="line">                <span class="comment">// 占用等待时间成功，直接sleep costTime</span></span><br><span class="line">                <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Thread.sleep(waitTime);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排队等待控制器的核心策略其实就是围绕了<code>latestPassedTime</code>进行的，<code>latestPassedTime</code>指的是上一次请求通过的时间，通过<code>latestPassedTime</code> + <code>costTime</code>来与当前时间做比较，来判断当前请求是否可以通过，无法通过的请求则会优先占用<code>latestPassedTime</code>时间，直到sleep到可以通过的时间。当然我们也可以配置排队等待的最大时间，来限制目前排队等待通过的请求数量。</p><h3 id="预热启动排队等待"><a href="#预热启动排队等待" class="headerlink" title="预热启动排队等待"></a>预热启动排队等待</h3><p>预热排队等待，<code>WarmUpRateLimiterController</code>实现类我们发现其继承了<code>WarmUpController</code>，这是Sentinel在1.4版本后新加的一种控制器，其实就是预热启动和排队等待的结合体，具体源码我们就不做分析。</p><h2 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h2><p><code>Sentinel</code>的流控策略和流控效果的相结合使用还是非常巧妙的，当中的一些设计思想还是非常有借鉴意义的</p><p>Sentinel系列</p><ul><li><p><a href="https://www.cnblogs.com/taromilk/p/11750962.html" target="_blank" rel="noopener">Sentinel源码解析一（流程总览）</a></p></li><li><p><a href="https://www.cnblogs.com/taromilk/p/11751000.html" target="_blank" rel="noopener">Sentinel源码解析二（slot总览）</a></p></li><li><p><a href="https://www.cnblogs.com/taromilk/p/11751009.html" target="_blank" rel="noopener">Sentinel源码解析三（滑动窗口流量统计）</a></p></li><li><a href="https://www.cnblogs.com/taromilk/p/11877242.html" target="_blank" rel="noopener">Sentinel源码解析四（流控策略和流控效果）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在分析Sentinel的上一篇文章中，我们知道了它是基于滑动窗口做的流量统计，那么在当我们能够根据流量统计算法拿到流量的实时数据后，下一步要
      
    
    </summary>
    
      <category term="Sentinel" scheme="http://wangjunnan.github.io/categories/Sentinel/"/>
    
      <category term="并发" scheme="http://wangjunnan.github.io/categories/Sentinel/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Sentinel" scheme="http://wangjunnan.github.io/tags/Sentinel/"/>
    
      <category term="中间件" scheme="http://wangjunnan.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>自定义maven脚手架</title>
    <link href="http://wangjunnan.github.io/2019/11/08/%E8%87%AA%E5%AE%9A%E4%B9%89maven%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://wangjunnan.github.io/2019/11/08/自定义maven脚手架/</id>
    <published>2019-11-08T07:40:50.000Z</published>
    <updated>2019-11-08T07:45:51.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>开发新项目就需要搭建新工程，但是搭建新工程的这个过程是非常繁琐浪费时间的，并且不可避免的需要踩坑。更可怕的是，如果是在一个团队中，每新起一个项目都由不同的开发人员去自定义的搭建工程结构，那么对后续的统一管理，监控，运维简直是灾难。基于以上几点，团队内部其实是非常有必要搭建一个统一的脚手架来供统一使用</p><h1 id="制作一个脚手架"><a href="#制作一个脚手架" class="headerlink" title="制作一个脚手架"></a>制作一个脚手架</h1><p>下面我们就来详细的介绍如何搭建一个maven工程的脚手架</p><p>要搭建脚手架，首先我们需要一个模板工程，这个模板工程一般来说会集成一些工具类，底层中间件，通用配置，并且要有良好的分层结构等。需要能够达到开箱即用的程度。</p><p>以下是一个模板工程的目录结构，也是目前我们团队内部的标准化结构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── example-client</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── example-core</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── example-server</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── example-test</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── Jenkinsfile</span><br><span class="line">├── README.md</span><br><span class="line">├── .gitignore</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure></p><p>完成模板工程的搭建后，需要在模板工程的最外层 pom 文件加入以下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-archetype-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成之后在根目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create-from-project</span><br></pre></td></tr></table></figure><p>刷新项目后，会发现在 <code>./target/generated-sources/archetype</code>目录下生成了脚手架工程，生成的脚手架工程可以当成是一个独立的项目，目录结构如下图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   │       ├── META-INF</span><br><span class="line">│   │       │   └── maven</span><br><span class="line">│   │       │       └── archetype-metadata.xml</span><br><span class="line">│   │       └── archetype-resources</span><br><span class="line">│   │           ├── Jenkinsfile</span><br><span class="line">│   │           ├── README.md</span><br><span class="line">│   │           ├── __artifactId__.iml</span><br><span class="line">│   │           ├── __rootArtifactId__-client</span><br><span class="line">│   │           │   ├── __parentArtifactId__-client.iml</span><br><span class="line">│   │           │   ├── pom.xml</span><br><span class="line">│   │           │   └── src</span><br><span class="line">│   │           ├── __rootArtifactId__-core</span><br><span class="line">│   │           │   ├── __parentArtifactId__-core.iml</span><br><span class="line">│   │           │   ├── pom.xml</span><br><span class="line">│   │           │   └── src</span><br><span class="line">│   │           ├── __rootArtifactId__-server</span><br><span class="line">│   │           │   ├── __parentArtifactId__-server.iml</span><br><span class="line">│   │           │   ├── pom.xml</span><br><span class="line">│   │           │   └── src</span><br><span class="line">│   │           ├── __rootArtifactId__-test</span><br><span class="line">│   │           │   ├── __parentArtifactId__-test.iml</span><br><span class="line">│   │           │   ├── pom.xml</span><br><span class="line">│   │           │   └── src</span><br><span class="line">│   │           └── pom.xml</span><br><span class="line">│   └── <span class="built_in">test</span></span><br><span class="line">│       └── resources</span><br><span class="line">│           └── projects</span><br><span class="line">│               └── basic</span><br><span class="line">│                   ├── archetype.properties</span><br><span class="line">│                   └── goal.txt</span><br></pre></td></tr></table></figure><p> 在脚手架工程目录下执行 mvn install 就完成了脚手架的本地安装，安装完成之后，这个脚手架在本地就可以使用了<br>可以执行以下脚本来通过此脚手架创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=com.xxx.example -DartifactId=xxxx -Dpackage=com.xxx.example -DarchetypeGroupId=com.demo.archetype -DarchetypeArtifactId=demo-archetype -DarchetypeVersion=1.0.0-SNAPSHOT -DinteractiveMode=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="扫坑"><a href="#扫坑" class="headerlink" title="扫坑"></a>扫坑</h1><p>不过如果我们直接这样使用的话，会发现生成了很多我们并不想要它出现的文件，比如 .idea .iml 文件等等，并且 .gitignore 文件也诡异的消失了（不知为何会忽略这个文件？？）… 这显然不是成熟的脚手架了。那么就需要对它做一些额外的配置了</p><p>有两种方式可以解决上面出现的问题</p><ol><li>将 .gitignore文件重命名为 <strong>gitignore</strong>，然后在模板工程根目录下新建 archetype.properties 文件，并填入以下内容</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## generate for archetype-metadata.xml</span></span><br><span class="line">excludePatterns=archetype.properties,*.iml,.idea/,.idea/libraries,logs/,build.sh</span><br><span class="line"><span class="comment">## generate .gitignore file</span></span><br><span class="line">gitignore=.gitignore</span><br></pre></td></tr></table></figure><p>完成上述配置后，重新执行 mvn archetype:create-from-project 生成脚手架工程。再完成本地安装，上面出现的问题就会解决</p><ol start="2"><li>第二种方式本质上和第一种方式是一样的，只是第二种方式是直接修改脚手架工程的配置文件。第一种方式相当于是执行  mvn archetype:create-from-project 时读取了 archetype.properties 帮我们做了配置文件的修改。</li></ol><p>maven的脚手架工程下有两个重要的配置文件</p><ul><li><p>./src/test/resources/projects/basic/archetype.properties</p><ul><li>这里可以加入自定义变量，如  gitignore 变量</li></ul></li><li><p>./src/main/resources/META-INF/maven/archetype-metadata.xml</p></li></ul><p>下面是一个典型的archetype-metadata.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">archetype-descriptor</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/plugins/maven-archetype-plugin/archetype-descriptor/1.0.0 http://maven.apache.org/xsd/archetype-descriptor-1.0.0.xsd"</span> <span class="attr">name</span>=<span class="string">"example"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/plugins/maven-archetype-plugin/archetype-descriptor/1.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">requiredProperties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">requiredProperty</span> <span class="attr">key</span>=<span class="string">"gitignore"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">defaultValue</span>&gt;</span>.gitignore<span class="tag">&lt;/<span class="name">defaultValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">requiredProperty</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">requiredProperty</span> <span class="attr">key</span>=<span class="string">"port"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">defaultValue</span>&gt;</span>8888<span class="tag">&lt;/<span class="name">defaultValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">requiredProperty</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">requiredProperties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span> <span class="attr">filtered</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span><span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>__gitignore__<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>README.md<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>Jenkinsfile<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>pom.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">id</span>=<span class="string">"$&#123;rootArtifactId&#125;-client"</span> <span class="attr">dir</span>=<span class="string">"__rootArtifactId__-client"</span> <span class="attr">name</span>=<span class="string">"$&#123;rootArtifactId&#125;-client"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">packaged</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">id</span>=<span class="string">"$&#123;rootArtifactId&#125;-core"</span> <span class="attr">dir</span>=<span class="string">"__rootArtifactId__-core"</span> <span class="attr">name</span>=<span class="string">"$&#123;rootArtifactId&#125;-core"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">packaged</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">id</span>=<span class="string">"$&#123;rootArtifactId&#125;-server"</span> <span class="attr">dir</span>=<span class="string">"__rootArtifactId__-server"</span> <span class="attr">name</span>=<span class="string">"$&#123;rootArtifactId&#125;-server"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">packaged</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/META-INF/dubbo<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">id</span>=<span class="string">"$&#123;rootArtifactId&#125;-test"</span> <span class="attr">dir</span>=<span class="string">"__rootArtifactId__-test"</span> <span class="attr">name</span>=<span class="string">"$&#123;rootArtifactId&#125;-test"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">archetype-descriptor</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="archetype-metadata-xml-结构"><a href="#archetype-metadata-xml-结构" class="headerlink" title="archetype-metadata.xml 结构"></a>archetype-metadata.xml 结构</h2><p>简单介绍archetype-metadata.xml文件的基本结构</p><ul><li><code>&lt;requiredProperties&gt;</code>是属性变量定义层，在这里定义的变量可以在archetype工程文件中通过 <code>${xxx}</code> 来进行引用，文件名则可以通过 <code>__xxx__</code>来引用变量（这就是为什么要把<code>.gitignore</code>重命名为<code>__gitignore__</code>）。变量在执行 <code>mvn archetype:generate</code>时才录入真正内容</li><li>再往下其实就是定义将要生成的工程目录结构，首先是一个 <code>fileSets</code> （包含多个 <code>fileSet</code>标签）标签定义了根目录需要生成哪些文件，再通过多个<code>modules</code> 标签来定义多个子模块（如果是多模块工程的话）。这其中比较重要的其实还是 <code>fileSet</code>标签，fileSet有两个重要的属性<ul><li>filtered = true 如果为true，则该 <code>fileSet</code>包含的文件中的<code>${}</code> 占位符会被替换成相应的变量</li><li>packaged = true 如果为true，则 <code>src/main/java</code> 下得文件内容会被加入 指定包路径下</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个优秀少坑的脚手架还是能极大的提升生产力的，毕竟这种重复且无价值的劳动我们还是交给工具吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;开发新项目就需要搭建新工程，但是搭建新工程的这个过程是非常繁琐浪费时间的，并且不可避免的需要踩坑。更可怕的是，如果是在一个团
      
    
    </summary>
    
      <category term="maven" scheme="http://wangjunnan.github.io/categories/maven/"/>
    
    
      <category term="maven" scheme="http://wangjunnan.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel源码解析三（滑动窗口流量统计）</title>
    <link href="http://wangjunnan.github.io/2019/10/25/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%89%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%EF%BC%89/"/>
    <id>http://wangjunnan.github.io/2019/10/25/Sentinel源码解析三（滑动窗口流量统计）/</id>
    <published>2019-10-25T08:55:44.000Z</published>
    <updated>2019-11-08T07:45:51.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Sentinel</code>的核心功能之一是流量统计，例如我们常用的指标QPS，当前线程数等。上一篇文章中我们已经大致提到了提供数据统计功能的<code>Slot（StatisticSlot）</code>，<code>StatisticSlot</code>在<code>Sentinel</code>的整个体系中扮演了一个非常重要的角色，后续的一系列操作（限流，熔断）等都依赖于<code>StatisticSlot</code>所统计出的数据。</p><p>本文所要讨论的重点就是<code>StatisticSlot</code>是如何做的流量统计？</p><p>其实在之前介绍常用限流算法<a href="http://wangjunnan.club/2019/10/09/%E6%B5%85%E8%B0%88%E5%B8%B8%E7%94%A8%E7%9A%84%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">常用限流算法</a>的时候已经有提到过一个算法<code>滑动窗口限流</code>，该算法的滑动窗口原理其实跟<code>Sentinel</code>所提供的流量统计原理是一样的，都是基于时间窗口的滑动统计</p><h2 id="回到StatisticSlot"><a href="#回到StatisticSlot" class="headerlink" title="回到StatisticSlot"></a>回到StatisticSlot</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> prioritized, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 当前请求线程数加一</span></span><br><span class="line">node.increaseThreadNum();</span><br><span class="line"><span class="comment">// 新增请求数</span></span><br><span class="line">node.addPassRequest(count);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>StatisticSlot</code>主要统计了两种类型的数据</p><ol><li>线程数</li><li>请求数（QPS）</li></ol><p>对于线程数的统计比较简单，通过内部维护一个<code>LongAdder</code>来进行当前线程数的统计，每进入一个请求加1，每释放一个请求减1，从而得到当前的线程数</p><p>对于请求数QPS的统计则相对比较复杂，其中有用到滑动窗口原理（也是本文的重点），下面根据源码来深入的分析</p><h2 id="DefaultNode-和-StatisticNode"><a href="#DefaultNode-和-StatisticNode" class="headerlink" title="DefaultNode 和 StatisticNode"></a>DefaultNode 和 StatisticNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPassRequest</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父类（StatisticNode）来进行统计</span></span><br><span class="line">    <span class="keyword">super</span>.addPassRequest(count);</span><br><span class="line">    <span class="comment">// 根据clusterNode 汇总统计（背后也是调用父类StatisticNode）</span></span><br><span class="line">    <span class="keyword">this</span>.clusterNode.addPassRequest(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终都是调用了父类<code>StatisticNode</code>的<code>addPassRequest</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按秒统计，分成两个窗口，每个窗口500ms，用来统计QPS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Metric rollingCounterInSecond = <span class="keyword">new</span> ArrayMetric(SampleCountProperty.SAMPLE_COUNT,</span><br><span class="line">    IntervalProperty.INTERVAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按分钟统计，分成60个窗口，每个窗口 1000ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Metric rollingCounterInMinute = <span class="keyword">new</span> ArrayMetric(<span class="number">60</span>, <span class="number">60</span> * <span class="number">1000</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPassRequest</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    rollingCounterInSecond.addPass(count);</span><br><span class="line">    rollingCounterInMinute.addPass(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较简单，可以知道内部是调用了<code>ArrayMetric</code>的<code>addPass</code>方法来统计的，并且统计了两种不同时间维度的数据(秒级和分钟级)</p><h2 id="ArrayMetric"><a href="#ArrayMetric" class="headerlink" title="ArrayMetric"></a>ArrayMetric</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LeapArray&lt;MetricBucket&gt; data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayMetric</span><span class="params">(<span class="keyword">int</span> sampleCount, <span class="keyword">int</span> intervalInMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">new</span> OccupiableBucketLeapArray(sampleCount, intervalInMs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayMetric</span><span class="params">(<span class="keyword">int</span> sampleCount, <span class="keyword">int</span> intervalInMs, <span class="keyword">boolean</span> enableOccupy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enableOccupy) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> OccupiableBucketLeapArray(sampleCount, intervalInMs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> BucketLeapArray(sampleCount, intervalInMs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPass</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前窗口</span></span><br><span class="line">    WindowWrap&lt;MetricBucket&gt; wrap = data.currentWindow();</span><br><span class="line">    <span class="comment">// 2. 当前窗口加1</span></span><br><span class="line">    wrap.value().addPass(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayMetric</code>其实也是一个包装类，内部通过实例化<code>LeapArray</code>的对应实现类，来实现具体的统计逻辑，<code>LeapArray</code>是一个抽象类，<code>OccupiableBucketLeapArray</code>和<code>BucketLeapArray</code>都是其具体的实现类<br><code>OccupiableBucketLeapArray</code>在1.5版本之后才被引入，<strong>主要是为了解决一些高优先级的请求在限流触发的时候也能通过(通过占用未来时间窗口的名额来实现)</strong> 也是默认使用的LeapArray实现类</p><p>而统计的逻辑也比较清楚，分成了两步：</p><ol><li>定位到当前窗口</li><li>获取到当前窗口<code>WindowWrap</code>的<code>MetricBucket</code>并执行<code>addPass</code>逻辑</li></ol><p>这里我们先看下第二步中的<code>MetricBucket</code>类，看看它做了哪些事情</p><h3 id="MetricBucket"><a href="#MetricBucket" class="headerlink" title="MetricBucket"></a>MetricBucket</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放当前窗口各种类型的统计值(类型包括 PASS BLOCK EXCEPTION 等)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LongAdder[] counters;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MetricBucket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MetricEvent[] events = MetricEvent.values();</span><br><span class="line">    <span class="keyword">this</span>.counters = <span class="keyword">new</span> LongAdder[events.length];</span><br><span class="line">    <span class="keyword">for</span> (MetricEvent event : events) &#123;</span><br><span class="line">        counters[event.ordinal()] = <span class="keyword">new</span> LongAdder();</span><br><span class="line">    &#125;</span><br><span class="line">    initMinRt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统计pass数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPass</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    add(MetricEvent.PASS, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统计可占用的pass数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOccupiedPass</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    add(MetricEvent.OCCUPIED_PASS, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统计异常数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addException</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    add(MetricEvent.EXCEPTION, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统计block数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBlock</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    add(MetricEvent.BLOCK, n);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>MetricBucket通过定义了一个<code>LongAdder</code>数组来存储不同类型的流量统计值，具体的类型则都定义在<code>MetricEvent</code>枚举中。<br>执行<code>addPass</code>方法对应<code>LongAdder</code>数组索引下表为0的值递增</p><p>下面再来看下<code>data.currentWindow()</code>的内部逻辑</p><h3 id="OccupiableBucketLeapArray"><a href="#OccupiableBucketLeapArray" class="headerlink" title="OccupiableBucketLeapArray"></a>OccupiableBucketLeapArray</h3><p><code>OccupiableBucketLeapArray</code>继承了抽象类<code>LeapArray</code>，核心逻辑也是在<code>LeapArray</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间窗口大小 单位ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> windowLengthInMs;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切分的窗口数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> sampleCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计的时间间隔 intervalInMs = windowLengthInMs * sampleCount</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> intervalInMs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 窗口数组 数组大小 = sampleCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> AtomicReferenceArray&lt;WindowWrap&lt;T&gt;&gt; array;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * update lock 更新窗口时需要上锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock updateLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sampleCount  需要划分的窗口数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intervalInMs 间隔的统计时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeapArray</span><span class="params">(<span class="keyword">int</span> sampleCount, <span class="keyword">int</span> intervalInMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.windowLengthInMs = intervalInMs / sampleCount;</span><br><span class="line">    <span class="keyword">this</span>.intervalInMs = intervalInMs;</span><br><span class="line">    <span class="keyword">this</span>.sampleCount = sampleCount;</span><br><span class="line">    <span class="keyword">this</span>.array = <span class="keyword">new</span> AtomicReferenceArray&lt;&gt;(sampleCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowWrap&lt;T&gt; <span class="title">currentWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentWindow(TimeUtil.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上需要着重理解的是几个参数的含义：</p><ol><li>sampleCount 定义的窗口的数</li><li>intervalInMs 统计的时间间隔</li><li>windowLengthInMs 每个窗口的时间大小 = intervalInMs / sampleCount</li></ol><p><code>sampleCount</code> 比较好理解，就是需要定义几个窗口（默认秒级统计维度的话是两个窗口），<code>intervalInMs</code> 指的就是我们需要统计的时间间隔，例如我们统计QPS的话那就是1000ms，<code>windowLengthInMs</code> 指的每个窗口的大小，是由<code>intervalInMs</code>除以<code>sampleCount</code>得来</p><p>类似下图<br><img src="http://img.souche.com/f2e/35184370429c595e41100e9e70018761.jpg" alt>￼</p><p>理解了上诉几个参数的含义后，我们直接进入到<code>LeapArray</code>的<code>currentWindow(long time)</code>方法中去看看具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowWrap&lt;T&gt; <span class="title">currentWindow</span><span class="params">(<span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据当前时间戳计算当前所属的窗口数组索引下标</span></span><br><span class="line">    <span class="keyword">int</span> idx = calculateTimeIdx(timeMillis);</span><br><span class="line">    <span class="comment">// 计算当前窗口的开始时间戳</span></span><br><span class="line">    <span class="keyword">long</span> windowStart = calculateWindowStart(timeMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 从窗口数组中获取当前窗口项，分为三种情况</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * (1) 当前窗口为空还未创建，则初始化一个</span></span><br><span class="line"><span class="comment">     * (2) 当前窗口的开始时间和上面计算出的窗口开始时间一致，表明当前窗口还未过期，直接返回当前窗口</span></span><br><span class="line"><span class="comment">     * (3) 当前窗口的开始时间 小于 上面计算出的窗口开始时间，表明当前窗口已过期，需要替换当前窗口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        WindowWrap&lt;T&gt; old = array.get(idx);</span><br><span class="line">        <span class="keyword">if</span> (old == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 第一种情况，新建一个窗口项</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            WindowWrap&lt;T&gt; window = <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">            <span class="keyword">if</span> (array.compareAndSet(idx, <span class="keyword">null</span>, window)) &#123;</span><br><span class="line">                <span class="comment">// Successfully updated, return the created bucket.</span></span><br><span class="line">                <span class="keyword">return</span> window;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart == old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 第二种情况 直接返回</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &gt; old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 第三种情况 替换窗口</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (updateLock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Successfully get the update lock, now we reset the bucket.</span></span><br><span class="line">                    <span class="keyword">return</span> resetWindowTo(old, windowStart);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    updateLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &lt; old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">// 第四种情况，讲道理不会走到这里</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据当前时间戳计算当前所属的窗口数组索引下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateTimeIdx</span><span class="params">(<span class="comment">/*@Valid*/</span> <span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timeId = timeMillis / windowLengthInMs;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(timeId % array.length());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算当前窗口的开始时间戳</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">calculateWindowStart</span><span class="params">(<span class="comment">/*@Valid*/</span> <span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timeMillis - timeMillis % windowLengthInMs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法就是整个滑动窗口逻辑的核心代码，注释其实也写的比较清晰了，简单概括下可以分为以下几步：</p><ol><li>根据当前时间戳 和 窗口数组大小 获取到当前的窗口数组索引下标<code>idx</code>，如果窗口数是2，那其实<code>idx</code>只有两种值(0 或 1)</li><li>根据当前时间戳（<code>windowStart</code>） 计算得到当前窗口的开始时间戳值。通过<code>calculateWindowStart</code>计算来得到，这个方法还蛮有意思的，通过当前时间戳和窗口时间大小取余来得到 与当前窗口开始时间的 偏移量。比我用定时任务实现高级多了 … 😆 可以去对比一下我之前文章中的蠢实现 <a href="https://github.com/WangJunnan/learn/blob/master/algorithm/src/main/java/com/walm/learn/algorithm/ratelimit/SlidingWindowRateLimit.java" target="_blank" rel="noopener">滑动窗口算法定时任务实现</a></li><li>然后就是根据上面得到的两个值 来获取当前时间窗口，这里其实又分为三种情况<ul><li>当前窗口为空还未创建，则初始化一个</li><li>当前窗口的开始时间和上面计算出的窗口开始时间(<code>windowStart</code>)一致，表明当前窗口还未过期，直接返回当前窗口</li><li>当前窗口的开始时间 小于 上面计算出的窗口(<code>windowStart</code>)开始时间，表明当前窗口已过期，需要替换当前窗口</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，<code>currentWindow</code>方法的实现还是非常巧妙的，因为我在看<code>Sentinel</code>的源码前也写过一篇限流算法的文章，恰好其中也实现过一个滑动窗口限流算法，不过相比于<code>Sentinel</code>的实现，我用了定时任务去做窗口的切换更新，显然性能上更差，实现的也不优雅，大家也可以去对比一下。<a href="http://wangjunnan.club/2019/10/09/%E6%B5%85%E8%B0%88%E5%B8%B8%E7%94%A8%E7%9A%84%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">常用限流算法</a></p><p>Sentinel系列</p><ul><li><p><a href="http://wangjunnan.club/2019/10/11/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%80/" target="_blank" rel="noopener">Sentinel源码解析一</a></p></li><li><p><a href="http://wangjunnan.club/2019/10/16/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%BA%8C%EF%BC%88slot%E6%80%BB%E8%A7%88%EF%BC%89/" target="_blank" rel="noopener">Sentinel源码解析二（slot总览）</a></p></li><li><p><a href="http://wangjunnan.club/2019/10/25/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%89%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%EF%BC%89/" target="_blank" rel="noopener">Sentinel源码解析二（滑动窗口流量统计）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Sentinel&lt;/code&gt;的核心功能之一是流量统计，例如我们常用的指标QPS，当前线程数等。上一篇文章中我们已经大致提到了提
      
    
    </summary>
    
      <category term="java框架" scheme="http://wangjunnan.github.io/categories/java%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Sentinel" scheme="http://wangjunnan.github.io/categories/java%E6%A1%86%E6%9E%B6/Sentinel/"/>
    
    
      <category term="并发" scheme="http://wangjunnan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel源码解析二（slot总览）</title>
    <link href="http://wangjunnan.github.io/2019/10/16/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%BA%8C%EF%BC%88slot%E6%80%BB%E8%A7%88%EF%BC%89/"/>
    <id>http://wangjunnan.github.io/2019/10/16/Sentinel源码解析二（slot总览）/</id>
    <published>2019-10-16T01:57:32.000Z</published>
    <updated>2019-11-08T07:45:51.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文继续来分析Sentinel的源码，上篇文章对Sentinel的调用过程做了深入分析，主要涉及到了两个概念：插槽链和Node节点。那么接下来我们就根据插槽链的调用关系来依次分析每个插槽（slot）的源码。</p><p>默认插槽链的调用顺序，以及每种类型Node节点的关系都在上面文章开头分析过 <a href></a></p><h2 id="NodeSelectorSlot"><a href="#NodeSelectorSlot" class="headerlink" title="NodeSelectorSlot"></a>NodeSelectorSlot</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 相同的资源但是Context不同，分别新建 DefaultNode，并以ContextName为key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, DefaultNode&gt; map = <span class="keyword">new</span> HashMap&lt;String, DefaultNode&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据ContextName尝试获取DefaultNode</span></span><br><span class="line">    DefaultNode node = map.get(context.getName());</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            node = map.get(context.getName());</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化DefaultNode，每个Context对应一个</span></span><br><span class="line">                node = <span class="keyword">new</span> DefaultNode(resourceWrapper, <span class="keyword">null</span>);</span><br><span class="line">                HashMap&lt;String, DefaultNode&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;String, DefaultNode&gt;(map.size());</span><br><span class="line">                cacheMap.putAll(map);</span><br><span class="line">                cacheMap.put(context.getName(), node);</span><br><span class="line">                map = cacheMap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 构建 Node tree</span></span><br><span class="line">            ((DefaultNode)context.getLastNode()).addChild(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.setCurNode(node);</span><br><span class="line">    <span class="comment">// 唤醒执行下一个插槽</span></span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NodeSelectorSlot</code>顾名思义是用来构建<code>Node</code>的。<br>我们可以看到<code>NodeSelectorSlot</code>对于不同的上下文都会生成一个<code>DefaultNode</code>。这里还有一个要注意的点：<strong>相同的资源({@link ResourceWrapper#equals(Object)})将全局共享相同的{@link ProcessorSlotChain}，无论在哪个上下文中</strong>，因此不同的上下文可以进入到同一个对象的<code>NodeSelectorSlot.entry</code>方法中，那么这里要怎么区分不同的上下文所创建的资源Node呢？显然可以使用上下文名称作为映射键以区分相同的资源Node。</p><p>然后这里要考虑另一个问题。一个资源有可能创建多个<code>DefaultNode</code>（有多个上下文时），那么我们应该如何快速的获取总的统计数据呢？</p><p>答案就在下一个Slot(<code>ClusterBuilderSlot</code>)中被解决了。</p><h2 id="ClusterBuilderSlot"><a href="#ClusterBuilderSlot" class="headerlink" title="ClusterBuilderSlot"></a>ClusterBuilderSlot</h2><p>上面有提到一个问题，我们要如何统计不同上下文相同资源的总量数据。<code>ClusterBuilderSlot</code>给了很好的解决方案：具有相同资源名称的共享一个<code>ClusterNode</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相同的资源共享一个 ClusterNode</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Map&lt;ResourceWrapper, ClusterNode&gt; clusterNodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ClusterNode clusterNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 判断本资源是否已经初始化过clusterNode</span></span><br><span class="line">    <span class="keyword">if</span> (clusterNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clusterNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 没有初始化则初始化clusterNode</span></span><br><span class="line">                clusterNode = <span class="keyword">new</span> ClusterNode(resourceWrapper.getName(), resourceWrapper.getResourceType());</span><br><span class="line">                HashMap&lt;ResourceWrapper, ClusterNode&gt; newMap = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max(clusterNodeMap.size(), <span class="number">16</span>));</span><br><span class="line">                newMap.putAll(clusterNodeMap);</span><br><span class="line">                newMap.put(node.getId(), clusterNode);</span><br><span class="line"></span><br><span class="line">                clusterNodeMap = newMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给相同资源的DefaultNode设置一样的ClusterNode</span></span><br><span class="line">    node.setClusterNode(clusterNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果有来源则新建一个来源Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">""</span>.equals(context.getOrigin())) &#123;</span><br><span class="line">        Node originNode = node.getClusterNode().getOrCreateOriginNode(context.getOrigin());</span><br><span class="line">        context.getCurEntry().setOriginNode(originNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码其实就是做了一件事情，为资源创建<code>CluserNode</code>。这里我又要提一嘴 <strong>相同的资源({@link ResourceWrapper#equals(Object)})将全局共享相同的{@link ProcessorSlotChain}，无论在哪个上下文中</strong>。也就是说，能进入到同一个<code>ClusterBuilderSlot</code>对象的<code>entry</code>方法的请求都是来自同一个资源的，所以这些相同资源需要初始化一个统一的<code>CluserNode</code>用来做流量的汇总统计。</p><h2 id="LogSlot"><a href="#LogSlot" class="headerlink" title="LogSlot"></a>LogSlot</h2><p>代码比较简单，逻辑就是打印异常日志，就不分析了</p><h2 id="StatisticSlot"><a href="#StatisticSlot" class="headerlink" title="StatisticSlot"></a>StatisticSlot</h2><p><code>StatisticSlot</code> 是 <code>Sentinel</code> 的核心功能插槽之一，用于统计实时的调用数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> prioritized, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先进行后续的check，包括规则的check，黑白名单check</span></span><br><span class="line">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计默认qps 线程数</span></span><br><span class="line">        node.increaseThreadNum();</span><br><span class="line">        node.addPassRequest(count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据来源统计qps 线程数</span></span><br><span class="line">            context.getCurEntry().getOriginNode().increaseThreadNum();</span><br><span class="line">            context.getCurEntry().getOriginNode().addPassRequest(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;</span><br><span class="line">            <span class="comment">// 统计入口 qps 线程数</span></span><br><span class="line">            Constants.ENTRY_NODE.increaseThreadNum();</span><br><span class="line">            Constants.ENTRY_NODE.addPassRequest(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .... 省略其他代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StatisticSlot主要做了4种不同维度的流量统计"><a href="#StatisticSlot主要做了4种不同维度的流量统计" class="headerlink" title="StatisticSlot主要做了4种不同维度的流量统计"></a>StatisticSlot主要做了4种不同维度的流量统计</h2><ol><li>资源在上下文维度（DefaultNode）的统计</li><li>clusterNode 维度的统计</li><li>Origin 来源维度的统计</li><li>入口全局流量的统计</li></ol><p>关于流量的统计原理的本文就不深入分析了，接下来的文章中会单独分析</p><h2 id="SystemSlot"><a href="#SystemSlot" class="headerlink" title="SystemSlot"></a>SystemSlot</h2><p><code>SystemSlot</code>比较简单，其实就是根据<code>StatisticSlot</code>所统计的全局入口流量进行限流。</p><h2 id="AuthoritySlot"><a href="#AuthoritySlot" class="headerlink" title="AuthoritySlot"></a>AuthoritySlot</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    checkBlackWhiteAuthority(resourceWrapper, context);</span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkBlackWhiteAuthority</span><span class="params">(ResourceWrapper resource, Context context)</span> <span class="keyword">throws</span> AuthorityException </span>&#123;</span><br><span class="line">    Map&lt;String, Set&lt;AuthorityRule&gt;&gt; authorityRules = AuthorityRuleManager.getAuthorityRules();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (authorityRules == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 根据资源获取黑白名单规则</span></span><br><span class="line">    Set&lt;AuthorityRule&gt; rules = authorityRules.get(resource.getName());</span><br><span class="line">    <span class="keyword">if</span> (rules == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对规则进行校验，只要有一条不通过 就抛异常</span></span><br><span class="line">    <span class="keyword">for</span> (AuthorityRule rule : rules) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!AuthorityRuleChecker.passCheck(rule, context)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthorityException(context.getOrigin(), rule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AuthoritySlot</code>会对资源的黑白名单做检查，并且只要有一条不通过就抛异常。</p><h2 id="FlowSlot"><a href="#FlowSlot" class="headerlink" title="FlowSlot"></a>FlowSlot</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> prioritized, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    checkFlow(resourceWrapper, context, node, count, prioritized);</span><br><span class="line"></span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkFlow</span><span class="params">(ResourceWrapper resource, Context context, DefaultNode node, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="comment">// 检查限流规则</span></span><br><span class="line">    checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>slot</code>主要根据预设的资源的统计信息，按照固定的次序，依次生效。如果一个资源对应两条或者多条流控规则，则会根据如下次序依次检验，直到全部通过或者有一个规则生效为止:<br>并且同样也会根据三种不同的维度来进行限流：</p><ol><li>资源在上下文维度（DefaultNode）的统计</li><li>clusterNode 维度的统计</li><li>Origin 来源维度的统计</li></ol><p>关于流控规则源码的深入分析就不在本篇文章赘述了</p><h2 id="DegradeSlot"><a href="#DegradeSlot" class="headerlink" title="DegradeSlot"></a>DegradeSlot</h2><p>这个<code>slot</code>主要针对资源的平均响应时间（RT）以及异常比率，来决定资源是否在接下来的时间被自动熔断掉。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>相同的资源({@link ResourceWrapper#equals(Object)})将全局共享相同的{@link ProcessorSlotChain}，无论在哪个上下文中</li><li>流控有多个维度，分别包括：1.不同上下文中的资源 2.相同资源 3.入口流量 3.相同的来源</li></ol><p>Sentinel系列</p><ul><li><p><a href="http://wangjunnan.club/2019/10/11/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%80/" target="_blank" rel="noopener">Sentinel源码解析一</a></p></li><li><p><a href="http://wangjunnan.club/2019/10/16/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%BA%8C%EF%BC%88slot%E6%80%BB%E8%A7%88%EF%BC%89/" target="_blank" rel="noopener">Sentinel源码解析二（slot总览）</a></p></li><li><p><a href="http://wangjunnan.club/2019/10/25/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%89%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%EF%BC%89/" target="_blank" rel="noopener">Sentinel源码解析二（滑动窗口流量统计）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本文继续来分析Sentinel的源码，上篇文章对Sentinel的调用过程做了深入分析，主要涉及到了两个概念：插槽链和Nod
      
    
    </summary>
    
      <category term="java框架" scheme="http://wangjunnan.github.io/categories/java%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Sentinel" scheme="http://wangjunnan.github.io/categories/java%E6%A1%86%E6%9E%B6/Sentinel/"/>
    
    
      <category term="并发" scheme="http://wangjunnan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Sentinel" scheme="http://wangjunnan.github.io/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel源码解析一</title>
    <link href="http://wangjunnan.github.io/2019/10/11/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%80/"/>
    <id>http://wangjunnan.github.io/2019/10/11/Sentinel源码解析一/</id>
    <published>2019-10-11T11:42:31.000Z</published>
    <updated>2019-11-17T09:28:12.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>Sentinel</code>作为ali开源的一款轻量级流控框架，<strong>主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性</strong>。相比于<code>Hystrix</code>，<code>Sentinel</code>的设计更加简单，在 <code>Sentinel</code>中资源定义和规则配置是分离的，也就是说用户可以先通过<code>Sentinel API</code>给对应的业务逻辑定义资源（埋点），然后在需要的时候再配置规则，通过这种组合方式，极大的增加了<code>Sentinel</code>流控的灵活性。</p><p>引入<code>Sentinel</code>带来的性能损耗非常小。只有在业务单机量级超过25W QPS的时候才会有一些显著的影响（5% - 10% 左右），单机QPS不太大的时候损耗几乎可以忽略不计。</p><p><code>Sentinel</code>提供两种埋点方式:</p><ul><li><code>try-catch</code> 方式（通过 <code>SphU.entry(...)</code>），用户在 catch 块中执行异常处理 / fallback</li><li><code>if-else</code> 方式（通过 <code>SphO.entry(...)</code>），当返回 false 时执行异常处理 / fallback</li></ul><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在此之前，需要先了解一下<code>Sentinel</code>的工作流程<br>在 <code>Sentinel</code> 里面，所有的资源都对应一个资源名称（<code>resourceName</code>），每次资源调用都会创建一个 <code>Entry</code> 对象。<code>Entry</code> 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 <code>SphU API</code> 显式创建。<code>Entry</code> 创建的时候，同时也会创建一系列功能插槽（<code>slot chain</code>），这些插槽有不同的职责，例如默认情况下会创建一下7个插槽：</p><ul><li><code>NodeSelectorSlot</code> 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li><li><code>ClusterBuilderSlot</code> 则用于存储资源的统计信息以及调用者信息，例如该资源的 <code>RT, QPS, thread count</code> 等等，这些信息将用作为多维度限流，降级的依据；</li><li><code>StatisticSlot</code> 则用于记录、统计不同纬度的 <code>runtime</code> 指标监控信息；</li><li><code>FlowSlot</code> 则用于根据预设的限流规则以及前面 <code>slot</code> 统计的状态，来进行流量控制；</li><li><code>AuthoritySlot</code> 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li><code>DegradeSlot</code> 则通过统计信息以及预设的规则，来做熔断降级；</li><li><code>SystemSlot</code> 则通过系统的状态，例如 <code>load1</code> 等，来控制总的入口流量</li></ul><p>注意：这里的插槽链都是一一对应资源名称的</p><p>上面的所介绍的插槽（<code>slot chain</code>）是<code>Sentinel</code>非常重要的概念。同时还有一个非常重要的概念那就是<code>Node</code>，为了帮助理解，尽我所能画了下面这张图，可以看到整个结构非常的像一棵树：</p><p><img src="http://img.souche.com/f2e/4dbc7a0b3df647df5c612fe39a86ee97.jpg" alt></p><p>简单解释下上图：</p><ul><li>顶部蓝色的<code>node</code>节点为根节点，全局唯一</li><li>下面黄色的节点为入口节点，每个<code>CentextName</code>(上下文名称)一一对应一个<ul><li>可以有多个子节点（对应多种资源）</li></ul></li><li>中间绿色框框中的节点都是属于同一个资源的(相同的<code>ResourceName</code>)</li><li>最底下紫色的节点是集群节点，可以理解成绿色框框中Node资源的整合</li></ul><p>以上2个概念务必要理清楚，之后再一步一步看源码会比较清晰</p><p>下面我们将从入口源码开始一步一步分析整个调用过程：</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>下面的是一个<code>Sentinel</code>使用的示例代码，我们就从这里切入开始分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个名称为entrance1，来源为appA 的上下文Context</span></span><br><span class="line">ContextUtil.enter(<span class="string">"entrance1"</span>, <span class="string">"appA"</span>);</span><br><span class="line"><span class="comment">// 创建一个资源名称nodeA的Entry</span></span><br><span class="line"> Entry nodeA = SphU.entry(<span class="string">"nodeA"</span>);</span><br><span class="line"> <span class="keyword">if</span> (nodeA != <span class="keyword">null</span>) &#123;</span><br><span class="line">    nodeA.exit();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 清除上下文</span></span><br><span class="line"> ContextUtil.exit();</span><br></pre></td></tr></table></figure><h3 id="ContextUtil-enter-“entrance1”-“appA”"><a href="#ContextUtil-enter-“entrance1”-“appA”" class="headerlink" title="ContextUtil.enter(“entrance1”, “appA”)"></a>ContextUtil.enter(“entrance1”, “appA”)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">enter</span><span class="params">(String name, String origin)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断上下文名称是否为默认的名称（sentinel_default_context） 是的话直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.CONTEXT_DEFAULT_NAME.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ContextNameDefineException(</span><br><span class="line">            <span class="string">"The "</span> + Constants.CONTEXT_DEFAULT_NAME + <span class="string">" can't be permit to defined!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trueEnter(name, origin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Context <span class="title">trueEnter</span><span class="params">(String name, String origin)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先从ThreadLocal中尝试获取，获取到则直接返回</span></span><br><span class="line">    Context context = contextHolder.get();</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Map&lt;String, DefaultNode&gt; localCacheNameMap = contextNameNodeMap;</span><br><span class="line">        <span class="comment">// 尝试从缓存中获取该上下文名称对应的 入口节点</span></span><br><span class="line">        DefaultNode node = localCacheNameMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 判断缓存中入口节点数量是否大于2000</span></span><br><span class="line">            <span class="keyword">if</span> (localCacheNameMap.size() &gt; Constants.MAX_CONTEXT_NAME_SIZE) &#123;</span><br><span class="line">                setNullContext();</span><br><span class="line">                <span class="keyword">return</span> NULL_CONTEXT;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加锁</span></span><br><span class="line">                    LOCK.lock();</span><br><span class="line">                    <span class="comment">// 双重检查锁</span></span><br><span class="line">                    node = contextNameNodeMap.get(name);</span><br><span class="line">                    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 判断缓存中入口节点数量是否大于2000</span></span><br><span class="line">                        <span class="keyword">if</span> (contextNameNodeMap.size() &gt; Constants.MAX_CONTEXT_NAME_SIZE) &#123;</span><br><span class="line">                            setNullContext();</span><br><span class="line">                            <span class="keyword">return</span> NULL_CONTEXT;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 根据上下文名称生成入口节点（entranceNode）</span></span><br><span class="line">                            node = <span class="keyword">new</span> EntranceNode(<span class="keyword">new</span> StringResourceWrapper(name, EntryType.IN), <span class="keyword">null</span>);</span><br><span class="line">                            <span class="comment">// 加入至全局根节点下</span></span><br><span class="line">                            Constants.ROOT.addChild(node);</span><br><span class="line">                            <span class="comment">// 加入缓存中</span></span><br><span class="line">                            Map&lt;String, DefaultNode&gt; newMap = <span class="keyword">new</span> HashMap&lt;&gt;(contextNameNodeMap.size() + <span class="number">1</span>);</span><br><span class="line">                            newMap.putAll(contextNameNodeMap);</span><br><span class="line">                            newMap.put(name, node);</span><br><span class="line">                            contextNameNodeMap = newMap;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    LOCK.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化上下文对象</span></span><br><span class="line">        context = <span class="keyword">new</span> Context(node, name);</span><br><span class="line">        context.setOrigin(origin);</span><br><span class="line">        <span class="comment">// 设置到当前线程中</span></span><br><span class="line">        contextHolder.set(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要做了2件事情</p><ol><li>根据<code>ContextName</code>生成<code>entranceNode</code>，并加入缓存，每个<code>ContextName</code>对应一个入口节点<code>entranceNode</code></li><li>根据<code>ContextName</code>和<code>entranceNode</code>初始化上下文对象，并将上下文对象设置到当前线程中</li></ol><p>这里有几点需要注意：</p><ol><li>入口节点数量不能大于2000，大于会直接抛异常</li><li>每个<code>ContextName</code>对应一个入口节点<code>entranceNode</code></li><li>每个<code>entranceNode</code>都有共同的父节点。也就是根节点</li></ol><h3 id="Entry-nodeA-SphU-entry-“nodeA”"><a href="#Entry-nodeA-SphU-entry-“nodeA”" class="headerlink" title="Entry nodeA = SphU.entry(“nodeA”)"></a>Entry nodeA = SphU.entry(“nodeA”)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SphU.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title">entry</span><span class="params">(String name)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="comment">// 默认为 出口流量类型，单位统计数为1</span></span><br><span class="line">    <span class="keyword">return</span> Env.sph.entry(name, EntryType.OUT, <span class="number">1</span>, OBJECTS0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CtSph.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Entry <span class="title">entry</span><span class="params">(String name, EntryType type, <span class="keyword">int</span> count, Object... args)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="comment">// 生成资源对象</span></span><br><span class="line">    StringResourceWrapper resource = <span class="keyword">new</span> StringResourceWrapper(name, type);</span><br><span class="line">    <span class="keyword">return</span> entry(resource, count, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Entry <span class="title">entry</span><span class="params">(ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> entryWithPriority(resourceWrapper, count, <span class="keyword">false</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码比较简单，不指定<code>EntryType</code>的话，则默认为出口流量类型，最终会调用<code>entryWithPriority</code>方法，主要业务逻辑也都在这个方法中</p><ul><li>entryWithPriority方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">entryWithPriority</span><span class="params">(ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程上下文对象</span></span><br><span class="line">    Context context = ContextUtil.getContext();</span><br><span class="line">    <span class="comment">// 上下文名称对应的入口节点是否已经超过阈值2000，超过则会返回空 CtEntry</span></span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> NullContext) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有指定上下文名称，则使用默认名称，也就是默认入口节点</span></span><br><span class="line">        context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局开关</span></span><br><span class="line">    <span class="keyword">if</span> (!Constants.ON) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成插槽链</span></span><br><span class="line">    ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 表示资源(插槽链)超过6000，因此不会进行规则检查。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成 Entry 对象</span></span><br><span class="line">    Entry e = <span class="keyword">new</span> CtEntry(resourceWrapper, chain, context);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 开始执行插槽链 调用逻辑</span></span><br><span class="line">        chain.entry(context, resourceWrapper, <span class="keyword">null</span>, count, prioritized, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e1) &#123;</span><br><span class="line">        <span class="comment">// 清除上下文</span></span><br><span class="line">        e.exit(count, args);</span><br><span class="line">        <span class="keyword">throw</span> e1;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e1) &#123;</span><br><span class="line">        <span class="comment">// 除非Sentinel内部存在错误，否则不应发生这种情况。</span></span><br><span class="line">        RecordLog.info(<span class="string">"Sentinel unexpected exception"</span>, e1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法可以说是涵盖了整个Sentinel的核心逻辑</p><ol><li>获取上下文对象，如果上下文对象还未初始化，则使用默认名称初始化。初始化逻辑在上文已经分析过</li><li>判断全局开关</li><li>根据给定的资源生成插槽链，插槽链是跟资源相关的，Sentinel最关键的逻辑也都在各个插槽中。初始化的逻辑在<code>lookProcessChain(resourceWrapper);</code>中，下文会分析</li><li>依顺序执行每个插槽逻辑</li></ol><h3 id="lookProcessChain-resourceWrapper-方法"><a href="#lookProcessChain-resourceWrapper-方法" class="headerlink" title="lookProcessChain(resourceWrapper)方法"></a>lookProcessChain(resourceWrapper)方法</h3><p><code>lookProcessChain</code>方法为指定资源生成插槽链，下面我们来看下它的初始化逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProcessorSlot&lt;Object&gt; <span class="title">lookProcessChain</span><span class="params">(ResourceWrapper resourceWrapper)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据资源尝试从全局缓存中获取</span></span><br><span class="line">    ProcessorSlotChain chain = chainMap.get(resourceWrapper);</span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 非常常见的双重检查锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            chain = chainMap.get(resourceWrapper);</span><br><span class="line">            <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断资源数是否大于6000</span></span><br><span class="line">                <span class="keyword">if</span> (chainMap.size() &gt;= Constants.MAX_SLOT_CHAIN_SIZE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 初始化插槽链</span></span><br><span class="line">                chain = SlotChainProvider.newSlotChain();</span><br><span class="line">                Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = <span class="keyword">new</span> HashMap&lt;ResourceWrapper, ProcessorSlotChain&gt;(</span><br><span class="line">                    chainMap.size() + <span class="number">1</span>);</span><br><span class="line">                newMap.putAll(chainMap);</span><br><span class="line">                newMap.put(resourceWrapper, chain);</span><br><span class="line">                chainMap = newMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>根据资源尝试从全局缓存中获取插槽链。每个资源对应一个插槽链（资源嘴多只能定义6000个）</li><li>初始化插槽链上的插槽（<code>SlotChainProvider.newSlotChain()</code>方法中）</li></ol><p>下面我们看下初始化插槽链上的插槽的逻辑</p><h3 id="SlotChainProvider-newSlotChain"><a href="#SlotChainProvider-newSlotChain" class="headerlink" title="SlotChainProvider.newSlotChain()"></a>SlotChainProvider.newSlotChain()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessorSlotChain <span class="title">newSlotChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否已经初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (builder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 加载 SlotChain </span></span><br><span class="line">    resolveSlotChainBuilder();</span><br><span class="line">    <span class="comment">// 加载失败则使用默认 插槽链 </span></span><br><span class="line">    <span class="keyword">if</span> (builder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RecordLog.warn(<span class="string">"[SlotChainProvider] Wrong state when resolving slot chain builder, using default"</span>);</span><br><span class="line">        builder = <span class="keyword">new</span> DefaultSlotChainBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建完成</span></span><br><span class="line">    <span class="keyword">return</span> builder.build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java自带 SPI机制 加载 slotChain</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveSlotChainBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;SlotChainBuilder&gt; list = <span class="keyword">new</span> ArrayList&lt;SlotChainBuilder&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> hasOther = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 尝试获取自定义SlotChainBuilder，通过JAVA SPI机制扩展</span></span><br><span class="line">    <span class="keyword">for</span> (SlotChainBuilder builder : LOADER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (builder.getClass() != DefaultSlotChainBuilder.class) &#123;</span><br><span class="line">            hasOther = <span class="keyword">true</span>;</span><br><span class="line">            list.add(builder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasOther) &#123;</span><br><span class="line">        builder = list.get(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未获取到自定义 SlotChainBuilder 则使用默认的</span></span><br><span class="line">        builder = <span class="keyword">new</span> DefaultSlotChainBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RecordLog.info(<span class="string">"[SlotChainProvider] Global slot chain builder resolved: "</span></span><br><span class="line">        + builder.getClass().getCanonicalName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先会尝试获取自定义的<code>SlotChainBuilder</code>来构建插槽链，自定义的<code>SlotChainBuilder</code>可以通过JAVA SPI机制来扩展</li><li>如果未配置自定义的<code>SlotChainBuilder</code>，则会使用默认的<code>DefaultSlotChainBuilder</code>来构建插槽链，<code>DefaultSlotChainBuilder</code>所构建的插槽就是文章开头我们提到的7种<code>Slot</code>。每个插槽都有其对应的职责，各司其职，后面我们会详细分析这几个插槽的源码，及所承担的职责。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章开头的提到的两个点(插槽链和Node)，这是Sentinel的重点，理解这两点对于阅读源码来说事半功倍</p><p>Sentinel系列</p><ul><li><p><a href="http://wangjunnan.club/2019/10/11/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%80/" target="_blank" rel="noopener">Sentinel源码解析一</a></p></li><li><p><a href="http://wangjunnan.club/2019/10/16/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%BA%8C%EF%BC%88slot%E6%80%BB%E8%A7%88%EF%BC%89/" target="_blank" rel="noopener">Sentinel源码解析二（slot总览）</a></p></li><li><p><a href="http://wangjunnan.club/2019/10/25/Sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%89%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%EF%BC%89/" target="_blank" rel="noopener">Sentinel源码解析二（滑动窗口流量统计）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Sentinel&lt;/code&gt;作为ali开源的一款轻量级流控框架，&lt;strong&gt;主要以流量为切入点，从流量控制、熔断降级、系统
      
    
    </summary>
    
      <category term="java框架" scheme="http://wangjunnan.github.io/categories/java%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Sentinel" scheme="http://wangjunnan.github.io/categories/java%E6%A1%86%E6%9E%B6/Sentinel/"/>
    
    
      <category term="并发" scheme="http://wangjunnan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Sentinel" scheme="http://wangjunnan.github.io/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>浅谈常用的限流算法</title>
    <link href="http://wangjunnan.github.io/2019/10/09/%E6%B5%85%E8%B0%88%E5%B8%B8%E7%94%A8%E7%9A%84%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <id>http://wangjunnan.github.io/2019/10/09/浅谈常用的限流算法/</id>
    <published>2019-10-09T02:15:47.000Z</published>
    <updated>2019-11-08T07:45:51.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。今天我们要聊的就是限流（Rate Limit），限流的目的很简单，就是为了保护系统不被瞬时大流量冲垮，<br>限流这个概念我其实很早之前就有去了解过，不过无奈之前工作所接触业务的并发量实在是谈不上限流。目前公司大促峰值QPS在2w往上，自然而然需要用到限流，特别是类似秒杀这种瞬时流量非常大但实际成单率低的业务场景。</p><p>目前比较常用的限流算法有三种</p><ul><li>计数器固定窗口算法</li><li>计数器滑动窗口算法</li><li>漏桶算法</li><li>令牌桶算法</li></ul><h2 id="计数器固定窗口算法"><a href="#计数器固定窗口算法" class="headerlink" title="计数器固定窗口算法"></a>计数器固定窗口算法</h2><p>计数器固定窗口算法是最简单的限流算法，实现方式也比较简单。就是通过维护一个单位时间内的计数值，每当一个请求通过时，就将计数值加1，当计数值超过预先设定的阈值时，就拒绝单位时间内的其他请求。如果单位时间已经结束，则将计数器清零，开启下一轮的计数。</p><p>但是这种实现会有一个问题，举个例子: </p><p>假设我们设定1秒内允许通过的请求阈值是200，如果有用户在时间窗口的最后几毫秒发送了200个请求，紧接着又在下一个时间窗口开始时发送了200个请求，那么这个用户其实在一秒内成功请求了400次，显然超过了阈值但并不会被限流。其实这就是临界值问题，那么临界值问题要怎么解决呢？</p><ul><li>代码实现 – <a href="https://github.com/WangJunnan/learn/blob/master/algorithm/src/main/java/com/walm/learn/algorithm/ratelimit/CounterRateLimit.java" target="_blank" rel="noopener">CounterRateLimit.java</a></li></ul><h2 id="计数器滑动窗口算法"><a href="#计数器滑动窗口算法" class="headerlink" title="计数器滑动窗口算法"></a>计数器滑动窗口算法</h2><p>计数器滑动窗口法就是为了解决上述固定窗口计数存在的问题而诞生，学过TCP协议的同学应该对滑动窗口不陌生，其实还是不太一样的，下文我们要说的滑动窗口是基于时间来划分窗口的。而TCP的滑动窗口指的是能够接受的字节数，并且大小是可变的（拥塞控制）</p><p>滑动窗口是怎么做的？</p><p>前面说了固定窗口存在临界值问题，要解决这种临界值问题，显然只用一个窗口是解决不了问题的。假设我们仍然设定1秒内允许通过的请求是200个，但是在这里我们需要把1秒的时间分成多格，假设分成5格（格数越多，流量过渡越平滑），每格窗口的时间大小是200毫秒，每过200毫秒，就将窗口向前移动一格。为了便于理解，可以看下图<br><img src="http://img.souche.com/f2e/c9acdd415f157334407d233927474513.jpg" alt></p><p>图中将窗口划为5份，每个小窗口中的数字表示在这个窗口中请求数，所以通过观察上图，可知在当前时间快（200毫秒）允许通过的请求数应该是20而不是200（只要超过20就会被限流），因为我们最终统计请求数时是需要把当前窗口的值进行累加，进而得到当前请求数来判断是不是需要进行限流。</p><p>那么滑动窗口限流法是完美的吗？<br>细心观察的我们应该能马上发现问题，<strong>滑动窗口限流法其实就是计数器固定窗口算法的一个变种</strong>。流量的过渡是否平滑依赖于我们设置的<strong>窗口格数也就是统计时间间隔</strong>，格数越多，统计越精确，但是具体要分多少格我们也说不上来呀… </p><ul><li>代码实现 – <a href="https://github.com/WangJunnan/learn/blob/master/algorithm/src/main/java/com/walm/learn/algorithm/ratelimit/SlidingWindowRateLimit.java" target="_blank" rel="noopener">SlidingWindowRateLimit.java</a></li></ul><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>上面所介绍的两种算法都不能非常平滑的过渡，下面就是漏桶算法登场了<br>什么是漏桶算法？<br>漏桶算法以一个常量限制了出口流量速率，因此漏桶算法可以平滑突发的流量。其中漏桶作为流量容器我们可以看做一个FIFO的队列，当入口流量速率大于出口流量速率时，因为流量容器是有限的，当超出流量容器大小时，超出的流量会被丢弃。<br>下图比较形象的说明了漏桶算法的原理，其中水龙头是入口流量，漏桶是流量容器，匀速流出的水是出口流量。<br><img src="http://img.souche.com/f2e/0186f84da43e3286f3d79e3a2f2d538e.jpg" alt></p><p>漏桶算法的特点</p><ul><li>漏桶具有固定容量，出口流量速率是固定常量（流出请求）</li><li>入口流量可以以任意速率流入到漏桶中（流入请求）</li><li><p>如果入口流量超出了桶的容量，则流入流量会溢出（新请求被拒绝）</p></li><li><p>代码实现 – <a href="https://github.com/WangJunnan/learn/blob/master/algorithm/src/main/java/com/walm/learn/algorithm/ratelimit/LeakyBucketRateLimit.java" target="_blank" rel="noopener">LeakyBucketRateLimit.java</a></p></li></ul><p><strong>不过因为漏桶算法限制了流出速率是一个固定常量值，所以漏桶算法不支持出现突发流出流量。但是在实际情况下，流量往往是突发的。</strong></p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法是漏桶算法的改进版，可以支持突发流量。不过与漏桶算法不同的是，令牌桶算法的漏桶中存放的是令牌而不是流量。<br>那么令牌桶算法是怎么突发流量的呢？<br>最开始，令牌桶是空的，我们以恒定速率往令牌桶里加入令牌，令牌桶被装满时，多余的令牌会被丢弃。当请求到来时，会先尝试从令牌桶获取令牌（相当于从令牌桶移除一个令牌），获取成功则请求被放行，获取失败则阻塞活拒绝请求。</p><p><img src="http://img.souche.com/f2e/d6decf371f1085a63bcf925bfcedeeae.jpg" alt></p><p>令牌桶算法的特点</p><ul><li>最多可以存发b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃</li><li>请求到来时，如果令牌桶中少于n个令牌，那么不会删除令牌。该请求会被限流（阻塞活拒绝）</li><li>算法允许最大b(令牌桶大小)个请求的突发</li></ul><p><strong>令牌桶算法限制的是平均流量，因此其允许突发流量（只要令牌桶中有令牌，就不会被限流）</strong></p><ul><li>代码实现 – <a href="https://github.com/WangJunnan/learn/blob/master/algorithm/src/main/java/com/walm/learn/algorithm/ratelimit/TokenBucketRateLimit.java" target="_blank" rel="noopener">TokenBucketRateLimit.java</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，基本把以上4种限流算法的原理都解释清楚了。每种限流算法都有其固定特点，及各自适用的场景，其中计数器算法是其中最简单的，相当于滑动窗口算法的简化版，令牌桶算法相比漏桶算法对资源的利用率更高（允许突发流量）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。今天我们要聊的就是限流（Rate Limit），限流的目的很简单，就是为了保护系
      
    
    </summary>
    
      <category term="算法" scheme="http://wangjunnan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式" scheme="http://wangjunnan.github.io/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="并发" scheme="http://wangjunnan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="算法" scheme="http://wangjunnan.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中时间的表现形式</title>
    <link href="http://wangjunnan.github.io/2019/09/26/JAVA%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"/>
    <id>http://wangjunnan.github.io/2019/09/26/JAVA中时间的表现形式/</id>
    <published>2019-09-26T08:02:02.000Z</published>
    <updated>2019-11-08T07:45:51.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大多数时候我们在表示时间的概念时，可能并不会去特意关注时区这个概念，毕竟在国内时区都是统一的，我们只需要使用默认时区 北京时间 就可以了。是的，在写这篇文章之前，我也没有过多的去关注时区的概念，以及在JAVA中的表现形式。但是因为目前所在的公司是跨境公司，公司主要业务在印度，印度时间跟北京时间显然是不同的。</p><h2 id="时区的概念"><a href="#时区的概念" class="headerlink" title="时区的概念"></a>时区的概念</h2><p>在这之前先说一下时区的概念，以及解释几个专有名词。<br>时区是地球上的区域使用同一个时间定义，整个全球被分成24个时区。所以每差一个时区，区时相差一个小时，相差多少个时区，就相差多少个小时。东边的时区时间比西边的时区时间早。北京时间指的就是东八区的时间。</p><h3 id="UTC时间和本地时间"><a href="#UTC时间和本地时间" class="headerlink" title="UTC时间和本地时间"></a>UTC时间和本地时间</h3><p>UTC时间又称协调世界时，是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间(GMT)。对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。<br><strong>如果时间是以协调世界时（UTC）表示，则在时间后面直接加上一个“Z”（不加空格）。“Z”是协调世界时中0时区的标志。</strong></p><ul><li>UTC偏移量和本地时间<br>例如北京时间的UTC偏移量是 +8，则当UTC时间是 2:00 时，北京时间的 10:00。所以借助于UTC时间，我们可以把全球的时间都统一起来。</li></ul><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>时区可以很好的表示各地的时间，但各个时区的字面时间显示仍然还是不同的，所以我们需要一种方式在来让世界各个角落的时间都有一样的表现形式。这引申出了时间戳，也被称为Unix时间(Unix time)，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。</p><h2 id="Java8中的时间类型"><a href="#Java8中的时间类型" class="headerlink" title="Java8中的时间类型"></a>Java8中的时间类型</h2><p>在JAVA8中，提供了新的时间日期操作类，相对于之前的 Date 类，可以说使用起来方便了许多，下面依次来介绍几个关键类。</p><ul><li>Instant 用来表示时间戳</li><li>LocalDateTime 单纯表示字面时间，不带时区信息。也就是说 <code>LocalDateTime = 2019-09-25 00:00:00</code>，这个时间我们并不知道是北京时间还是东京时间，仅仅用作字面时间</li><li>ZonedDateTime 含有时区信息的时间，类似于北京时间，UTC+8</li></ul><h3 id="它们如何表示时间"><a href="#它们如何表示时间" class="headerlink" title="它们如何表示时间"></a>它们如何表示时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(LocalDateTime.now());</span><br><span class="line">System.out.println(Instant.now());</span><br><span class="line">System.out.println(ZonedDateTime.now());</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">26</span>T14:<span class="number">50</span>:<span class="number">43.741</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">26</span>T06:<span class="number">50</span>:<span class="number">43.742</span>Z</span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">26</span>T14:<span class="number">50</span>:<span class="number">43.803</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure><p>可以看到<br><code>LocalDateTime</code> 会根据UTC时间获取到本地时间显示，但是会把时区信息丢弃<br><code>Instant</code> 则直接表示的UTC世界标准时间<br><code>ZonedDateTime</code> 会根据UTC时间获取到本地时间显示，同时也会显示当前的时区信息</p><p>其实ZonedDateTime 是由 Instant 加上时区信息结合而来，通过ZonedDateTime可以直接获取到Instant时间戳信息</p><h3 id="如何转换"><a href="#如何转换" class="headerlink" title="如何转换"></a>如何转换</h3><p>转换的核心其实都是往时间戳（世界标准时间）靠拢，试想是不是这样？只有转成了标准时间才能转成其他时区的时间</p><ul><li><code>ZonedDateTime</code> <-> <code>Instant</code></-></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zonedDateTime -&gt; instant</span></span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.now();</span><br><span class="line">Instant instant = zonedDateTime.toInstant();</span><br><span class="line"></span><br><span class="line"><span class="comment">// instant -&gt; zonedDateTime 要指定时区信息</span></span><br><span class="line">ZoneId DEFAULT_ZONE_ID = ZoneId.of(<span class="string">"Asia/Shanghai"</span>);</span><br><span class="line">zonedDateTime = instant.atZone(DEFAULT_ZONE_ID);</span><br></pre></td></tr></table></figure><ul><li><code>LocalDateTime</code> <-> <code>Instant</code></-></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalDateTime -&gt; Instant</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">Instant instant = localDateTime.toInstant(ZoneOffset.of(<span class="string">"+08:00"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instant -&gt; ZonedDateTime -&gt; LocalDateTime</span></span><br><span class="line"><span class="comment">// Instant 需要先转换成 ZonedDateTime 再转换成本地时间</span></span><br><span class="line">ZonedDateTime zonedDateTime = instant.atZone(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">localDateTime = zonedDateTime.toLocalDateTime();</span><br></pre></td></tr></table></figure><ul><li><code>LocalDateTime</code> <-> <code>ZonedDateTime</code></-></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalDateTime -&gt; ZonedDateTime 需要指定本地所在时区</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">ZonedDateTime zonedDateTime = localDateTime.atZone(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接转换成本地时间</span></span><br><span class="line">localDateTime = zonedDateTime.toLocalDateTime();</span><br></pre></td></tr></table></figure><p>可以看到，在转换过程中，会频繁的手动指定时区，主要原因是<code>LocalDateTime</code>并不带有时区信息，如果我们要转换成标准时间，就需要手动指定时区。<strong>所以为了避免转换过程中的错误，我们应该尽量使用时间戳来来传输时间。</strong></p><h4 id="与其他api的转换"><a href="#与其他api的转换" class="headerlink" title="与其他api的转换"></a>与其他api的转换</h4><ul><li>Timestamp <-> LocalDateTime</-></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Timestamp -&gt; LocalDateTime</span><br><span class="line">Timestamp timestamp = Timestamp.from(Instant.now());</span><br><span class="line">LocalDateTime localDateTime = timestamp.toLocalDateTime();</span><br><span class="line"></span><br><span class="line">// LocalDateTime -&gt; Timestamp 有两种方式</span><br><span class="line">// 1. 直接按本地默认时区转时区</span><br><span class="line">timestamp = Timestamp.valueOf(localDateTime);</span><br><span class="line">// 2. 指定时区转</span><br><span class="line">timestamp = Timestamp.from(localDateTime.toInstant(ZoneOffset.of(&quot;+08:00&quot;)));</span><br></pre></td></tr></table></figure><ul><li>Date <-> LocalDateTime</-></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Date -&gt; LocalDateTime</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">LocalDateTime localDateTime = date.toInstant().atZone(ZoneId.of(<span class="string">"Asia/Shanghai"</span>)).toLocalDateTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalDateTime -&gt; Date</span></span><br><span class="line">date = Date.from(localDateTime.toInstant(ZoneOffset.of(<span class="string">"+08:00"</span>)));</span><br></pre></td></tr></table></figure><p>更多例子<a href="https://github.com/WangJunnan/walm-common/blob/master/src/main/java/com/walm/common/util/DateTimeUtils.java" target="_blank" rel="noopener">DateTimeUtils.java</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后还是建议操作时间时使用时间戳，这样子没有时区的概念，也就不会产生歧义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;大多数时候我们在表示时间的概念时，可能并不会去特意关注时区这个概念，毕竟在国内时区都是统一的，我们只需要使用默认时区 北京时间 就可以了。是
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://wangjunnan.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring的@Configuration @Bean注解</title>
    <link href="http://wangjunnan.github.io/2019/09/03/Spring%E7%9A%84-Configuration-Bean%E6%B3%A8%E8%A7%A3/"/>
    <id>http://wangjunnan.github.io/2019/09/03/Spring的-Configuration-Bean注解/</id>
    <published>2019-09-03T08:47:31.000Z</published>
    <updated>2019-11-08T07:45:51.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>之前Spring 一直用的xml配置文件比较多，现在发现新公司用的注解比较多。也就是通过定义一个配置类(以@Configuration注解的类)内部在方法上注解 <a href="#"><a href="#">@Bean</a></a> 注解来完成Bean的依赖注入Spring容器。用注解来配置的话，其实就是减少了配置文件的工作，但总体来说代码可读性其实是会下降的。不过也省去了一大堆的xml配置文件</p><h2 id="直接看源码"><a href="#直接看源码" class="headerlink" title="直接看源码"></a>直接看源码</h2><p>下面就从源码层面来看看  通过注解配置有什么不同</p><p>之前有分析过Spring对Bean的解析，<strong>是通过把我们配置的Bean信息抽象成了一个BeanDefiniion对象。这个对象持有了我们配置的Bean的元数据</strong></p><p>那么其实 <a href="#"><a href="#">@Bean</a></a> 的注解的原理也是类似，也是通过将我们配置的Bean信息抽象成一个BeanDefiniion对象</p><p>这里我们分两种情况讨论，一种是 Spring 通过 xml文件配置实现注解配置，一种就是我们现在非常流行的 SpringBoot实现的注解配置。其实两者实现原理一致，只是配置入口略有不同。</p><p>先看 普通 Spring 应用的配置:</p><p>如果我们要在  普通 Spring 应用中实现注解配置。那么我们需要在Spring的配置文件中配置以下几个配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;context:annotation-config&gt;</span><br><span class="line"></span><br><span class="line">&lt;context:component-scan&gt;</span><br></pre></td></tr></table></figure><p>这两个配置的意思是什么呢？</p><p>我们直接看Spring是如何解析这两个标签的吧，通过在<code>META-INF/spring.handlers</code>目录下根据<code>spring.handlers</code>文件可以找到 Context 标签  解析入口类 <code>ContextNamespaceHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"property-placeholder"</span>, <span class="keyword">new</span> PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"property-override"</span>, <span class="keyword">new</span> PropertyOverrideBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"annotation-config"</span>, <span class="keyword">new</span> AnnotationConfigBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"component-scan"</span>, <span class="keyword">new</span> ComponentScanBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"load-time-weaver"</span>, <span class="keyword">new</span> LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"mbean-export"</span>, <span class="keyword">new</span> MBeanExportBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"mbean-server"</span>, <span class="keyword">new</span> MBeanServerBeanDefinitionParser());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了上面的解析源码，可以知道annotation-config由AnnotationConfigBeanDefinitionParser解析。component-scan由ComponentScanBeanDefinitionParser解析。这里就是Spring XML 注解配置的入口，下面我们来依次分析这两个解析类干了什么事情？</p><ul><li>ComponentScanBeanDefinitionParser</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</span><br><span class="line"></span><br><span class="line">String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line"></span><br><span class="line">ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line"></span><br><span class="line">ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里扫描了我们配置的 base-package 包下全部 beanDefinitions，并抽象成了 BeanDefinitionHolder类</span></span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将抽象的 beanDefinitions 全部注册进 Spring容器中，注 这里包含了被@Configuration注解的类</span></span><br><span class="line"></span><br><span class="line">registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AnnotationConfigBeanDefinitionParser</li></ul><p>主要逻辑在 AnnotationConfigUtils 工具类的 registerAnnotationConfigProcessors方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Object source = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一些 BeanFactoryPostProcessor 进Spring容器，会在getBean之前全部执行。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一般用来在容器实例化Bean前，对BeanDefinition做修改，或添加新的BeanDefinition等前置修改</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主要逻辑就在这里</span></span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line"></span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register component for the surrounding &lt;context:annotation-config&gt; element.</span></span><br><span class="line"></span><br><span class="line">CompositeComponentDefinition compDefinition = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line"></span><br><span class="line">parserContext.pushContainingComponent(compDefinition);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nest the concrete beans in the surrounding component.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123;</span><br><span class="line"></span><br><span class="line">parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(processorDefinition));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally register the composite component.</span></span><br><span class="line"></span><br><span class="line">parserContext.popAndRegisterContainingComponent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnnotationConfigUtils.class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加支持 annotation-config 配置的一些BeanFactoryPostProcessor 实现类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line"></span><br><span class="line">beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line"></span><br><span class="line">beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Configuration 注解解析</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @Autowired 注解解析</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Required 注解解析</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 JSR-250做支持 解析注解 @Resource @PostConstruct @PreDestroy </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line"></span><br><span class="line">AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"></span><br><span class="line"><span class="string">"Cannot load optional framework class: "</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line"></span><br><span class="line">def.setSource(source);</span><br><span class="line"></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> beanDefs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 annotation-config 配置其实就是添加了几个 BeanFactoryPostProcessor 实现类，以此来实现 Autowired Configuration @Resource @PostConstruct @PreDestroy 等注解的实现。其他的注解暂且不看，我们直接看今天的重点  Configuration 注解是如何解析，@Configuration是通过 BeanFactoryPostProcessor 的实现类 ConfigurationClassPostProcessor 类在Spring启动的时候执行的（具体BeanFactoryPostProcessor的执行时机可以看我另一篇博文[<a href> <a href="https://www.yuque.com/wangjunnan/pnhnfo/bx15ai" target="_blank" rel="noopener">链接](https://www.yuque.com/wangjunnan/pnhnfo/bx15ai)</a></a>）</p><ul><li>ConfigurationClassPostProcessor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否已经执行过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"></span><br><span class="line"><span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"></span><br><span class="line"><span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正式执行逻辑</span></span><br><span class="line"></span><br><span class="line">processConfigBeanDefinitions(registry);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有 BeanDefinition name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line"></span><br><span class="line">BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否已经处理过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line"></span><br><span class="line">ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 条件筛选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"></span><br><span class="line">configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栓选完为空  直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 @Order 注解排序</span></span><br><span class="line"></span><br><span class="line">configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 BeanName 生成策略</span></span><br><span class="line"></span><br><span class="line">SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line"></span><br><span class="line">sbr = (SingletonBeanRegistry) registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line"></span><br><span class="line">BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse each @Configuration class</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @Configuration 注解</span></span><br><span class="line"></span><br><span class="line">ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line"></span><br><span class="line">Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">parser.parse(candidates);</span><br><span class="line"></span><br><span class="line">parser.validate();</span><br><span class="line"></span><br><span class="line">Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line"></span><br><span class="line">configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取并解析注册 BeanDefinition</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line"></span><br><span class="line">registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line"></span><br><span class="line">alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">candidates.clear();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 处理新加入的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line"></span><br><span class="line">String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line"></span><br><span class="line">alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line"></span><br><span class="line">BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line"></span><br><span class="line">!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line"></span><br><span class="line">candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">candidateNames = newCandidateNames;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span></span><br><span class="line"></span><br><span class="line">((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的执行逻辑在ConfigurationClassParser 类的 parse 方法中</p><ul><li>ConfigurationClassParser</li></ul><p>核心解析方法是 doProcessConfigurationClass方法，下面直接看这个方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line"></span><br><span class="line">processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @PropertySource </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line"></span><br><span class="line">sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line"></span><br><span class="line">org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line"></span><br><span class="line">processPropertySource(propertySource);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">logger.warn(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line"></span><br><span class="line"><span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @ComponentScan </span></span><br><span class="line"></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line"></span><br><span class="line">sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line"></span><br><span class="line">!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line"></span><br><span class="line">BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">bdCand = holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"></span><br><span class="line">parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @Import annotations</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @Import</span></span><br><span class="line"></span><br><span class="line">processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @ImportResource</span></span><br><span class="line"></span><br><span class="line">AnnotationAttributes importResource =</span><br><span class="line"></span><br><span class="line">AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line"></span><br><span class="line">String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line"></span><br><span class="line">configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process individual @Bean methods</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @Bean</span></span><br><span class="line"></span><br><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line"></span><br><span class="line">configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process default methods on interfaces</span></span><br><span class="line"></span><br><span class="line">processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process superclass, if any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line"></span><br><span class="line">String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">"java"</span>) &amp;&amp;</span><br><span class="line"></span><br><span class="line">!<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的代码依次解析了 @PropertySource，@ComponentScan <a href="#"><a href="#">@Bean</a></a> <a href="#"><a href="#">@Import</a></a> 等注解。这里我们重点关注 <a href="#"><a href="#">@Bean</a></a> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取 @bean 注解修饰的  方法元数据信息</span></span><br><span class="line"></span><br><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装成 BeanMethod </span></span><br><span class="line"></span><br><span class="line">configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们回到 ConfigurationClassPostProcessor ，解析完 元数据之后，就是加载注册 BeanDefinition了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">TrackedConditionEvaluator trackedConditionEvaluator = <span class="keyword">new</span> TrackedConditionEvaluator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line"></span><br><span class="line">loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</span><br><span class="line"></span><br><span class="line">String beanName = configClass.getBeanName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.registry.removeBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line"></span><br><span class="line">registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析之前 解析 @bean 加入的 beanMethod信息</span></span><br><span class="line"></span><br><span class="line">loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line"></span><br><span class="line">loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看 loadBeanDefinitionsForBeanMethod 方法的实现，其实就是从BeanMethod中提取信息组装成 BeanDefinition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForBeanMethod</span><span class="params">(BeanMethod beanMethod)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ConfigurationClass configClass = beanMethod.getConfigurationClass();</span><br><span class="line"></span><br><span class="line">MethodMetadata metadata = beanMethod.getMetadata();</span><br><span class="line"></span><br><span class="line">String methodName = metadata.getMethodName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要跳过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line"></span><br><span class="line">configClass.skippedBeanMethods.add(methodName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (configClass.skippedBeanMethods.contains(methodName)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);</span><br><span class="line"></span><br><span class="line">Assert.state(bean != <span class="keyword">null</span>, <span class="string">"No @Bean annotation attributes"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑别名 名称</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(bean.getStringArray(<span class="string">"name"</span>)));</span><br><span class="line"></span><br><span class="line">String beanName = (!names.isEmpty() ? names.remove(<span class="number">0</span>) : methodName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册别名 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String alias : names) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.registry.registerAlias(beanName, alias);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Has this effectively been overridden before (e.g. via XML)?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否在 xml配置文件中  已经配置过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isOverriddenByExistingDefinition(beanMethod, beanName)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),</span><br><span class="line"></span><br><span class="line">beanName, <span class="string">"Bean name derived from @Bean method '"</span> + beanMethod.getMetadata().getMethodName() +</span><br><span class="line"></span><br><span class="line"><span class="string">"' clashes with bean name for containing configuration class; please make those names unique!"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConfigurationClassBeanDefinition beanDef = <span class="keyword">new</span> ConfigurationClassBeanDefinition(configClass, metadata);</span><br><span class="line"></span><br><span class="line">beanDef.setResource(configClass.getResource());</span><br><span class="line"></span><br><span class="line">beanDef.setSource(<span class="keyword">this</span>.sourceExtractor.extractSource(metadata, configClass.getResource()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里可以知道 @bean 配置是 通过 FactoryMethod 来初始化的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (metadata.isStatic()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static @Bean method</span></span><br><span class="line"></span><br><span class="line">beanDef.setBeanClassName(configClass.getMetadata().getClassName());</span><br><span class="line"></span><br><span class="line">beanDef.setFactoryMethodName(methodName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// instance @Bean method</span></span><br><span class="line"></span><br><span class="line">beanDef.setFactoryBeanName(configClass.getBeanName());</span><br><span class="line"></span><br><span class="line">beanDef.setUniqueFactoryMethodName(methodName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line"></span><br><span class="line">beanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置autowire属性</span></span><br><span class="line"></span><br><span class="line">Autowire autowire = bean.getEnum(<span class="string">"autowire"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (autowire.isAutowire()) &#123;</span><br><span class="line"></span><br><span class="line">beanDef.setAutowireMode(autowire.value());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置initMethod 初始化方法</span></span><br><span class="line"></span><br><span class="line">String initMethodName = bean.getString(<span class="string">"initMethod"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(initMethodName)) &#123;</span><br><span class="line"></span><br><span class="line">beanDef.setInitMethodName(initMethodName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置destroyMethod 销毁方法</span></span><br><span class="line"></span><br><span class="line">String destroyMethodName = bean.getString(<span class="string">"destroyMethod"</span>);</span><br><span class="line"></span><br><span class="line">beanDef.setDestroyMethodName(destroyMethodName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 scope</span></span><br><span class="line"></span><br><span class="line">ScopedProxyMode proxyMode = ScopedProxyMode.NO;</span><br><span class="line"></span><br><span class="line">AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">beanDef.setScope(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line"></span><br><span class="line">proxyMode = attributes.getEnum(<span class="string">"proxyMode"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (proxyMode == ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line"></span><br><span class="line">proxyMode = ScopedProxyMode.NO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace the original bean definition with the target one, if necessary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如有必要，将原始Bean定义替换为目标Bean定义</span></span><br><span class="line"></span><br><span class="line">BeanDefinition beanDefToRegister = beanDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (proxyMode != ScopedProxyMode.NO) &#123;</span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName), <span class="keyword">this</span>.registry,</span><br><span class="line"></span><br><span class="line">proxyMode == ScopedProxyMode.TARGET_CLASS);</span><br><span class="line"></span><br><span class="line">beanDefToRegister = <span class="keyword">new</span> ConfigurationClassBeanDefinition(</span><br><span class="line"></span><br><span class="line">(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"></span><br><span class="line">logger.debug(String.format(<span class="string">"Registering bean definition for @Bean method %s.%s()"</span>,</span><br><span class="line"></span><br><span class="line">configClass.getMetadata().getClassName(), beanName));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.registry.registerBeanDefinition(beanName, beanDefToRegister);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解析到这里为止，@Bean配置的Bean信息就被全部抽象成了一个 BeanDefinition对象，接下来的Bean加载等等一大堆逻辑走的就是Spring的同一套逻辑了。</p><p>以上是通过在配置文件中配置 <code>&lt;context:annotation-config&gt; &lt;context:component-scan&gt;</code>。</p><h2 id="Springboot怎么做的"><a href="#Springboot怎么做的" class="headerlink" title="Springboot怎么做的"></a>Springboot怎么做的</h2><p>那么Spring Boot并不需要配置文件，它又是在哪里配置了入口呢？</p><p>其实在之前的分析Spring boot的启动过程时 已经有提到了 <a href="https://www.yuque.com/wangjunnan/pnhnfo/qtapgd" target="_blank" rel="noopener"><a href="https://www.yuque.com/wangjunnan/pnhnfo/qtapgd" target="_blank" rel="noopener">链接</a></a> ，其实是在初始化 Spring容器的构造方法中进行了配置的加载，并且最终也是调用了 AnnotationConfigUtils 工具类的 registerAnnotationConfigProcessors方法</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>终于写完了，其实分析来分析去，不论是Spring Boot Spring mvc 其实最核心不变的还是 Spring Framework，只要把核心搞清楚了，下次Spring 又推出什么 Spring xxx 也能应付自如</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;之前Spring 一直用的xml配置文件比较多，现在发现新公司用的注解比较多。也就是通过定义一个配置类(以@Configuration注解的
      
    
    </summary>
    
      <category term="Spring" scheme="http://wangjunnan.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://wangjunnan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>MVC-HttpRequestHandler接口静态资源的关系</title>
    <link href="http://wangjunnan.github.io/2019/08/30/MVC-HttpRequestHandler%E6%8E%A5%E5%8F%A3%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://wangjunnan.github.io/2019/08/30/MVC-HttpRequestHandler接口静态资源的关系/</id>
    <published>2019-08-30T08:10:15.000Z</published>
    <updated>2019-11-08T07:45:51.789Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring Mvc，一般我们都会配置对静态资源的拦截，因为静态资源处理有别与普通请求，需要进行特殊配置。</p><p>比较常用的配置有这几种</p><ol><li>Tomcat defaultServelt 激活tomcat自带的defaultServelt 用来处理静态资源</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.js<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.css<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>&lt;mvc:resources/&gt;</code> Spring mvc自己提供的静态资源处理器</li></ol><p>例如做如下配置，就可以将<code>static</code>开头的路径全部访问至<code>static</code>目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/static/**"</span> <span class="attr">location</span>=<span class="string">"/static/"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>那么这个配置的实现原理是什么？</p><p>通过阅读源码其实可以知道实际上是 Spring mvc 自动帮我们注册了一个<code>SimpleUrlHandlerMapping</code>，在之前分析<code>SimpleUrlHandlerMapping</code>时也有提到它其实可以当成拦截器用，这里其实就是一个实例。注册了<code>HandlerMapping</code>必然要确定<code>handler</code>处理器，这里的<code>handler</code>处理器其实就是<code>HttpRequestHandler</code>接口的实现类（ResourceHttpRequestHandler）</p><ol start="3"><li>使用 <code>&lt;mvc:default-servlet-handler/&gt;</code> 激活Spring mvc提供的默认静态资源处理器</li></ol><p>使用这个配置其实原理与第二个配置非常相似，也是利用了<code>SimpleUrlHandlerMapping</code>，并且<code>handler</code>处理器也是<code>HttpRequestHandler</code>接口的实现类，只是把具体的实现类换成了<code>DefaultServletHttpRequestHandler</code>，相比第二种配置，此种配置无法自定义。</p><ul><li>写在后面</li></ul><p>不过我们要是使用Spring boot开发，也就省去了这一堆繁琐的配置，包括静态资源的配置也都是自动完成配置。只要按照约定将静态资源放置在classpath下的这几个目录下（<code>public</code>,<code>resource</code>,<code>static</code>），就不需要任何配置，不得不说，约定优于配置还是可以极大的提升开发效率的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Spring Mvc，一般我们都会配置对静态资源的拦截，因为静态资源处理有别与普通请求，需要进行特殊配置。&lt;/p&gt;
&lt;p&gt;比较常用的配置有这几种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Tomcat defaultServelt 激活tomcat自带的defaultServelt 用来
      
    
    </summary>
    
      <category term="Spring" scheme="http://wangjunnan.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://wangjunnan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>手写一个starter</title>
    <link href="http://wangjunnan.github.io/2019/08/28/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAstarter/"/>
    <id>http://wangjunnan.github.io/2019/08/28/手写一个starter/</id>
    <published>2019-08-28T08:47:15.000Z</published>
    <updated>2019-11-08T07:45:51.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前文说过，<code>Spring Boot</code>最大的优势在于自动配置，我么只需要引入一个个第三方提供的<code>starter</code>就可以快速集成第三方功能，既然<code>starter</code>这么方便，我们自己应该也可以写一个。</p><h2 id="快速写一个starter"><a href="#快速写一个starter" class="headerlink" title="快速写一个starter"></a>快速写一个starter</h2><ul><li>新建一个maven项目</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.walm&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;boot-test-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><ul><li>新建一个config类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">HelloWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新建一个提供服务的service类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最重要的是一步，需要让spring能够扫描到我们的 config HelloWorldConfig 类<ul><li>在resource 文件夹下新建一个 META-INF 文件夹</li><li>新建一个 spring.factories 文件</li></ul></li></ul><p>在spring.factories文件中配置我们的写的HelloWorldConfig类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.walm.boottest.HelloWorldConfig</span><br></pre></td></tr></table></figure><p>这样一个简单的 springboot  starter 就完成了，最后本地安装 install我们的starter jar包就可以在其他项目中引用了</p><ul><li>引用starter，只需要在项目引用 该jar包即可</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.walm&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;boot-test-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>下面我们简单分析一下 stater的原理</p><h2 id="starter-自动配置原理"><a href="#starter-自动配置原理" class="headerlink" title="starter 自动配置原理"></a>starter 自动配置原理</h2><p>首先自动配置的原理关键一定是在 spring.factories 文件是如何被加载到的这个点上去探究</p><p>需要从spring boot的启动过程一步一步的去看了</p><p>首先，我们启动一个spring-boot项目，肯定会有一个配置注解 <code>SpringBootApplication</code> 那么这个注解到底起什么作用呢？</p><ul><li>SpringBootApplication.class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration.class)</span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration.class)</span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base packages to scan for annotated components. Use &#123;<span class="doctag">@link</span> #scanBasePackageClasses&#125;</span></span><br><span class="line"><span class="comment"> * for a type-safe alternative to String-based package names.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> base packages to scan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">"basePackages"</span>)</span><br><span class="line">String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Type-safe alternative to &#123;<span class="doctag">@link</span> #scanBasePackages&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment"> * scan for annotated components. The package of each class specified will be scanned.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Consider creating a special no-op marker class or interface in each package that</span></span><br><span class="line"><span class="comment"> * serves no purpose other than being referenced by this attribute.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> base packages to scan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">"basePackageClasses"</span>)</span><br><span class="line">Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里着重看 EnableAutoConfiguration 这个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 @Import(AutoConfigurationImportSelector.class)这个注解，这里就是我们自动配置的入口<br>注意，解析Import注解其实是通过 BeanFactoryPostProcessor 接口来扩展的</p><p>下面我们来看下AutoConfigurationImportSelector.class 类的实现，AutoConfigurationImportSelector 实现了ImportSelector接口</p><ul><li>ImportSelector</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解析import注解的时候会调用指定ImportSelector 接口实现 的 selectImports方法。下面我们看下AutoConfigurationImportSelector的 selectImports方法实现</p><ul><li>selectImports</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// 获取  META-INF/spring.factories  文件中的配置信息</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">attributes);</span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写一个starter还是非常简单的，核心就是要让springboot自动扫描到我们的 配置类，核心逻辑其实就是通过扫描我们的自定义的META-INF/spring.factories文件来进行自动配置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;前文说过，&lt;code&gt;Spring Boot&lt;/code&gt;最大的优势在于自动配置，我么只需要引入一个个第三方提供的&lt;code&gt;starter
      
    
    </summary>
    
      <category term="Spring" scheme="http://wangjunnan.github.io/categories/Spring/"/>
    
      <category term="SpringBoot" scheme="http://wangjunnan.github.io/categories/Spring/SpringBoot/"/>
    
    
      <category term="Spring" scheme="http://wangjunnan.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://wangjunnan.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的启动过程</title>
    <link href="http://wangjunnan.github.io/2019/08/27/SpringBoot%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://wangjunnan.github.io/2019/08/27/SpringBoot的启动过程/</id>
    <published>2019-08-27T08:44:29.000Z</published>
    <updated>2019-11-08T07:45:51.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在我之前写的文章中有详细分析过<code>Spring</code>的启动过程，如何大家有深入阅读过<code>Spring Framework</code>的核心源码，那么阅读<code>Spring Boot</code>的源码会比较轻松。个人觉得<code>Spring Boot</code>核心的东西比较少，其核心还是<code>Spring Framework</code>。</p><h2 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h2><p>还是一步到位，直接看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 统计启动时间</span></span><br><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置 java.awt.headless 参数</span></span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 获取监听器</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">args);</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">            <span class="comment">// 创建 context容器</span></span><br><span class="line">context = createApplicationContext();</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">SpringBootExceptionReporter.class,</span><br><span class="line"><span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">            <span class="comment">// 准备容器</span></span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">printedBanner);</span><br><span class="line">            <span class="comment">// 刷新容器</span></span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>createApplicationContext<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line"><span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"Unable create a default ApplicationContext, "</span></span><br><span class="line">+ <span class="string">"please specify an ApplicationContextClass"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 这里会引入一些BeanFactoryProcess，比如 ConfigurationClassPostProcessor 解析Configuration注解的</span></span><br><span class="line"><span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注: 引入的BeanFactoryProcess 的逻辑在DEFAULT_SERVLET_WEB_CONTEXT_CLASS的构造方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看下 AnnotationConfigServletWebServerApplicationContext 的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigServletWebServerApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相当于xml中配置了 &lt;context:annotation-config&gt;</span></span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 相当于xml中配置了 &lt;context:component-scan&gt;</span></span><br><span class="line"><span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在看下 AnnotatedBeanDefinitionReader 的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@code</span> AnnotatedBeanDefinitionReader&#125; for the given registry and using</span></span><br><span class="line"><span class="comment"> * the given &#123;<span class="doctag">@link</span> Environment&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the &#123;<span class="doctag">@code</span> BeanFactory&#125; to load bean definitions into,</span></span><br><span class="line"><span class="comment"> * in the form of a &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> environment the &#123;<span class="doctag">@code</span> Environment&#125; to use when evaluating bean definition</span></span><br><span class="line"><span class="comment"> * profiles.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line">Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">Assert.notNull(environment, <span class="string">"Environment must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.registry = registry;</span><br><span class="line"><span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 在这里 注册了一堆的 BeanFactoryProcess </span></span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面主要prepareContext和refreshContext方法</p><ul><li>prepareContext</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">applyInitializers(context);</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">context.getBeanFactory().registerSingleton(<span class="string">"springApplicationArguments"</span>,</span><br><span class="line">applicationArguments);</span><br><span class="line"><span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">context.getBeanFactory().registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the sources</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">        <span class="comment">// 这里引入了 启动类</span></span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注： 这里的主要作用就是引入了启动类，加入到 BeanFactory中</strong></p><ul><li>refreshContext<ul><li>后面其实 就是 Spring 统一的一套了</li><li>可以看我的之前写的 Spring 源码解析系列</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Springboot的核心在于自动配置 快速集成 。一些原本需要在Spring xml文件配置的东西，Spring 只需要一个注解就帮我们都做了。不过前文也都说了，核心还是 Spring Framework。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在我之前写的文章中有详细分析过&lt;code&gt;Spring&lt;/code&gt;的启动过程，如何大家有深入阅读过&lt;code&gt;Spring Framewo
      
    
    </summary>
    
      <category term="Spring" scheme="http://wangjunnan.github.io/categories/Spring/"/>
    
      <category term="SpringBoot" scheme="http://wangjunnan.github.io/categories/Spring/SpringBoot/"/>
    
    
      <category term="Spring" scheme="http://wangjunnan.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://wangjunnan.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MVC源码解析-HandlerAdapter</title>
    <link href="http://wangjunnan.github.io/2019/08/25/MVC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-HandlerAdapter/"/>
    <id>http://wangjunnan.github.io/2019/08/25/MVC源码解析-HandlerAdapter/</id>
    <published>2019-08-25T08:08:54.000Z</published>
    <updated>2019-11-08T07:45:51.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上篇文章分析了<code>handerMapping</code>的实现。本篇文章会继续分析和<code>handerMapping</code>相辅相成的<code>handerAdapter</code>。</p><p><strong>什么是<code>handerAdapter</code>？</strong><br>在理解了<code>handerMapping</code>的基础上，我们应该发现了一个问题。就是每个<code>handerMapping</code>所匹配的到的hander实现是不一样的。比如<code>RequestMappingHandlerMapping</code>的hander的实现是一个<code>HandlerMethod</code>实现，而<code>BeanNameUrlHandlerMapping</code>的hander则是一个<code>Controller</code>接口实现类。所以如果我们要是不引入<code>handerAdapter</code>的话，就无法统一的去执行各自的hander</p><p>上文所说<code>handerAdapter</code>和<code>handerMapping</code>是相辅相成的。以下列出了几个的对应关系</p><ul><li><code>RequestMappingHandlerMapping</code> -&gt; <code>RequestMappingHandlerAdapter</code></li><li><code>BeanNameUrlHandlerMapping</code> -&gt; <code>SimpleControllerHandlerAdapter</code></li><li><code>SimpleUrlHandlerMapping</code> -&gt; <code>SimpleControllerHandlerAdapter</code></li><li><code>SimpleUrlHandlerMapping</code> -&gt; <code>HttpRequestHandlerAdapter</code></li></ul><p>其中<code>SimpleUrlHandlerMapping</code>比较特殊，可以对应多个<code>Adapter</code>，主要原因是<code>SimpleUrlHandlerMapping</code>中的<code>handler</code>类型也可以有多种，比较常见的有<code>Controller</code>接口实现类，<code>HttpRequestHandler</code>接口实现类。</p><h2 id="HandlerAdapter接口"><a href="#HandlerAdapter接口" class="headerlink" title="HandlerAdapter接口"></a>HandlerAdapter接口</h2><p>先看下HandlerAdapter接口的几个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 判断指定hander是否可以被当前Adapter支持</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler handler object to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether or not this object can use the given handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行hander方法</span></span><br><span class="line"><span class="comment"> * returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ModelAndView object with the name of the view and the required</span></span><br><span class="line"><span class="comment"> * model data, or &#123;<span class="doctag">@code</span> null&#125; if the request has been handled directly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与HttpServlet的&#123;<span class="doctag">@code</span> getLastModified&#125;方法的约定相同</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler handler to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the lastModified value for the given handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> javax.servlet.http.HttpServlet#getLastModified</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.servlet.mvc.LastModified#getLastModified</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是<code>supports</code>和<code>hander</code>方法</p><ol><li><code>supports</code>用于判断指定hander是否可以被当前Adapter支持</li><li><code>hander</code>方法用于执行指定的hander的核心逻辑</li></ol><p>下面简单来看下各个HandlerAdapter接口的实现类，看一下对这两个核心方法的实现</p><h2 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h2><ul><li>supports</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法比较简单，判断<code>handler</code>的类型是不是<code>HandlerMethod</code>，如果是的话，则说明该handler可以被该adapter所适配，那么就会直接返回该Adapter。</p><ul><li>hander</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">protected ModelAndView handleInternal(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">// 定义 ModelAndView</span><br><span class="line">ModelAndView mav;</span><br><span class="line">checkRequest(request);</span><br><span class="line"></span><br><span class="line">// 处于一个session时判断是否需要同步</span><br><span class="line">if (this.synchronizeOnSession) &#123;</span><br><span class="line">// 获取当前session</span><br><span class="line">HttpSession session = request.getSession(false);</span><br><span class="line">if (session != null) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">synchronized (mutex) &#123;</span><br><span class="line">   // 执行 handerMethod 实际逻辑</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// No HttpSession available -&gt; no mutex necessary</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// </span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">prepareResponse(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleControllerHandlerAdapter"><a href="#SimpleControllerHandlerAdapter" class="headerlink" title="SimpleControllerHandlerAdapter"></a>SimpleControllerHandlerAdapter</h2><ul><li>supports</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否是handler的类型是否是Controller</p><ul><li>handler</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的话，则直接执行Controller的handleRequest方法</p><h2 id="HttpRequestHandlerAdapter"><a href="#HttpRequestHandlerAdapter" class="headerlink" title="HttpRequestHandlerAdapter"></a>HttpRequestHandlerAdapter</h2><ul><li>supports</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpRequestHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>handler</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">((HttpRequestHandler) handler).handleRequest(request, response);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现逻辑与<code>SimpleControllerHandlerAdapter</code>类似</p><p>对于以上几个Adapter的匹配顺序，Spring会根据各个Adapter的Order值来进行排序，依次匹配直到找到合适的为止。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>HandlerAdapter</code>的核心逻辑就是承接不同的<code>HandlerMapping</code>做适配。本身的逻辑并不复杂，其引入的适配中间层设计模式是一个非常好的案例。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;上篇文章分析了&lt;code&gt;handerMapping&lt;/code&gt;的实现。本篇文章会继续分析和&lt;code&gt;handerMapping&lt;/co
      
    
    </summary>
    
      <category term="Spring" scheme="http://wangjunnan.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://wangjunnan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>MVC源码解析-HandlerMapping</title>
    <link href="http://wangjunnan.github.io/2019/08/20/MVC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-HandlerMapping/"/>
    <id>http://wangjunnan.github.io/2019/08/20/MVC源码解析-HandlerMapping/</id>
    <published>2019-08-20T08:07:09.000Z</published>
    <updated>2019-11-08T07:45:51.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>什么是Spring mvc 的 HanderMapping? </strong><br>**<br>我们知道当一个http请求到服务器时，我们需要根据请求的上下文url来匹配到对应的处理类，而HanderMapping做的就是这个事情，它定义了我们的请求和对应的处理类的映射关系。</p><p>Spring mvc提供了多种HanderMapping类型，比较常用的有 <code>RequestMappingHandlerMapping</code>,<code>BeanNameUrlHandlerMapping</code>,<code>SimpleUrlHandlerMapping</code></p><p>以下是这三个HanderMapping的继承结构：<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/149106/1568030225719-c9a755b8-c582-4c6d-8373-b7b078b6ad0b.jpeg#align=left&amp;display=inline&amp;height=528&amp;name=15680101158745.jpg&amp;originHeight=528&amp;originWidth=689&amp;size=67913&amp;status=done&amp;width=689" alt="15680101158745.jpg"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/149106/1568030238662-c338cb95-bf09-4657-bbeb-8dd96897e59f.jpeg#align=left&amp;display=inline&amp;height=624&amp;name=15680196478301.jpg&amp;originHeight=624&amp;originWidth=672&amp;size=70420&amp;status=done&amp;width=672" alt="15680196478301.jpg"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/149106/1568030249196-ed212f57-bff0-47ba-8dd6-f8fc907b3d33.jpeg#align=left&amp;display=inline&amp;height=571&amp;name=15680196756855.jpg&amp;originHeight=571&amp;originWidth=634&amp;size=59515&amp;status=done&amp;width=634" alt="15680196756855.jpg"></p><p>先来看一下这几个HandlerMapping的配置入口，如果是普通Spring Mvc应用的话，当我们在配置文件中配置了<code>annotation-driven</code>后，便会自动帮我们注入这几个类。具体的源码入口在<code>AnnotationDrivenBeanDefinitionParser</code>中，这里的逻辑非常简单，就是帮我们自动注入这几个常用类的<code>BeanDefinition</code>元数据（包括HandlerMapping，handlerAdapter，ExceptionResolver等等）</p><p>下面通过阅读源码依次分别看一下这几个HanderMapping的作用及实现原理</p><h2 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h2><p>我们先来看下 RequestMappingHandlerMapping 的用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestAPI &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/api/sayHello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value = &quot;/api/sayHello2&quot;)</span><br><span class="line">    public String hello2() &#123;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码，这是一个我们非常常用的用法，一个<code>Controller</code>定义多个处理方法，并且在方法上注解RequestMapping，如此做之后就可以实现一个<code>Controller</code>根据不同的路径分别可以处理多个请求。下面我们来看下其实现原理。<br>我比较好奇的是，<code>RequestMappingHandlerMapping</code>是如何将请求路径与处理方法进行初始化映射的？</p><p>通过观察<code>RequestMappingHandlerMapping</code>的继承体系，可以知道其实现了<code>InitializingBean</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">initHandlerMethods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 HandlerMethods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Looking for request mappings in application context: "</span> + getApplicationContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取容器中所有的Bean</span></span><br><span class="line">String[] beanNames = (<span class="keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</span><br><span class="line">BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :</span><br><span class="line">obtainApplicationContext().getBeanNamesForType(Object.class));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// An unresolvable bean type, probably from a lazy bean - let's ignore it.</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Could not resolve target class for bean with name '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断该Bean是否被 @Controller 或则 @RequestMapping 所注解</span></span><br><span class="line"><span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line"><span class="comment">// 初始化 HandlerMethods</span></span><br><span class="line">detectHandlerMethods(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要做了3件事情</p><ol><li>获取容器中所有的Bean</li><li>筛选出被<a href>@Controller </a> 或则 <a href>@RequestMapping </a> 所注解的Bean</li><li>根据筛选出的Bean初始化HandlerMethod</li></ol><p>可以看到这里有一个很重要的类叫做HandlerMethod，我们来看看这个类的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 目标Bean **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; beanType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对应的目标方法 **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method bridgedMethod;</span><br><span class="line"><span class="comment">/** 方法参数类型 **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MethodParameter[] parameters;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HttpStatus responseStatus;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String responseStatusReason;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HandlerMethod resolvedFromHandlerMethod;</span><br><span class="line"></span><br><span class="line">... 还提供了很多方法，像获取方法返回值等等</span><br></pre></td></tr></table></figure><p>对于这个类我们现在可以不用深入去理解，只需知道它封装了处理类的目标方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line">Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line"><span class="comment">// 获取目标Bean中被RequestMapping注解的方法</span></span><br><span class="line">Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">userType.getName() + <span class="string">"]: "</span> + method, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(methods.size() + <span class="string">" request handler methods found on "</span> + userType + <span class="string">": "</span> + methods);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册 HandlerMethod</span></span><br><span class="line">methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要做了两件事情</p><ol><li>获取目前Bean中被RequestMapping注解的方法</li><li>把获取到的Method 封装成HandlerMethod并完成注册</li></ol><p>到这里为止<code>RequestMappingHandlerMapping</code>就完成初始化了，下面再来看下当一个请求来时其实如何处理的，并选择正确的 HandlerMethod 处理的.</p><p><strong>当一个请求进来时，DispatcherServlet会分别调用每个HandlerMapping的getHandler的方法，直到有个HandlerMapping返回了一个hander</strong></p><p><code>getHandler方法</code>在抽象父类<code>AbstractHandlerMapping.class</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 具体调用逻辑，由子类实现</span></span><br><span class="line">Object handler = getHandlerInternal(request);</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">handler = getDefaultHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line"><span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">CorsConfiguration globalConfig = <span class="keyword">this</span>.globalCorsConfigSource.getCorsConfiguration(request);</span><br><span class="line">CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">CorsConfiguration config = (globalConfig != <span class="keyword">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看<code>RequestMappingHandlerMapping</code>的<code>getHandlerInternal</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 根据 request获取到 path</span></span><br><span class="line"><span class="comment">// 如请求是 localhost:8080/api/sayHello</span></span><br><span class="line"><span class="comment">// 则这里返回  /api/sayHello</span></span><br><span class="line">String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Looking up handler method for path "</span> + lookupPath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 获取到请求对应的 handlerMethod </span></span><br><span class="line">HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (handlerMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">logger.debug(<span class="string">"Returning handler method ["</span> + handlerMethod + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">"Did not find handler method for ["</span> + lookupPath + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<code>RequestMappingHandlerMapping</code>在整个MVC流程中所起的作用</p><h2 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h2><p>下面我们再简单看下<code>BeanNameUrlHandlerMapping</code>的使用和原理<br>顾名思义，<code>BeanNameUrlHandlerMapping</code>就是指通过BeanName和Url进行关联匹配，跟<code>RequestMappingHandlerMapping</code>不一样，<code>BeanNameUrlHandlerMapping</code>一个Bean就对应处理一个请求.<br>先来看个使用的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;/test2API&quot;)</span><br><span class="line">public class Test2API implements Controller &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;test2API&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此定义一个类，我们便能通过<code>/test2API</code>这个路径来访问这个类。<br>如何实现的？我们还是打开<code>BeanNameUrlHandlerMapping</code>看看其实现，与<code>RequestMappingHandlerMapping</code>不同的是，它没有实现<code>InitializingBean</code>接口，不过它实现了<code>ApplicationContextAware</code>接口，在Spring容器完成初始化的时候回调用这个唤醒接口，也就是在这里进行了<code>BeanNameUrlHandlerMapping</code>的初始化。</p><p>初始化逻辑在 AbstractDetectingUrlHandlerMapping.detectHandlers() 方法中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected void detectHandlers() throws BeansException &#123;</span><br><span class="line">ApplicationContext applicationContext = obtainApplicationContext();</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Looking for URL mappings in application context: &quot; + applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">String[] beanNames = (this.detectHandlersInAncestorContexts ?</span><br><span class="line">BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :</span><br><span class="line">applicationContext.getBeanNamesForType(Object.class));</span><br><span class="line"></span><br><span class="line">// Take any bean name that we can determine URLs for.</span><br><span class="line">for (String beanName : beanNames) &#123;</span><br><span class="line">// 获取BeanName或别名是 &quot;/&quot; 开头的 Bean名称</span><br><span class="line">String[] urls = determineUrlsForHandler(beanName);</span><br><span class="line">if (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">// URL paths found: Let&apos;s consider it a handler.</span><br><span class="line">// 把获取到的 urls 注册到 handler</span><br><span class="line">registerHandler(urls, beanName);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Rejected bean name &apos;&quot; + beanName + &quot;&apos;: no URL paths identified&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>determineUrlsForHandler</code>是<code>BeanNameUrlHandlerMapping</code>类仅有实现的一个方法，主要逻辑就是获取BeanName或别名是 “/“ 开头的 Bean名称。所以这里也可以知道在上文的使用例子中，BeanName我为何要以斜杠开头。</p><p>当一个请求来时<code>BeanNameUrlHandlerMapping</code>的处理逻辑类似，只不过匹配的容器换成了<code>handlerMap = new LinkedHashMap&lt;&gt;();</code>，匹配逻辑更加的简单直接。</p><h2 id="SimpleUrlHandlerMapping"><a href="#SimpleUrlHandlerMapping" class="headerlink" title="SimpleUrlHandlerMapping"></a>SimpleUrlHandlerMapping</h2><p>最后再看下 SimpleUrlHandlerMapping的用法及实现</p><p>定义一个<code>SimpleUrlHandlerMapping</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title">simpleUrlHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleUrlHandlerMapping simpleUrlHandlerMapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">        Map&lt;String, Object&gt; urlMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        urlMap.put(<span class="string">"/**"</span>, <span class="keyword">new</span> Test2API());</span><br><span class="line">        <span class="comment">// ... 可配置多个映射关系</span></span><br><span class="line">        simpleUrlHandlerMapping.setUrlMap(urlMap);</span><br><span class="line">        simpleUrlHandlerMapping.setOrder(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> simpleUrlHandlerMapping;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上配置会拦截所有的请求，然后转交给 Test2API处理（Test2API可以是Controller接口实现类，也可以是一个 HttpRequestHandler接口实现类），可以看到这里<code>SimpleUrlHandlerMapping</code>起的作用非常像一个拦截器起的作用，其实也确实是这样，像对静态资源的拦截就可以采用<code>SimpleUrlHandlerMapping</code>来实现。</p><p>具体实现其实跟上文的两种mapping实现类似，简单看下源码</p><p>初始注册逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.initApplicationContext();</span><br><span class="line">registerHandlers(<span class="keyword">this</span>.urlMap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlers</span><span class="params">(Map&lt;String, Object&gt; urlMap)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (urlMap.isEmpty()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Neither 'urlMap' nor 'mappings' set on SimpleUrlHandlerMapping"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">urlMap.forEach((url, handler) -&gt; &#123;</span><br><span class="line"><span class="comment">// 确保路径是以斜杠开头的</span></span><br><span class="line"><span class="keyword">if</span> (!url.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">url = <span class="string">"/"</span> + url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 去除空格</span></span><br><span class="line"><span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">handler = ((String) handler).trim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">registerHandler(url, handler);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑还是比较简单的，就是将我们手动配置的多个映射关系进行初始注册，以备后面逻辑使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说HanderMapping的职责是非常清晰的，就是存储并匹配请求url和处理类的映射关系。整个处理流程的源码相对来说也比较直观，易阅读。读完其源码对MVC的url匹配流程会有更加深刻的认识</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;什么是Spring mvc 的 HanderMapping? &lt;/strong&gt;&lt;br&gt;**&lt;br&gt;我们知道当一个http请
      
    
    </summary>
    
      <category term="Spring" scheme="http://wangjunnan.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://wangjunnan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务在积分商城里的应用</title>
    <link href="http://wangjunnan.github.io/2019/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%9C%A8%E7%A7%AF%E5%88%86%E5%95%86%E5%9F%8E%E9%87%8C%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://wangjunnan.github.io/2019/07/10/分布式事务在积分商城里的应用/</id>
    <published>2019-07-10T08:56:22.000Z</published>
    <updated>2019-11-08T07:45:51.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近在做会员体系的时候，涉及到了积分商城订单体系，既然设计到订单体系，因为现在的项目架构体系基本都是微服务分布式的，所以必然会涉及到分布式事务。事务问题在早些时候都是单机部署的时代依靠数据库本身提供的事务机制非常容易解决，但是一旦设计到分布式，各个独立的服务是无法感知其他事务执行状态的，所以我们需要借助一些其他手段来保证分布式事务</p><h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><ul><li><p>CAP</p><ul><li>C（一致性）一致性是指数据的原子性，在经典的数据库中通过事务来保障，事务完成时，无论成功或回滚，数据都会处于一致的状态，在分布式环境下，一致性是指多个节点数据是否一致；</li><li>A（可用性）服务一直保持可用的状态，当用户发出一个请求，服务能在一定的时间内返回结果；</li><li>P（分区容错性）机器故障、网络故障、机房停电等异常情况下仍然能够满足一致性和可用性，分布式应用一般都满足分区容错性<br>分布式事务我们要解决的就是数据的一致性问题</li></ul></li><li><p>一致性模型</p><ul><li>基本可用（Basically Available）</li><li>软状态（Soft State）</li><li><p>最终一致性（Eventually Consistent）</p><p>其中最终一致性又可分为：会话一致性 单调一致性等等</p></li></ul></li></ul><h2 id="2PC-Two-Three-Phase-Commit"><a href="#2PC-Two-Three-Phase-Commit" class="headerlink" title="2PC (Two/Three Phase Commit)"></a>2PC (Two/Three Phase Commit)</h2><p>2PC 我们又把它叫做两阶段提交，在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写入磁盘等等）。因此，二阶段提交的算法思路可以概括为： 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>二阶段提交算法的成立基于以下假设：</p><ol><li>该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Participants)。且节点之间可以进行网络通信。</li><li>所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li></ol><h3 id="第一阶段-提交请求阶段"><a href="#第一阶段-提交请求阶段" class="headerlink" title="第一阶段(提交请求阶段)"></a>第一阶段(提交请求阶段)</h3><ol><li>协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。</li><li>参与者节点执行询问发起为止的所有事务操作，并将<code>Undo</code>信息和<code>Redo</code>信息写入日志。</li><li>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li></ol><p>有时候，第一阶段也被称作投票阶段，即各参与者投票是否要继续接下来的提交操作。</p><h3 id="第二阶段-提交执行阶段"><a href="#第二阶段-提交执行阶段" class="headerlink" title="第二阶段(提交执行阶段)"></a>第二阶段(提交执行阶段)</h3><ul><li>成功<br>  当协调者节点从所有参与者节点获得的相应消息都为”同意”时：<ol><li>协调者节点向所有参与者节点发出”正式提交”的请求。</li><li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”完成”消息。</li><li>协调者节点收到所有参与者节点反馈的”完成”消息后，完成事务。</li></ol></li><li>失败<br>  如果任一参与者节点在第一阶段返回的响应消息为”终止”，或者 协调者节点在第一阶段的询问超    时之前无法获取所有参与者节点的响应消息时：<ol><li>协调者节点向所有参与者节点发出”回滚操作”的请求。</li><li>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”回滚完成”消息。</li><li>协调者节点收到所有参与者节点反馈的”回滚完成”消息后，取消事务。</li></ol></li></ul><p>有时候，第二阶段也被称作完成阶段，因为无论结果怎样，协调者都必须在此阶段结束当前事务</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>二阶段提交算法的最大缺点就在于: <strong>它的执行过程中间，节点都处于阻塞状态</strong>。即节点之间在等待对方的响应消息时，它将什么也做不了。特别是，当一个节点在已经占有了某项资源的情况下，为了等待其他节点的响应消息而陷入阻塞状态时，当第三个节点尝试访问该节点占有的资源时，这个节点也将连带陷入阻塞状态。</p><h2 id="TCC-补偿型"><a href="#TCC-补偿型" class="headerlink" title="TCC 补偿型"></a>TCC 补偿型</h2><p>上面大篇幅的介绍了2PC提交，但实际的应用中我们基本都不会使用这种方案，原因在上面的缺点中已经说明了，2PC这种传统的分布式事务解决方案性能实在是太差了，在互联网大并发的背景下显然是不行的，这就引申出了TCC补偿性分布式事务解决方案</p><p>TCC是(<code>Try-Confirm-Cancel</code>)的简称，从名字我们知道TCC有三个阶段</p><ol><li>Try<br>Try阶段主要做资源的预留，锁定操作</li><li>Confirm<br>如果Try预留资源成功，则执行Confirm操作，对资源做最终的提交</li><li>Cancel<br>如果Try预留资源失败，则执行Cancel取消对资源的锁定</li></ol><p>通过上文的描述，可以发现TCC与2PC非常相似，但实际上两者在解决分布式事务的层面上不一样的，2PC主要还是借助数据库层面的事务来协调解决，相对于数据库事务的<code>rollback</code>，TCC在逻辑层面的Cancel操作，代价要小的多。并且TCC事务引入了中间状态（也就是资源的锁定），只要全部资源都锁定成功，我们就认为最终是执行成功的（最终一致性）</p><p>下图是积分下单用TCC事务解决的典型场景<br><img src="http://img.souche.com/f2e/d6344431308a0bf0524dee25a67a7ed4.jpg" alt></p><h3 id="TCC是如何解决最终一致性的？"><a href="#TCC是如何解决最终一致性的？" class="headerlink" title="TCC是如何解决最终一致性的？"></a>TCC是如何解决最终一致性的？</h3><p>当我们在<code>Try</code>阶段预留资源成功的话，那么我们就认为最终这个事务是肯定可以完成的，即使因为某些原因(数据库down了等的)<code>Confirm</code>执行失败，TCC事务框架会不停的重试调用它的<code>Confirm</code>逻辑，务必会保证其最终一致性</p><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>订单系统</p><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>事务消息的应用场景是，事务参与方的资源已经锁定，只需要保持最终一致性的场景。比较典型的实例是银行转账，当A账户完成账户扣减后，B账户不需要锁定账户，只需要保证最终B账户可以增加指定金额</p><p><img src="http://img.souche.com/f2e/43a4b89a08f32771eb7815782d749a8a.jpg" alt></p><h3 id="为何需要先发送-Prepare消息？"><a href="#为何需要先发送-Prepare消息？" class="headerlink" title="为何需要先发送 Prepare消息？"></a>为何需要先发送 Prepare消息？</h3><p>试想一种场景，本地事务执行成功，准备发送消息的时候断网了，这时候就会造成数据不一致的情况</p><h3 id="commit-or-rollback-消息发送失败？"><a href="#commit-or-rollback-消息发送失败？" class="headerlink" title="commit or rollback 消息发送失败？"></a>commit or rollback 消息发送失败？</h3><p>这时候需要消息中间件提供消息回查功能，也就是当间隔一段时间之后，Prepare消息没有收到 commit or rollback消息，需要发起消息回查，并且由业务方判断最终消息是否需要投递</p><p>对于事务消息的解决方案，阿里的<code>RocketMq</code>也提供了解决方案<br><img src="http://img.souche.com/f2e/1ec3ad72a09958fad49b6cbfb08949db.jpg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，每种分布式事务解决方案都有其应用场景，但目前业界比较主流的还是TCC和事务消息，TCC事务需要业务实现<code>Try-Confirm-Cancel</code>逻辑，需要在Try阶段提前锁定资源，相对于事务消息来说成本较高，但是事务消息的适用场景也是有限的，如下单扣减库存这个场景因为需要提前锁定库存，事务消息就不适用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;最近在做会员体系的时候，涉及到了积分商城订单体系，既然设计到订单体系，因为现在的项目架构体系基本都是微服务分布式的，所以必然会涉及到分布式事
      
    
    </summary>
    
      <category term="分布式" scheme="http://wangjunnan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://wangjunnan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="事务" scheme="http://wangjunnan.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>git 你真的会用吗</title>
    <link href="http://wangjunnan.github.io/2019/06/21/git-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E5%90%97/"/>
    <id>http://wangjunnan.github.io/2019/06/21/git-你真的会用吗/</id>
    <published>2019-06-21T02:26:10.000Z</published>
    <updated>2019-11-08T07:45:51.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录原由"><a href="#记录原由" class="headerlink" title="记录原由"></a>记录原由</h2><p>最近因为公司新来的同事，在使用<code>Git</code>时犯了一些非常低级的错误，导致团队为了解决这些问题浪费了很多时间。究其原因其实还是对于<code>Git</code>内部实现不清晰，仅仅知道敲几个git命令，但是却不知道敲了这个命令<code>Git</code>会发生什么！这里根据<a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">git官方文档</a>节选了一些重要概念分享出来。</p><h2 id="几个重要概念"><a href="#几个重要概念" class="headerlink" title="几个重要概念"></a>几个重要概念</h2><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><ol><li>工作区状态<ul><li>就是修改了文件还没有做 <code>git add</code>的文件状态</li></ul></li><li>暂存区状态<ul><li>已经<code>git add</code>但还未<code>git commit</code>的文件状态</li></ul></li><li>已提交状态<ul><li>已经<code>git commit</code>的文件状态，也就是真正存储到<code>git</code>仓库</li></ul></li></ol><h3 id="Branch指针和HEAD指针"><a href="#Branch指针和HEAD指针" class="headerlink" title="Branch指针和HEAD指针"></a>Branch指针和HEAD指针</h3><p><code>Git</code>的分支特性是其最强大最独特的功能，也正是因为这个特性让<code>git</code>得以在众多的版本控制系统中脱颖而出，在理解<code>branch</code>之前，有必要先对<code>git commit</code>命令做一个简单的介绍</p><ul><li>当使用<code>git commit</code>进行提交操作时，<code>Git</code>便会创建一个提交对象，这个对象会包含一个指向本次提交的指针，指针指向本次<code>commit</code>的快照。指针也就是我们通常所说的<code>commit id(长度为 40 的 SHA-1 值字符串)</code>。如此一来，<code>Git</code>就可以在需要的时候根据<code>commit id</code>来回退版本</li></ul><p><code>Branch</code>的本质其实仅仅是指向提交对象的<strong>某一个可变指针</strong>。所以根据这个概念，我们可以知道<code>master</code>并不是一个特殊的分支，他跟我们众多自定义的分支没有任何不同，唯一区别是它是<code>Git</code>的默认分支(初始化的时候总得有一个默认分支)</p><p>下面的图是单个<code>master</code>分支时的结构，这里<code>master</code>仅仅是一个指向<code>f30ab</code>提交对象的指针</p><p><img src="http://img.souche.com/f2e/037ab2a225f8b9457af9a40324313f84.jpg" alt></p><p>执行 <code>$ git branch testing</code>创建一个 <code>testing</code>分支，会在当前所在的提交对象上创建一个名为<code>testing</code>的指针，也就是<code>testing</code>分支<br><img src="http://img.souche.com/f2e/0efbc0ed98b12c7aadfe4a97d82d2315.jpg" alt></p><p>注意：此时两个指针指向了相同的提交<br>那么<code>Git</code>是如何来知道当前处于哪个分支的呢？<br>这就引出了<code>Git</code>中的另一个特殊的指针<code>HEAD</code>，<code>HEAD</code>用来指向当前所在的分支，也就是一个用来指向分支指针的指针（有点拗口），就像下图这样，当前是在<code>master</code>分支，因为<code>git branch</code>并不会移动<code>HEAD</code>指针切换分支</p><p><img src="http://img.souche.com/f2e/bc84a1c0611edbcf64756ad321f0d84c.jpg" alt></p><p>执行 <code>$ git checkout testing</code>命令才会将<code>HEAD</code>指针指向<code>testing</code>分支<br><img src="http://img.souche.com/f2e/d09338fd78877491ec49f7fcb191a491.jpg" alt></p><p>当我们在<code>testing</code>分支上继续提交几个commit之后，<code>testing</code>指针和<code>HEAD</code>指针都会跟着向前移动，但是<code>master</code>指针并不会移动，依旧指向<code>f30ab</code>这个提交<br><img src="http://img.souche.com/f2e/8b8a8539aa7dc810a9a9f371f8751bc3.jpg" alt></p><p>现在执行<code>git checkout master</code>切回<code>master</code>分支，<code>HEAD</code>指针会重新指向<code>master</code>，也就是说现在又回到了一个旧的版本，这也是<code>Git</code>的神奇之处<br><img src="http://img.souche.com/f2e/a172111db3abe0d8c6f82c7b3a99607f.jpg" alt></p><p>接下来我们在<code>master</code>分支上做一些修改，提交一个commit，<code>HEAD</code>和<code>master</code>指针会继续向前移动，并且这个项目的提交（快照版本）已经产生了分叉<br><img src="http://img.souche.com/f2e/237c20e005bac4135577ffd143eeb033.jpg" alt></p><blockquote><p>保存分支信息的目录在<code>.git/refs/heads</code>下，也可以在这个目录下查看或修改分支指针</p></blockquote><h2 id="merge-命令"><a href="#merge-命令" class="headerlink" title="merge 命令"></a>merge 命令</h2><p>在上文的例子中，项目有两个分支，且已经产生了分叉，这时候需要把<code>testing</code>分支上的内容合并至<code>master</code>时需要用到<code>merge</code>命令<br>在<code>master</code>执行<code>git merge testing</code>，会生成一个新的提交<code>9c67a</code>，并且<code>HEAD</code>和<code>master</code>指针继续向前移动</p><p><img src="http://img.souche.com/f2e/0c40f40917743bcc75b4871ad7a76bf8.jpg" alt></p><h2 id="reset-命令"><a href="#reset-命令" class="headerlink" title="reset 命令"></a>reset 命令</h2><p>假如上面的<code>merge</code>操作有问题，需要撤销，可以使用<code>reset</code>命令，但首先需要明确回退的版本是哪一个，例如要回退的版本是<code>c2b9e</code>，执行<code>git reset --hard c2b9e</code>后，<code>HEAD</code>和<code>master</code>指针会回退到版本<code>c2b9e</code></p><p><img src="http://img.souche.com/f2e/cfd70efa478ee439cc8db564681b22c2.jpg" alt></p><h2 id="…"><a href="#…" class="headerlink" title="…"></a>…</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记录原由&quot;&gt;&lt;a href=&quot;#记录原由&quot; class=&quot;headerlink&quot; title=&quot;记录原由&quot;&gt;&lt;/a&gt;记录原由&lt;/h2&gt;&lt;p&gt;最近因为公司新来的同事，在使用&lt;code&gt;Git&lt;/code&gt;时犯了一些非常低级的错误，导致团队为了解决这些问题浪费了很多时
      
    
    </summary>
    
      <category term="git" scheme="http://wangjunnan.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://wangjunnan.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 泛型 你真的理解了吗？</title>
    <link href="http://wangjunnan.github.io/2019/06/19/JAVA-%E6%B3%9B%E5%9E%8B-%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E4%BA%86%E5%90%97%EF%BC%9F/"/>
    <id>http://wangjunnan.github.io/2019/06/19/JAVA-泛型-你真的理解了吗？/</id>
    <published>2019-06-19T08:16:53.000Z</published>
    <updated>2019-11-08T07:45:51.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录原由"><a href="#记录原由" class="headerlink" title="记录原由"></a>记录原由</h2><p>之前虽然泛型一直在使用，但使用的过程中总是没有那么得心应手，有些细节还是过于模糊。究其原因其实是一直都没有系统深入的去理解过，最近花了一点时间去深入的理解了一下java的泛型机制，也希望借这次记录能够彻底的理解java的泛型</p><h2 id="为什么要有泛型"><a href="#为什么要有泛型" class="headerlink" title="为什么要有泛型"></a>为什么要有泛型</h2><p><strong>泛型的本质是把 类型参数化</strong>，什么是类型参数化？举个例子，我们常用的集合类，要是没有类型参数化的话，我们就得实现装不同类型的集合类，会大大降低代码的可重用性！</p><p>例如我们要设计一个装苹果的盘子和一个装香蕉的盘子，要怎么设计呢？非常简单，最简单的方式就是设计两个盘子类，一个是苹果盘子，一个香蕉盘子，就像下面的代码一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplePlant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Apple apple;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Apple <span class="title">getApple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApple</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.apple = apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BananaPlant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Banana banana;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Banana <span class="title">getBanana</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> banana;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBanana</span><span class="params">(Banana banana)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.banana = banana;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码的确能够满足我们的需求，但就像上文所说的，这样的代码降低了代码的可重用性，那么我们要怎么优化呢，聪明的程序员们马上想到了，可以用<code>Object</code>来代替盘子里所指代的具体类型，就像下面这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectPlant</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObject</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看似完美解决了代码不可重用的问题，但同时也隐含了很多其他问题，例如在我们取数据的时候，取出来的只能是<code>Object</code>类型，需要我们强转类型，而往盘子中加入数据的时候，也没有任何验证，有可能往放苹果的盘子中加入了香蕉也说不定，因为编译器并没有做任何限制，只要是<code>Object</code>类型，都可以验证通过。</p><p>上面的问题在Java 1.5引入了泛型之后得到了完美的解决，下面让我们来看看用泛型如何优雅的解决上述问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plant</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个泛型类，它表示了一个可以<code>T</code>类型的篮子，而这个<code>T</code>类型需要到我们真正使用的时候才会去指定</p><p>例如现在我们要定义两种盘子，可以这样声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plant&lt;Apple&gt; applePlant = <span class="keyword">new</span> Plant&lt;&gt;();</span><br><span class="line">Plant&lt;Banana&gt; bananaPlant = <span class="keyword">new</span> Plant&lt;&gt;();</span><br><span class="line">Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">Banana banana = <span class="keyword">new</span> Banana();</span><br><span class="line">applePlant.set(banana); <span class="comment">// 编译报错</span></span><br><span class="line">bananaPlant.set(apple); <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><p>上面的代码之所以实际类型<code>new Plant&lt;&gt;()</code>的<code>&lt;&gt;</code>中没有指明具体类型，是因为Java7之后加了类型自动推断，也就不需要两侧都加上泛型类型</p><p>可以看到使用了泛型之后，既提高了代码的可重用性，在实际使用时也对类型进行了约束，装苹果的盘子是装不了香蕉的！</p><p>不过要注意的是，java的泛型约束是在编译时生效的，一旦编译成了class字节码文件后，一切都打回原形了，泛型信息会被擦除，所以我们把<code>JAVA</code>的泛型称为伪泛型，跟<code>C#</code>等语言的真泛型有着本质区别，在<code>C#</code>中，<code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code> 就是两种不同的类型</p><p>如下面字节码文件的最后一行<code>invokevirtual</code>命令的方法描述符<code>Method setT:(Ljava/lang/Object;)V</code>，可知泛型类型已经被擦除成了<code>Object</code>类型，也就是在字节码层面实际上与我们直接用<code>Object</code>来实现是一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: new           #3                  // class com/sunshine/common/test/Plant</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #4                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: aload_1</span><br><span class="line">         9: new           #5                  // class com/sunshine/common/test/Apple</span><br><span class="line">        12: dup</span><br><span class="line">        13: invokespecial #6                  // Method com/sunshine/common/test/Apple.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        16: invokevirtual #7                  // Method setT:(Ljava/lang/Object;)V</span><br></pre></td></tr></table></figure><h2 id="泛型进阶"><a href="#泛型进阶" class="headerlink" title="泛型进阶"></a>泛型进阶</h2><h3 id="使用-lt-T-extends-gt-定义泛型类"><a href="#使用-lt-T-extends-gt-定义泛型类" class="headerlink" title="使用 &lt;T extends ?&gt; 定义泛型类"></a>使用 <code>&lt;T extends ?&gt;</code> 定义泛型类</h3><p>头一次看到上面两个符号，是不是有点懵逼？它们在代码里也非常常见，那么它们究竟是表示什么意思呢？<br>还是通过上文的<code>plant</code>盘子来举例吧，举一种情况，我们只希望这个盘子用来装一些水果，而不希望它被用来装肉，那么我们该怎么做呢？<br>现在的情况是，它既可以实例化成一个装香蕉的盘子，也可以被实例化成一个装肉的盘子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plant&lt;Apple&gt; applePlant = <span class="keyword">new</span> Plant&lt;&gt;(); <span class="comment">// </span></span><br><span class="line">Plant&lt;Meat&gt; meatPlant = <span class="keyword">new</span> Plant&lt;&gt;(); <span class="comment">// 都是Ok的</span></span><br></pre></td></tr></table></figure><p>现在让我们来重新设计一个盘子类，通过<code>&lt;T extends Firut&gt;</code>来限制泛型，其实如果我们直接用<code>&lt;T&gt;</code>的编译成字节码后也会自动编译成<code>&lt;T extends Object&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirutPlant</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Firut</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FirutPlant&lt;Apple&gt; appleFirutPlant = <span class="keyword">new</span> FirutPlant&lt;&gt;(); <span class="comment">// OK</span></span><br><span class="line">FirutPlant&lt;Firut&gt; firutPlant = <span class="keyword">new</span> FirutPlant&lt;&gt;(); <span class="comment">// OK</span></span><br><span class="line">FirutPlant&lt;Meat&gt; meatFirutPlant = <span class="keyword">new</span> FirutPlant&lt;&gt;(); <span class="comment">// 编译无法通过</span></span><br></pre></td></tr></table></figure><p>通过上面的代码可知我们成功的限制了泛型，水果盘子就只能装水果，盘子中的类型只能是水果或则它的子类型。</p><h3 id="lt-extends-T-gt-lt-super-T-gt"><a href="#lt-extends-T-gt-lt-super-T-gt" class="headerlink" title="&lt;? extends T&gt; &lt;? super T&gt;"></a><code>&lt;? extends T&gt; &lt;? super T&gt;</code></h3><p>注意这里的T是泛型参数，跟上面的<t extends ?> T不一样</t></p><p>看完上面的 <code>&lt;T extends ?&gt;</code>，接下来我们再来看<code>&lt;? extends T&gt; &lt;? super T&gt;</code>，可能这里你会非常疑惑，哇 这两个有什么区别？其实简单理解的话，<code>&lt;T extends ?&gt;</code>是在类文件层面就限制了泛型的范围，而<code>&lt;? extends T&gt; &lt;? super T&gt;</code>是在使用泛型的时候再去做限制。明白了这个之后接下来我们就来看下<code>&lt;? extends T&gt; &lt;? super T&gt;</code>的使用。</p><p>让我们回到<code>Firut.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plant</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在不在定义泛型类的时候做限制，(使用<code>&lt;T&gt;</code>，其实这里还是相当于<code>&lt;T extends Object&gt;</code>)，而是在使用的是去做限制</p><p>下面我们来看下<code>&lt;? extends T&gt;</code>的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Plant&lt;Apple&gt; applePlant = new Plant&lt;Apple&gt;();</span><br><span class="line">applePlant.setT(new Apple());</span><br><span class="line">// 使用 &lt;? extends T&gt;</span><br><span class="line">Plant&lt;? extends Firut&gt; plant = applePlant;</span><br><span class="line"></span><br><span class="line">plant.setT(new Apple()); // 无法存 编译报错</span><br><span class="line">plant.setT(new Firut()); // 无法存 编译报错</span><br><span class="line">Firut apple = plant.getT(); // 可以获取</span><br></pre></td></tr></table></figure><p>可以看到当<code>&lt;? extends T&gt;</code>做为接收参数时，因为其必然是<code>Firut</code>的子类，这里实例类型是<code>Apple</code>，所以<code>getT()</code>方法仍然可以使用，因为会进行一次隐式的类型转换（向上转型是安全的），但是<code>setT()</code>方法是失效的，这是因为编译器不能确定你一定会往里面添加<code>Apple</code>类型，因为你还可以往里面添加<code>Banana</code>类型，显然<code>Banana</code>类型无法强转<code>Apple</code>类型，所以这里的<code>setT()</code>方法是失效的</p><p>下面我们来看下<code>&lt;? super T&gt;</code>的使用<br>有了上面<code>&lt;? extends T&gt;</code>的使用经验，顾明思议，<code>&lt;? super T&gt;</code>必然表示<code>T</code>的全部父类型，还是再来看下<code>&lt;? super T&gt;</code>的使用吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Plant&lt;Firut&gt; firutPlant = <span class="keyword">new</span> Plant&lt;&gt;();</span><br><span class="line">Plant&lt;? <span class="keyword">super</span> Apple&gt; plant = firutPlant;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plant.setT(<span class="keyword">new</span> Apple()); <span class="comment">// 可以存成功，不过这里只能存 Apple类型</span></span><br><span class="line">Apple apple = plant.getT(); <span class="comment">// 编译报错</span></span><br><span class="line"></span><br><span class="line">Firut firut = firutPlant.getT();</span><br></pre></td></tr></table></figure><p>上面可以存成功的原因和上面<code>&lt;? extends T&gt;</code>可以取成功的原因一样，也是因为存在一个隐式的向上转型，而获取失败的原因 也很容易理解，因为实际类型肯定是<code>Apple</code>的父类（这里是Firut），所以要将<code>Firut</code>转成<code>Apple</code>显然是不可行的！</p><h3 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;?&gt;"></a>&lt;?&gt;</h3><p><code>&lt;?&gt;</code>其实等价与<code>&lt;? extends Object&gt;</code>，这样子我相信就比较好理解了，跟<code>&lt;? extends T&gt;</code>类似，也是取可以，存被限制</p><p><code>&lt;T&gt;</code>一般都是在定义泛型类或则泛型方法时出现，实际使用时都以<code>?</code>或具体类型替代<code>T</code></p><h3 id="Type-与-Class-的区别和联系"><a href="#Type-与-Class-的区别和联系" class="headerlink" title="Type 与 Class 的区别和联系"></a>Type 与 Class 的区别和联系</h3><p>说起泛型，不得不提JDK在1.5之后引入的<code>Type</code>类型，显然<code>Type</code>是<code>Java</code>为了实现泛型而引入的。那么<code>Type</code>到底是什么呢，它表示的范围有多大？<br>其实我们可以直接理解把<code>Class</code>当成是<code>Type</code>的子集，<code>Class</code>对应着jdk1.5之前不是泛型的原始类型</p><p><code>Type</code>下包含了几种不同的类型</p><ul><li><code>Class</code> 原始类型，我这里直接理解成我们常用的<code>Class</code>类型，<code>Class</code>是<code>Type</code>的直接子类</li><li><code>ParameterizedType</code> 参数化类型类似 <code>List&lt;String&gt; list</code> 获取list的类型</li><li><code>TypeVariable</code> 类似 <code>T t</code></li><li><code>GenericArrayType</code> 类似 <code>List&lt;String&gt;[]</code> 或则 <code>List&lt;T&gt; []</code><ul><li><code>GenericArrayType</code> 接口只有一个方法<code>getGenericComponentType</code>，用户返回<code>ParameterizedType</code>或则<code>TypeVariable</code>类型</li></ul></li><li><code>WildcardType</code> 类似 <code>&lt;? super T&gt;</code> 要得到这个类型，首先需要得到<code>ParameterizedType</code>类型，然后通过<code>getActualTypeArguments</code>方法获取<code>WildcardType</code>类型</li></ul><p>说了这么多，还是通过实际的代码来详细解释吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOne</span><span class="params">(Plant&lt;Apple&gt; plant, </span></span></span><br><span class="line"><span class="function"><span class="params">                        Plant&lt;Apple&gt; [] plants, </span></span></span><br><span class="line"><span class="function"><span class="params">                        Plant&lt;? extends Apple&gt; applePlant)</span> </span>&#123;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">testOne</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写段测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Method [] methods = TypeTest.class.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getName().equals(<span class="string">"testOne"</span>)) &#123;</span><br><span class="line">        Type [] parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        System.out.println(<span class="string">"methodOne start --------&gt; "</span>);</span><br><span class="line">        <span class="keyword">for</span> (Type type : parameterTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Class ---- "</span> + type.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                System.out.println(<span class="string">"ParameterizedType ---- "</span> + type.getTypeName());</span><br><span class="line">                Type ytpe3[] = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type type2 : ytpe3) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (type2 <span class="keyword">instanceof</span> WildcardType) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"ParameterizedType-WildcardType  ---- "</span> + type2.getTypeName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">                System.out.println(<span class="string">"GenericArrayType ---- "</span> + type.getTypeName());</span><br><span class="line">                Type type2 = ((GenericArrayType) type).getGenericComponentType();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">                System.out.println(<span class="string">"TypeVariable ---- "</span> + type.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">"testTwo"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        Type [] parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        System.out.println(<span class="string">"methodTwo start --------&gt; "</span>);</span><br><span class="line">        <span class="keyword">for</span> (Type type : parameterTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">                System.out.println(<span class="string">"TypeVariable ---- "</span> + type.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methodTwo start --------&gt; </span><br><span class="line">TypeVariable ---- T</span><br><span class="line">methodOne start --------&gt; </span><br><span class="line">ParameterizedType ---- com.sunshine.common.test.Plant&lt;com.sunshine.common.test.Apple&gt;</span><br><span class="line">GenericArrayType ---- com.sunshine.common.test.Plant&lt;com.sunshine.common.test.Apple&gt;[]</span><br><span class="line">ParameterizedType ---- com.sunshine.common.test.Plant&lt;? extends com.sunshine.common.test.Apple&gt;</span><br><span class="line">ParameterizedType-WildcardType  ---- ? extends com.sunshine.common.test.Apple</span><br></pre></td></tr></table></figure><h2 id="什么情况可以拿到泛型类型"><a href="#什么情况可以拿到泛型类型" class="headerlink" title="什么情况可以拿到泛型类型"></a>什么情况可以拿到泛型类型</h2><p>先看可以拿到泛型的情形，与上面的例子一样，我们可以获取方法入参，超类的参数化类型，举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperPlant</span> <span class="title">extend</span> <span class="title">Plant</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;Apple&gt; apples)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取父类参数化类型</span></span><br><span class="line">    Type type = SuperPlant.class.getGenericSuperclass();</span><br><span class="line">    Method[] methods = SuperPlant.class.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">// 获取方法参数化类型</span></span><br><span class="line">            Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现以上代码是可以获取到泛型类型。通过<code>getGenericSuperclass</code>获取到父类的参数化类型，method的<code>getGenericParameterTypes</code>获取到入参的参数化类型数组。</p><p>再看一种情况<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Plant&lt;Firut&gt; firutPlant = <span class="keyword">new</span> Plant&lt;&gt;();</span><br><span class="line">  <span class="comment">// 这里可以拿到 firutPlant 对象的泛型吗?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子中，我们是拿不到 firutPlant 的泛型的，因为JAVA 在将其编译成字节码的时候，实际上会变成 <code>Plant&lt;Object&gt;</code>类型，泛型会被擦除。</p><p><strong>所以我们其实是无法在运行时通过泛型对象本身拿到泛型类型的，那么有没有黑科技可以拿到运行时泛型本身的泛型信息？上面有提到，我们拿泛型可以通过子类来获取父类的泛型</strong><br>我们依据这个思路将上面例子修改一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Type type = <span class="keyword">new</span> Plant&lt;Firut&gt;() &#123;&#125;.getClass().getGenericSuperclass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是将Plant改成了匿名类方式实现，这种方式可以拿到Plant的泛型信息吗？答案是可以的<br>这里通过<code>getGenericSuperclass</code>拿到的就是Plant<firut> 的泛型类型信息。其实这种方式在很多框架源码里很常见，通过匿名类方式获取参数类型，感兴趣的可以看下<code>Gson</code>的<code>TypeToken</code>的实现，也是一样的原理。</firut></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记录原由&quot;&gt;&lt;a href=&quot;#记录原由&quot; class=&quot;headerlink&quot; title=&quot;记录原由&quot;&gt;&lt;/a&gt;记录原由&lt;/h2&gt;&lt;p&gt;之前虽然泛型一直在使用，但使用的过程中总是没有那么得心应手，有些细节还是过于模糊。究其原因其实是一直都没有系统深入的去理解过
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://wangjunnan.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码方法表</title>
    <link href="http://wangjunnan.github.io/2019/04/25/Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8/"/>
    <id>http://wangjunnan.github.io/2019/04/25/Java字节码方法表/</id>
    <published>2019-04-25T07:50:02.000Z</published>
    <updated>2019-11-08T07:45:51.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>因为字段表和方法表的结构类似，所以我们直接分析Java字节码的方法表内容，理解了方法表，自然就理解了字段表</p><h2 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h2><p>方法表在<code>Class</code>文件中的位置是在字段表之后的，具体的结构我们根据下表再来回顾一下</p><table><thead><tr><th>类型</th><th>名称</th><th>数量 </th></tr></thead><tbody><tr><td>u2</td><td>access_flas</td><td>1 </td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>属性表</td><td>attributes_count</td></tr></tbody></table><p>还是跟上篇文章一样，我们写一个简单的Java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> String sayStr = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> sayStr;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"> System.out.println(test.sayHello());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>javap</code>翻译字节码文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class com.ymm.agent.Test</span><br><span class="line"></span><br><span class="line"> minor version: 0</span><br><span class="line"></span><br><span class="line"> major version: 52</span><br><span class="line"></span><br><span class="line"> flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line"></span><br><span class="line"> this_class: #3 // com/ymm/agent/Test</span><br><span class="line"></span><br><span class="line"> super_class: #8  // java/lang/Object</span><br><span class="line"></span><br><span class="line"> interfaces: 0, fields: 0, methods: 3, attributes: 1</span><br><span class="line"></span><br><span class="line">Constant pool:</span><br><span class="line"></span><br><span class="line"> #1 = Methodref #8.#27  // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line"> #2 = String  #28 // hello world</span><br><span class="line"></span><br><span class="line"> #3 = Class #29 // com/ymm/agent/Test</span><br><span class="line"></span><br><span class="line"> #4 = Methodref #3.#27  // com/ymm/agent/Test.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line"> #5 = Fieldref  #30.#31 // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line"> #6 = Methodref #3.#32  // com/ymm/agent/Test.sayHello:()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> #7 = Methodref #33.#34 // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"> #8 = Class #35 // java/lang/Object</span><br><span class="line"></span><br><span class="line"> #9 = Utf8  &lt;init&gt;</span><br><span class="line"></span><br><span class="line"> #10 = Utf8  ()V</span><br><span class="line"></span><br><span class="line"> #11 = Utf8  Code</span><br><span class="line"></span><br><span class="line"> #12 = Utf8  LineNumberTable</span><br><span class="line"></span><br><span class="line"> #13 = Utf8  LocalVariableTable</span><br><span class="line"></span><br><span class="line"> #14 = Utf8  this</span><br><span class="line"></span><br><span class="line"> #15 = Utf8  Lcom/ymm/agent/Test;</span><br><span class="line"></span><br><span class="line"> #16 = Utf8  sayHello</span><br><span class="line"></span><br><span class="line"> #17 = Utf8  ()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> #18 = Utf8  sayStr</span><br><span class="line"></span><br><span class="line"> #19 = Utf8  Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> #20 = Utf8  main</span><br><span class="line"></span><br><span class="line"> #21 = Utf8  ([Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"> #22 = Utf8  args</span><br><span class="line"></span><br><span class="line"> #23 = Utf8  [Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> #24 = Utf8  test</span><br><span class="line"></span><br><span class="line"> #25 = Utf8  SourceFile</span><br><span class="line"></span><br><span class="line"> #26 = Utf8  Test.java</span><br><span class="line"></span><br><span class="line"> #27 = NameAndType #9:#10  // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line"> #28 = Utf8  hello world</span><br><span class="line"></span><br><span class="line"> #29 = Utf8  com/ymm/agent/Test</span><br><span class="line"></span><br><span class="line"> #30 = Class #36 // java/lang/System</span><br><span class="line"></span><br><span class="line"> #31 = NameAndType #37:#38 // out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line"> #32 = NameAndType #16:#17 // sayHello:()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> #33 = Class #39 // java/io/PrintStream</span><br><span class="line"></span><br><span class="line"> #34 = NameAndType #40:#41 // println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"> #35 = Utf8  java/lang/Object</span><br><span class="line"></span><br><span class="line"> #36 = Utf8  java/lang/System</span><br><span class="line"></span><br><span class="line"> #37 = Utf8  out</span><br><span class="line"></span><br><span class="line"> #38 = Utf8  Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line"> #39 = Utf8  java/io/PrintStream</span><br><span class="line"></span><br><span class="line"> #40 = Utf8  println</span><br><span class="line"></span><br><span class="line"> #41 = Utf8  (Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> public com.ymm.agent.Test();</span><br><span class="line"></span><br><span class="line"> descriptor: ()V</span><br><span class="line"></span><br><span class="line"> flags: (0x0001) ACC_PUBLIC</span><br><span class="line"></span><br><span class="line"> Code:</span><br><span class="line"></span><br><span class="line"> stack=1, locals=1, args_size=1</span><br><span class="line"></span><br><span class="line"> 0: aload_0</span><br><span class="line"></span><br><span class="line"> 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line"> 4: return</span><br><span class="line"></span><br><span class="line"> LineNumberTable:</span><br><span class="line"></span><br><span class="line"> line 9: 0</span><br><span class="line"></span><br><span class="line"> LocalVariableTable:</span><br><span class="line"></span><br><span class="line"> Start Length Slot Name  Signature</span><br><span class="line"></span><br><span class="line"> 0  5  0 this  Lcom/ymm/agent/Test;</span><br><span class="line"></span><br><span class="line"> public java.lang.String sayHello();</span><br><span class="line"></span><br><span class="line"> descriptor: ()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> flags: (0x0001) ACC_PUBLIC</span><br><span class="line"></span><br><span class="line"> Code:</span><br><span class="line"></span><br><span class="line"> stack=1, locals=2, args_size=1</span><br><span class="line"></span><br><span class="line"> 0: ldc  #2 // String hello world</span><br><span class="line"></span><br><span class="line"> 2: astore_1</span><br><span class="line"></span><br><span class="line"> 3: aload_1</span><br><span class="line"></span><br><span class="line"> 4: areturn</span><br><span class="line"></span><br><span class="line"> LineNumberTable:</span><br><span class="line"></span><br><span class="line"> line 12: 0</span><br><span class="line"></span><br><span class="line"> line 13: 3</span><br><span class="line"></span><br><span class="line"> LocalVariableTable:</span><br><span class="line"></span><br><span class="line"> Start Length Slot Name  Signature</span><br><span class="line"></span><br><span class="line"> 0  5  0 this  Lcom/ymm/agent/Test;</span><br><span class="line"></span><br><span class="line"> 3  2  1 sayStr  Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> public static void main(java.lang.String[]);</span><br><span class="line"></span><br><span class="line"> descriptor: ([Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"> flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line"> Code:</span><br><span class="line"></span><br><span class="line"> stack=2, locals=2, args_size=1</span><br><span class="line"></span><br><span class="line"> 0: new  #3 // class com/ymm/agent/Test</span><br><span class="line"></span><br><span class="line"> 3: dup</span><br><span class="line"></span><br><span class="line"> 4: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line"> 7: astore_1</span><br><span class="line"></span><br><span class="line"> 8: getstatic  #5 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line"> 11: aload_1</span><br><span class="line"></span><br><span class="line"> 12: invokevirtual #6 // Method sayHello:()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> 15: invokevirtual #7 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"> 18: return</span><br><span class="line"></span><br><span class="line"> LineNumberTable:</span><br><span class="line"></span><br><span class="line"> line 17: 0</span><br><span class="line"></span><br><span class="line"> line 18: 8</span><br><span class="line"></span><br><span class="line"> line 19: 18</span><br><span class="line"></span><br><span class="line"> LocalVariableTable:</span><br><span class="line"></span><br><span class="line"> Start Length Slot Name  Signature</span><br><span class="line"></span><br><span class="line"> 0 19  0 args  [Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"> 8 11  1 test  Lcom/ymm/agent/Test;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SourceFile: &quot;Test.java&quot;</span><br></pre></td></tr></table></figure><p>通过上文的<code>interfaces: 0, fields: 0, methods: 3, attributes: 1</code>，我们可以知道该文件一共包含<code>3</code>个方法，分别对应着<code>无参构造</code>,<code>sayHello</code>,<code>main</code>三个方法</p><p>好了，现在让我们直接略过前面的一大推常量池项，</p><p>直接阅读我们自己写的<code>sayHello</code>方法的字节码内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public java.lang.String sayHello();</span><br><span class="line"></span><br><span class="line"> descriptor: ()Ljava/lang/String; /* 方法描述符 */</span><br><span class="line"></span><br><span class="line"> flags: (0x0001) ACC_PUBLIC /* 访问标识 */</span><br><span class="line"></span><br><span class="line"> Code: /* code属性  也就是我们写的具体代码翻译成的字节码指令内容 */</span><br><span class="line"></span><br><span class="line"> stack=1, locals=2, args_size=1 /* 分别指操作数栈深度；本地变量所需的存储空间（slot为单位）；参数个数 */</span><br><span class="line"></span><br><span class="line"> 0: ldc  #2 // String hello world /*将一个常量加载到操作数栈*/</span><br><span class="line"></span><br><span class="line"> 2: astore_1 /* 将一个数值从操作数栈存储到局部变量表 */</span><br><span class="line"></span><br><span class="line"> 3: aload_1 /* 将一个数值从局部变量表加载到操作数栈 */</span><br><span class="line"></span><br><span class="line"> 4: areturn /* 将栈顶第一个元素返回 */</span><br><span class="line"></span><br><span class="line"> LineNumberTable: /* 字节码与java代码行数对应关系 一般用于调试 */</span><br><span class="line"></span><br><span class="line"> line 12: 0</span><br><span class="line"></span><br><span class="line"> line 13: 3</span><br><span class="line"></span><br><span class="line"> LocalVariableTable: /* 局部变量表 */</span><br><span class="line"></span><br><span class="line"> Start Length Slot Name  Signature</span><br><span class="line"></span><br><span class="line"> 0  5  0 this  Lcom/ymm/agent/Test;</span><br><span class="line"></span><br><span class="line"> 3  2  1 sayStr  Ljava/lang/String;</span><br></pre></td></tr></table></figure><p>根据上表我们知道方法表的第一个内容的是<code>access_flas</code>，占一个字节。表中的<code>access_flas</code>其实就对应着上文中的  <code>flags: (0x0001) ACC_PUBLIC</code>，标识这个方法是<code>public</code>的，接下在的<code>name_index</code>和<code>descriptor_index</code>，在上文中的体现分别对应着<code>sayHello</code>和<code>()Ljava/lang/String;</code>。</p><p>这里解释一下描述符的概念，在介绍<code>Class文件结构</code>的文章中有提到，这里再提一遍:</p><p><strong>描述符的作用是用来描述字段的数据类型，方法的参数列表和返回值</strong>，根据描述符规则，基本数据类型（byte,char,int,long,float,double,short,boolean）以及代表无返回值的<code>void</code>类型都用一个大写字符来表示，而对象类型则用<code>L</code>加对象的全限定名来表示</p><p>最重要的内容其实还是在<code>attribute_info</code>属性表中的<code>code</code>内容，也就是我们写的具体代码翻译成的字节码指令内容，这块内容是我们阅读字节码文件的重中之重。下面我们就来阅读一下上文的字节码内容</p><ol><li><p>ldc #2 将常量池中索引为2的字符串加载到操作数栈顶</p></li><li><p>astore_1 将一个数值从操作数栈存储到局部变量表</p></li><li><p>aload_1 将一个数值从局部变量表加载到操作数栈</p></li><li><p>areturn 将栈顶第一个元素返回</p></li></ol><p>可以看到上面的四个步骤的操作其实都是基于栈的操作，这里提一下java虚拟机栈的栈帧结构</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-0b89369329932afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>关于字节码子令集可以参考<a href="https://blog.csdn.net/zqz_zqz/article/details/79484757" target="_blank" rel="noopener"><a href="https://blog.csdn.net/zqz_zqz/article/details/79484757" target="_blank" rel="noopener">java字节码子令集</a></a></p><h2 id="有趣的例子-—"><a href="#有趣的例子-—" class="headerlink" title="有趣的例子 —"></a>有趣的例子 —</h2><p>下面我们再来看一个有趣的例子，大家思考一下这个执行这个方法的返回值会是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line"> public int inc() &#123;</span><br><span class="line"></span><br><span class="line"> int x;</span><br><span class="line"></span><br><span class="line"> try &#123;</span><br><span class="line"></span><br><span class="line"> x = 1;</span><br><span class="line"></span><br><span class="line"> return x;</span><br><span class="line"></span><br><span class="line"> &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line"> x = 2;</span><br><span class="line"></span><br><span class="line"> return x;</span><br><span class="line"></span><br><span class="line"> &#125; finally &#123;</span><br><span class="line"></span><br><span class="line"> x = 3;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码非常简单，我想大家应该也都知道正确答案，当没有出现异常的时候，返回值为1，出现异常的话则为2（当然这里不会抛异常）。可是如果我们在finally快里加句代码<code>System.out.prinln(&quot;do it&quot;)</code>，然后再执行这个方法，其实是可以看到<code>do it</code>被打印了，也就是说在执行<code>return</code>之前，finally快中的代码是被执行了的，那么这里就有一个有趣的问题了，为何返回仍然是2而不是3呢？</p><p>下面我们就从字节码文件中来找出答案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int inc();</span><br><span class="line"></span><br><span class="line"> descriptor: ()I</span><br><span class="line"></span><br><span class="line"> flags: (0x0001) ACC_PUBLIC</span><br><span class="line"></span><br><span class="line"> Code:</span><br><span class="line"></span><br><span class="line"> stack=1, locals=5, args_size=1</span><br><span class="line"></span><br><span class="line"> 0: iconst_1 // 将int = 1的值压入栈顶</span><br><span class="line"></span><br><span class="line"> 1: istore_1 // 弹出栈顶元素，存入位置为1的局部变量表</span><br><span class="line"></span><br><span class="line"> 2: iload_1 // 从位置为1的局部变量中取出元素压入栈顶</span><br><span class="line"></span><br><span class="line"> 3: istore_2 // 弹出栈顶元素，存入位置2的局部变量中</span><br><span class="line"></span><br><span class="line"> 4: iconst_3 // 将int = 3的值压入栈顶 （这里执行finally块中的代码了）</span><br><span class="line"></span><br><span class="line"> 5: istore_1 // 弹出栈顶元素，存入位置1的局部变量中</span><br><span class="line"></span><br><span class="line"> 6: iload_2 // 从位置为2的局部变量中取出元素压入栈顶</span><br><span class="line"></span><br><span class="line"> 7: ireturn // 返回栈顶元素2 (哈哈哈  看到没有，这里返回的是2，没有异常的话，这里方法就返回了)</span><br><span class="line"></span><br><span class="line"> 8: astore_2 // 将栈顶的异常引用，存入位置2的局部变量中  （这里就是异常捕获的代码了）</span><br><span class="line"></span><br><span class="line"> 9: iconst_2 // 将int = 2的值压入栈顶</span><br><span class="line"></span><br><span class="line"> 10: istore_1 // 弹出栈顶元素，存入位置1的局部变量中</span><br><span class="line"></span><br><span class="line"> 11: iload_1 // 从位置为1的局部变量中取出元素压入栈顶</span><br><span class="line"></span><br><span class="line"> 12: istore_3 // 弹出栈顶元素，存入位置3的局部变量中</span><br><span class="line"></span><br><span class="line"> 13: iconst_3 // 将int = 3的值压入栈顶</span><br><span class="line"></span><br><span class="line"> 14: istore_1 // 弹出栈顶元素，存入位置1的局部变量中</span><br><span class="line"></span><br><span class="line"> 15: iload_3 // 从位置为3的局部变量中取出元素压入栈顶</span><br><span class="line"></span><br><span class="line"> 16: ireturn // 返回栈顶元素 2</span><br><span class="line"></span><br><span class="line"> 17: astore 4 // 将栈顶异常引用存入位置为4的局部变量表中</span><br><span class="line"></span><br><span class="line"> 19: iconst_3 // 将int = 3的值压入栈顶</span><br><span class="line"></span><br><span class="line"> 20: istore_1 // 弹出栈顶元素，存入位置1的局部变量中</span><br><span class="line"></span><br><span class="line"> 21: aload  4 将位置为4的局部变量引用压入栈顶</span><br><span class="line"></span><br><span class="line"> 23: athrow // 将栈顶的异常抛出</span><br><span class="line"></span><br><span class="line"> Exception table: // 异常表</span><br><span class="line"></span><br><span class="line"> from to target type</span><br><span class="line"></span><br><span class="line"> 0  4  8  Class java/lang/Exception</span><br><span class="line"></span><br><span class="line"> 0  4 17  any</span><br><span class="line"></span><br><span class="line"> 8 13 17  any</span><br><span class="line"></span><br><span class="line"> 17 19 17  any</span><br></pre></td></tr></table></figure><p>如果你已经看懂了上面的字节码，你应该会豁朗开朗。原因其实就是在于这里开辟了两个局部变量，<code>finally</code>块中的代码也确实执行了，只是将变量存入了局部变量表中的另一个位置，并且通过这个例子，也可以发现，无论什么情况<code>finally</code>块中的代码都会执行。</p><h2 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h2><p>好了，本文到这里就差不多结束了。对于字节码的探索个人觉的还是非常有意思的，之后应该也会探索更多有意思的东西</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;因为字段表和方法表的结构类似，所以我们直接分析Java字节码的方法表内容，理解了方法表，自然就理解了字段表&lt;/p&gt;
&lt;h2 id=&quot;方法表&quot;
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JVM" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/"/>
    
      <category term="java字节码" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
    
      <category term="JVM" scheme="http://wangjunnan.github.io/tags/JVM/"/>
    
      <category term="java字节码" scheme="http://wangjunnan.github.io/tags/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>使用Java NIO实现一个HTTP服务器</title>
    <link href="http://wangjunnan.github.io/2019/04/19/%E4%BD%BF%E7%94%A8Java-NIO%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://wangjunnan.github.io/2019/04/19/使用Java-NIO实现一个HTTP服务器/</id>
    <published>2019-04-19T03:04:30.000Z</published>
    <updated>2019-11-08T07:45:51.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>一直以来都想写一个自己的http服务器，这次趁着稍微空闲了一些，赶紧码了一个<code>mini</code>版的。在这里跟大家分享一下编写的整个思路，总体来说，整个应用非常简单，目前也只是实现了最基本的静态资源访问，但对于想学习<code>Http</code>协议的同学来说，应该还是有所帮助</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>先简单介绍一下<code>HTTP</code>协议，<code>HTTP</code>协议是构建于<code>TCP/IP</code>协议之上的一个应用层协议，并且是无连接无状态的。</p><h3 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h3><p>http的请求报文由三部分组成</p><ul><li><p>状态行  <code>&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</code> method包含<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>等</p></li><li><p>请求头</p></li><li><p>消息主体</p></li></ul><p>下面是典型的http请求报文示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /static/home.html HTTP/1.1</span><br><span class="line"></span><br><span class="line">Host: localhost:8080</span><br><span class="line"></span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line"></span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36</span><br><span class="line"></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3</span><br><span class="line"></span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line"></span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br></pre></td></tr></table></figure><h3 id="http响应报文"><a href="#http响应报文" class="headerlink" title="http响应报文"></a>http响应报文</h3><p>响应报文跟请求报文类似，也由三部分组成</p><ul><li><p>状态行  这里需要关注下响应的各个状态所代表的含义，以及浏览器识别这些状态码会相应的做哪些事情</p></li><li><p>响应头</p></li><li><p>响应正文</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">Server: cloud http v1.0</span><br><span class="line"></span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...</span><br></pre></td></tr></table></figure><p><strong>##</strong> <strong>动手</strong></p><p>前面简单介绍了一下http协议的基本信息，下面就是源码实现了，我这里直接使用了Java NIO作为底层通信支撑，在实际的生产代码中，大多会选择封装良好的<code>netty</code>来作为稳定的底层通信</p><p>这里先放上项目源码 <a href="https://github.com/WangJunnan/cloudhttp" target="_blank" rel="noopener"><a href="https://github.com/WangJunnan/cloudhttp" target="_blank" rel="noopener">CloudHttp</a></a></p><h3 id="定义Request和Response"><a href="#定义Request和Response" class="headerlink" title="定义Request和Response"></a>定义Request和Response</h3><ul><li>Request</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * method</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * http协议版本</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String httpVersion;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 请求uri</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String uri;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 请求相对路径</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 请求头信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, String&gt; headers;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 请求参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, String&gt; attribute;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Response</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String protocol = <span class="string">"HTTP/1.1"</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, String&gt; headers;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> ByteArrayOutputStream outPutStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.code = HttpCode.STATUS_200.getCode();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.msg = HttpCode.STATUS_200.getMsg();</span><br><span class="line"></span><br><span class="line"> headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> headers.put(<span class="string">"Content-Type"</span>, <span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"> headers.put(<span class="string">"Server"</span>, <span class="string">"cloud http v1.0"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义请求响应解析类  <code>HttpParser</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(HttpParser.class);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * &lt;p&gt;解析http请求体&lt;/p&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buffers</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Request <span class="title">decodeReq</span><span class="params">(<span class="keyword">byte</span> [] buffers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> Request request = <span class="keyword">new</span> Request();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (buffers != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"> String resString = <span class="keyword">new</span> String(buffers);</span><br><span class="line"></span><br><span class="line"> logger.info(resString);</span><br><span class="line"></span><br><span class="line"> String[] headers = resString.trim().split(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (headers.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"> String firstline = headers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 按空格分割字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 method uri 协议版本</span></span><br><span class="line"></span><br><span class="line"> String mainInfo [] = firstline.split(<span class="string">"\\s+"</span>);</span><br><span class="line"></span><br><span class="line"> request.setMethod(mainInfo[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> request.setUri(URLDecoder.decode(mainInfo[<span class="number">1</span>], <span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_HttpParser_URLDecode, uri = &#123;&#125;"</span>, mainInfo[<span class="number">1</span>], e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> request.setHttpVersion(mainInfo[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解析header</span></span><br><span class="line"></span><br><span class="line"> Map&lt;String, String&gt; headersMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; headers.length; i++) &#123;</span><br><span class="line"></span><br><span class="line"> String entryStr = headers[i];</span><br><span class="line"></span><br><span class="line"> String entry [] = entryStr.trim().split(<span class="string">":"</span>);</span><br><span class="line"></span><br><span class="line"> headersMap.put(entry[<span class="number">0</span>].trim(), entry[<span class="number">1</span>].trim());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> request.setHeaders(headersMap);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解析参数</span></span><br><span class="line"></span><br><span class="line"> String uri = request.getUri();</span><br><span class="line"></span><br><span class="line"> Map&lt;String, String&gt; attribute = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> request.setPath(uri);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (StringUtils.isNotEmpty(uri)) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> indexOfParam = uri.indexOf(<span class="string">"?"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (indexOfParam &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 设置path</span></span><br><span class="line"></span><br><span class="line"> request.setPath(uri.substring(<span class="number">0</span>, indexOfParam));</span><br><span class="line"></span><br><span class="line"> String queryString = uri.substring(indexOfParam + <span class="number">1</span>, uri.length());</span><br><span class="line"></span><br><span class="line"> String paramEntrys [] = queryString.split(<span class="string">"&amp;"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (String paramEntry : paramEntrys) &#123;</span><br><span class="line"></span><br><span class="line"> String [] entry = paramEntry.split(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (entry.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"> String key = entry[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"> String value = entry.length &gt; <span class="number">1</span> ? entry[<span class="number">1</span>] : <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"> attribute.put(key, value);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> request.setAttribute(attribute);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> request;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * &lt;p&gt;返回http响应字节流&lt;/p&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encodeResHeader(Response response) &#123;</span><br><span class="line"></span><br><span class="line"> StringBuilder resBuild = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"> resBuild.append(response.getProtocol() + <span class="string">" "</span> + response.getCode() + <span class="string">" "</span> + response.getMsg());</span><br><span class="line"></span><br><span class="line"> resBuild.append(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line"> Map&lt;String, String&gt; headers = response.getHeaders();</span><br><span class="line"></span><br><span class="line"> headers.entrySet().forEach(entry -&gt; &#123;</span><br><span class="line"></span><br><span class="line"> resBuild.append(entry.getKey());</span><br><span class="line"></span><br><span class="line"> resBuild.append(<span class="string">": "</span>);</span><br><span class="line"></span><br><span class="line"> resBuild.append(entry.getValue());</span><br><span class="line"></span><br><span class="line"> resBuild.append(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> resBuild.append(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line"> String resString = resBuild.toString();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> [] bytes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> bytes = resString.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_encodeResHeader"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> bytes;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Java-nio-启动服务器"><a href="#使用Java-nio-启动服务器" class="headerlink" title="使用Java nio 启动服务器"></a>使用Java nio 启动服务器</h3><ul><li>NioServer</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> <span class="keyword">implements</span> <span class="title">Server</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(NioServer.class);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Thread serverThread;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">boolean</span> running = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> NioServer server;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> CloudService cloudService;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService requestWork = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NioServer <span class="title">getServerInstance</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">synchronized</span> (NioServer.class) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"> server = <span class="keyword">new</span> NioServer();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> server;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">NioServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.cloudService = <span class="keyword">new</span> CloudService();</span><br><span class="line"></span><br><span class="line"> port = Integer.valueOf(CloudHttpConfig.getValue(<span class="string">"port"</span>, <span class="string">"8080"</span>));</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (running) &#123;</span><br><span class="line"></span><br><span class="line"> logger.info(<span class="string">"服务器已经启动"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> serverThread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"> serverThread.start();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> serverSocketChannel.close();</span><br><span class="line"></span><br><span class="line"> serverThread.stop();</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_NioServer_stop"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打开ServerSocketChannel通道</span></span><br><span class="line"></span><br><span class="line"> serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//得到ServerSocket对象</span></span><br><span class="line"></span><br><span class="line"> serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line"> Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"> serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"> serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line"> selector.select();</span><br><span class="line"></span><br><span class="line"> Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line"> SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (selectedKeys.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line"> key = selectedKeys.next();</span><br><span class="line"></span><br><span class="line"> selectedKeys.remove();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line"> accept(key);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line"> read(key);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line"></span><br><span class="line"> write(key);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_NioServer_run"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> ServerSocketChannel serverSocketChannel = (ServerSocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line"> SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line"> socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"> socketChannel.register(key.selector(), SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_NioServer_accept"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Request <span class="title">read</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> Request request = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> readNum = socketChannel.read(readBuffer);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (readNum == -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"> socketChannel.close();</span><br><span class="line"></span><br><span class="line"> key.cancel();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> readBuffer.flip();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> [] buffers = <span class="keyword">new</span> <span class="keyword">byte</span>[readBuffer.limit()];</span><br><span class="line"></span><br><span class="line"> readBuffer.get(buffers);</span><br><span class="line"></span><br><span class="line"> readBuffer.clear();</span><br><span class="line"></span><br><span class="line"> request = HttpParser.decodeReq(buffers);</span><br><span class="line"></span><br><span class="line"> requestWork.execute(<span class="keyword">new</span> RequestWorker(request, key, cloudService));</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_NioServer_read"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> request;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"> ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(buffer == <span class="keyword">null</span> || !buffer.hasRemaining()) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line"> socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(!buffer.hasRemaining())&#123;</span><br><span class="line"></span><br><span class="line"> key.interestOps(SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"> buffer.clear();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> socketChannel.close();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理请求的-RequestWork类"><a href="#处理请求的-RequestWork类" class="headerlink" title="处理请求的 RequestWork类"></a>处理请求的 RequestWork类</h3><p>对于每一个进入的请求。都会单独启动一个线程来进行处理</p><ul><li>RequestWorker</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RequestWorker.class);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Request request;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> SelectionKey key;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> SocketChannel channel;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> CloudService cloudService;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">RequestWorker</span><span class="params">(Request request, SelectionKey key, CloudService cloudService)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.request = request;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.key = key;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.channel = (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.cloudService = cloudService;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> Response response = <span class="keyword">new</span> Response();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> cloudService.doService(request, response);</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (ViewNotFoundException e) &#123;</span><br><span class="line"></span><br><span class="line"> response.setCode(HttpCode.STATUS_404.getCode());</span><br><span class="line"></span><br><span class="line"> response.setMsg(HttpCode.STATUS_404.getMsg());</span><br><span class="line"></span><br><span class="line"> ByteArrayOutputStream outputStream = response.getOutPutStream();</span><br><span class="line"></span><br><span class="line"> InputStream inputStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"404.html"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> bytes [] = <span class="keyword">new</span> <span class="keyword">byte</span> [<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> ((len = inputStream.read(bytes)) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"> outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_requestWork_write404"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> [] resHeader = HttpParser.encodeResHeader(response);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> [] body = response.getOutPutStream().toByteArray();</span><br><span class="line"></span><br><span class="line"> ByteBuffer byteBuffer = ByteBuffer.allocate(resHeader.length + body.length);</span><br><span class="line"></span><br><span class="line"> byteBuffer.put(resHeader);</span><br><span class="line"></span><br><span class="line"> byteBuffer.put(body);</span><br><span class="line"></span><br><span class="line"> byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将输出流绑定至附件</span></span><br><span class="line"></span><br><span class="line"> key.attach(byteBuffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册写事件</span></span><br><span class="line"></span><br><span class="line"> key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line"></span><br><span class="line"> key.selector().wakeup();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义Servlet接口"><a href="#定义Servlet接口" class="headerlink" title="定义Servlet接口"></a>定义Servlet接口</h3><ul><li>CloudServlet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CloudServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 判断当前请求是否匹配 handler</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Request request)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 执行初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Request request, Response response)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 执行请求</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">doService</span><span class="params">(Request request, Response response)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>StaticViewServlet 定义一个处理静态资源的<code>StaticViewServlet</code>实现<code>CloudServlet</code>接口</li></ul><p>该静态资源处理器会自动拦截<code>static</code>路径下的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticViewServlet</span> <span class="keyword">implements</span> <span class="title">CloudServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(StaticViewServlet.class);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String staticRootPath;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Pattern p = Pattern.compile(<span class="string">"^/static/\\S+"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> String path = request.getPath();</span><br><span class="line"></span><br><span class="line"> Matcher matcher = p.matcher(path);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> matcher.matches();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> staticRootPath = CloudHttpConfig.getValue(<span class="string">"static.resource.path"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> String path = request.getPath();</span><br><span class="line"></span><br><span class="line"> String fileRelativePath = path.substring(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> String absolutePath = staticRootPath + <span class="string">"/"</span> + fileRelativePath;</span><br><span class="line"></span><br><span class="line"> RandomAccessFile randomAccessFile = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"> randomAccessFile = <span class="keyword">new</span> RandomAccessFile(absolutePath, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"> FileChannel fileChannel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line"> ByteBuffer htmBuffer = ByteBuffer.allocate((<span class="keyword">int</span>)fileChannel.size());</span><br><span class="line"></span><br><span class="line"> fileChannel.read(htmBuffer);</span><br><span class="line"></span><br><span class="line"> htmBuffer.flip();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> [] htmByte = <span class="keyword">new</span> <span class="keyword">byte</span>[htmBuffer.limit()];</span><br><span class="line"></span><br><span class="line"> htmBuffer.get(htmByte);</span><br><span class="line"></span><br><span class="line"> response.getOutPutStream().write(htmByte);</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> ViewNotFoundException();</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line"> logger.error(<span class="string">"error_StaticViewServlet_doService 异常"</span>, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义-CloudService"><a href="#定义-CloudService" class="headerlink" title="定义 CloudService"></a>定义 CloudService</h3><p><code>CloudService</code>是用于盛放<code>Servlet</code>的容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> List&lt;CloudServlet&gt; cloudServlets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">CloudService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> cloudServlets.add(<span class="keyword">new</span> StaticViewServlet());</span><br><span class="line"></span><br><span class="line"> cloudServlets.add(<span class="keyword">new</span> MappingUrlServlet());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> CloudServlet servlet = doSelect(request);</span><br><span class="line"></span><br><span class="line"> servlet.init(request, response);</span><br><span class="line"></span><br><span class="line"> servlet.doService(request, response);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> CloudServlet <span class="title">doSelect</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (CloudServlet cloudServlet : cloudServlets) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (cloudServlet.match(request)) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> cloudServlet;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> MappingUrlServlet();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后-编写启动类"><a href="#最后-编写启动类" class="headerlink" title="最后  编写启动类"></a>最后  编写启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudHttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 启动服务器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> NioServer.getServerInstance().start();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> startServer();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li><p>启动服务器</p></li><li><p>浏览器访问  <code>http://localhost:8080/static/home.html</code></p></li></ol><p>响应页面</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-aa1ea0a3a1d1f266.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h2><p>本文只是一个示例，仅仅实现了静态资源访问。做为自娱自乐的项目 +——=</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;一直以来都想写一个自己的http服务器，这次趁着稍微空闲了一些，赶紧码了一个&lt;code&gt;mini&lt;/code&gt;版的。在这里跟大家分享一下编写
      
    
    </summary>
    
      <category term="NIO" scheme="http://wangjunnan.github.io/categories/NIO/"/>
    
      <category term="HTTP" scheme="http://wangjunnan.github.io/categories/NIO/HTTP/"/>
    
    
      <category term="NIO" scheme="http://wangjunnan.github.io/tags/NIO/"/>
    
      <category term="HTTP" scheme="http://wangjunnan.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码常量池</title>
    <link href="http://wangjunnan.github.io/2019/04/17/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <id>http://wangjunnan.github.io/2019/04/17/Java字节码常量池/</id>
    <published>2019-04-17T07:48:48.000Z</published>
    <updated>2019-11-08T07:45:51.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上篇文章简单介绍了<code>java Class</code> 字节码文件的基本格式。本文我们直接通过阅读字节码文件来进一步理解字节码中的常量池结构</p><p>首先我们新建一个最简单的Java文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后使用文本编辑器打开，可以看到<code>Class</code>文件最原始的16进制格式。最明显的<code>Class</code>文件的魔数<code>cafe babe</code>一眼就能看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">cafe babe 0000 0034 0022 0a00 0600 1409</span><br><span class="line">0015 0016 0800 170a 0018 0019 0700 1a07</span><br><span class="line">001b 0100 063c 696e 6974 3e01 0003 2829</span><br><span class="line">5601 0004 436f 6465 0100 0f4c 696e 654e</span><br><span class="line">756d 6265 7254 6162 6c65 0100 124c 6f63</span><br><span class="line">616c 5661 7269 6162 6c65 5461 626c 6501</span><br><span class="line">0004 7468 6973 0100 144c 636f 6d2f 796d</span><br><span class="line">6d2f 6167 656e 742f 5465 7374 3b01 0004</span><br><span class="line">6d61 696e 0100 1628 5b4c 6a61 7661 2f6c</span><br><span class="line">616e 672f 5374 7269 6e67 3b29 5601 0004</span><br><span class="line">6172 6773 0100 135b 4c6a 6176 612f 6c61</span><br><span class="line">6e67 2f53 7472 696e 673b 0100 0a53 6f75</span><br><span class="line">7263 6546 696c 6501 0009 5465 7374 2e6a</span><br><span class="line">6176 610c 0007 0008 0700 1c0c 001d 001e</span><br><span class="line">0100 0b68 656c 6c6f 2077 6f72 6c64 0700</span><br><span class="line">1f0c 0020 0021 0100 1263 6f6d 2f79 6d6d</span><br><span class="line">2f61 6765 6e74 2f54 6573 7401 0010 6a61</span><br><span class="line">7661 2f6c 616e 672f 4f62 6a65 6374 0100</span><br><span class="line">106a 6176 612f 6c61 6e67 2f53 7973 7465</span><br><span class="line">6d01 0003 6f75 7401 0015 4c6a 6176 612f</span><br><span class="line">696f 2f50 7269 6e74 5374 7265 616d 3b01</span><br><span class="line">0013 6a61 7661 2f69 6f2f 5072 696e 7453</span><br><span class="line">7472 6561 6d01 0007 7072 696e 746c 6e01</span><br><span class="line">0015 284c 6a61 7661 2f6c 616e 672f 5374</span><br><span class="line">7269 6e67 3b29 5600 2100 0500 0600 0000</span><br><span class="line">0000 0200 0100 0700 0800 0100 0900 0000</span><br><span class="line">2f00 0100 0100 0000 052a b700 01b1 0000</span><br><span class="line">0002 000a 0000 0006 0001 0000 0009 000b</span><br><span class="line">0000 000c 0001 0000 0005 000c 000d 0000</span><br><span class="line">0009 000e 000f 0001 0009 0000 0037 0002</span><br><span class="line">0001 0000 0009 b200 0212 03b6 0004 b100</span><br><span class="line">0000 0200 0a00 0000 0a00 0200 0000 0b00</span><br><span class="line">0800 0c00 0b00 0000 0c00 0100 0000 0900</span><br><span class="line">1000 1100 0000 0100 1200 0000 0200 13</span><br></pre></td></tr></table></figure><h2 id="如何从上面的文件中找到常量池所在的位置呢"><a href="#如何从上面的文件中找到常量池所在的位置呢" class="headerlink" title="如何从上面的文件中找到常量池所在的位置呢"></a>如何从上面的文件中找到常量池所在的位置呢</h2><p>在上篇文章中我们已经分析过<code>Class</code>文件文件格式了，常量池的位置紧随在版本号之后，也就是从第9个字节开始就是常量池的内容了，下面就让我们一起来看下常量池的具体内容</p><h3 id="constant-pool-count-u2"><a href="#constant-pool-count-u2" class="headerlink" title="constant_pool_count u2"></a>constant_pool_count u2</h3><p>从第9个字节开始往后的两个字节，是<code>constant_pool_count</code>，我们把它叫做常量计数器，比较特殊的是它的下标是从1开始的，也就是说真正的常量池数量是<code>constant_pool_count - 1</code>个，那好现在让我们来看看上面的那个普通<code>Class</code>文件包含了多少个常量表（<code>cp_info</code>）</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-1e1c7e2eecf80bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常量计数"></p><p>可以看到<code>constant_pool_count</code>标识位是<code>0022</code>，转为10进制就是34。也就是说包含<code>34 - 1 = 33</code>个常量表内容</p><h3 id="cp-info"><a href="#cp-info" class="headerlink" title="cp_info"></a>cp_info</h3><p>上文经过分析我们已经确定了字节码文件包含的常量表个数，那么接下来我们要具体怎么看呢？</p><p>下面让我们来具体分析下<code>cp_info</code>的结构</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-e45775e88817026d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以看到每个<code>cp_info</code>的第一个字节位都是<code>tag</code>，用于标识常量表所属的具体类型，上篇文章我们说过，常量表之所以非常复杂，就是因为它的类型众多，有多大14种类型。那么这些类型的区分就是通过<code>tag</code>来区分。我们会逐个分析这14种类型</p><p>先来看下这14常量池类型</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-5f84affafe924089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>还是回到上述字节码的16进制文件，我们接着往下看</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-e413777a45543d46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以看到<code>tag = 10</code>，根据上文我们列出的细分类型可以确定这第一个出现的常量表类型是<code>constant_Methodref_info</code>。那好现在我们再去具体的看下<code>constant_Methodref_info</code>表的具体内容</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-10a980be4439b580.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="constant_Methodref_info.png"></p><p>可以看到紧跟在<code>tag</code>之后其实是两项index索引值，分别指向<code>constant_Class_info</code>和<code>constant_NameAndType_info</code>。</p><p>继续往下阅读，可以知道具体的索引值分别为<code>0006</code>，<code>0014</code>。也就是指向常量池的第6项和第20项</p><p>下面为了方便阅读，我们直接使用<code>javap -v Test</code>命令生成方便我们阅读的字节码文件，当然如果有兴趣的话，直接阅读源文件也是oK的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class com.ymm.agent.Test</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #5                          // com/ymm/agent/Test</span><br><span class="line">  super_class: #6                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #23            // hello world</span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/ymm/agent/Test</span><br><span class="line">   #6 = Class              #27            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/ymm/agent/Test;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               Test.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               hello world</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/ymm/agent/Test</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.ymm.agent.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">.... 省略其他字节码</span><br></pre></td></tr></table></figure><p>通过<code>javap</code> 生成的字节码文件，看起来就舒服多了。现在继续回到第一个常量池项<code>constant_Methodref_info</code>，可以知道它是由<code>constant_Class_info</code>，<code>constant_NameAndType_info</code>两项的索引值组成，根据索引值<code>6</code>,<code>20</code>我们可以找到具体常量池项内容。</p><p>先找到索引值为<code>6</code>的<code>constant_Class_info</code>的内容，可以发现其具体内容也是指向了一个索引值<code>27</code>，继续找索引值为<code>27</code>常量项</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-5c7eb023de534a0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>找到索引值为<code>27</code>的常量项，可以发现是一个<code>constant_utf8_info</code>类型的字符串(java/lang/Object)，这也就是我们之前提到的类的全限定名称</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-22a9e1eb96234b8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>到目前为止大家应该已经找到了阅读常量池的感觉了，那么我们去查看索引项为<code>20</code>的<code>constant_NameAndType_info</code>的方法也是一样的</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-4332f33c24364301.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><code>constant_NameAndType_info</code>指向索引值为<code>7</code>和<code>8</code>的内容</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-0e0729faf2be3012.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以知道方法名称为<code>init</code>，类型为<code>void</code>方法</p><p>到目前为止我们大概可以知道此常量池的第一项表示其实是一个无参的构造方法，并且是编译器为我们自动生成的</p><p>其实大多数复杂的常量池内容最终都会索引到一个<code>constant_utf8_info</code>字符串类型，用于描述类全限定名，方法或字段名称及描述符等等 ..</p><h2 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h2><p>本篇文章我们只是通过一个示例来阅读<code>Class</code>文件的常量池内容，具体的常量池结构在上篇文章中我们都有列出，并且阅读的方法也是与本文类似。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;上篇文章简单介绍了&lt;code&gt;java Class&lt;/code&gt; 字节码文件的基本格式。本文我们直接通过阅读字节码文件来进一步理解字节码中的
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JVM" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/"/>
    
      <category term="java字节码" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
    
      <category term="JVM" scheme="http://wangjunnan.github.io/tags/JVM/"/>
    
      <category term="java字节码" scheme="http://wangjunnan.github.io/tags/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java Class文件结构</title>
    <link href="http://wangjunnan.github.io/2019/04/04/Java-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://wangjunnan.github.io/2019/04/04/Java-Class文件结构/</id>
    <published>2019-04-04T07:47:26.000Z</published>
    <updated>2019-11-08T07:45:51.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们都知道java是跨平台的，原因就在于各个平台的java虚拟机可以载入和执行同一种平台无关的字节码文件，也就是说java虚拟机不与包括Java在内的任何语言绑定，只于<code>Class</code>文件这种二进制格式文件所关联。</p><p>基于这样的设计，到目前为止已经出现了很多基于Java虚拟机的语言</p><p>如<code>groovy</code>最终都会编译成<code>class</code>文件</p><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p>一个Class文件唯一对应一个类或接口</p><p>现在让我们来看下<code>Class</code>文件的基本结构</p><p>Class文件以8位字节为基本单位的二进制文件，<strong>各个数据项目严格的按照顺序紧凑的排列在<code>Class</code>文件之中，中间没有任何分隔符，这使得整个<code>Class</code>文件中存储的内容几乎全部是运行时的必要数据</strong></p><p><code>Class</code>文件的二进制文件只有两种数据类型：无符号数和表，后面的解析都会以这两种数据类型为基础</p><ul><li>无符号数</li></ul><p>无符号数是最基本的数据类型，以<code>u1</code>,<code>u2</code>,<code>u4</code>,<code>u8</code>来分别代表1个字节，2个字节，4个字节，8个字节的无符号数，无符号数用来描述数字，索引引用，数量值，以及以UTF-8编码的字符串</p><ul><li>表</li></ul><p>表则是由多个无符号数或<strong>其他表组成的复合数据结构</strong>，表的名称一般以<code>_info</code>结尾。<strong>所以整个<code>Class</code>文件其实就是一张特殊的表</strong></p><p>下面表中所列的就是一个<code>Class</code>按顺序排列的数据结构</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic 魔数 标识Class文件</td><td>1</td></tr><tr><td>u2</td><td>minor_version 次版本号</td><td>1</td></tr><tr><td>u2</td><td>major_version 主版本号</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count 常量表集合数量</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool 常量表</td><td>constant_pool_count - 1</td></tr><tr><td>u2</td><td>access_flag 访问标识</td><td>1</td></tr><tr><td>u2</td><td>this_class 类索引</td><td>1</td></tr><tr><td>u2</td><td>super_class 父类索引</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count 接口索引数量</td><td>1</td></tr><tr><td>u2</td><td>interfaces 接口索引</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count 字段表集合数量</td><td>1</td></tr><tr><td>field_info</td><td>fields 字段表</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count 方法表集合数量</td><td>1</td></tr><tr><td>method_info</td><td>methods 方法表</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count 属性表集合数量</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes 属性表</td><td>attributes_count</td></tr></tbody></table><p>下面依次来解读表中每个类型</p><h3 id="魔数和版本号"><a href="#魔数和版本号" class="headerlink" title="魔数和版本号"></a>魔数和版本号</h3><p>头4个字节称为<code>Class</code>文件的魔数，魔数的作用是标识此文件能被Java虚拟机接受的<code>Class</code>文件，其实不止<code>Class</code>文件有魔数这个概念，包括其他很多文件格式出于安全的考虑也都会有魔数这个概念，魔数都是固定不变的，如<code>Class</code>文件的魔数就是<code>cafebabe</code></p><p>紧接着魔数之后的是版本号，第5 6个字节表示的是次版本号，第7 8个字节表示的是主版本号。版本号都是向下兼容的</p><h3 id="常量池表"><a href="#常量池表" class="headerlink" title="常量池表"></a>常量池表</h3><p>读懂常量池表对于阅读Class字节码非常重要，下面我们将以大篇幅分析常量池表</p><p>常量池是<code>Class</code>文件中出现的第一个表结构类型，同时也是占用<code>Class</code>文件最大空间的类型之一。由于常量池表的数量不是固定的，所以在常量池的入口有一项<code>u2</code>类型的数据，来代表常量池的数量。并且常量池比较特殊，容量计数是从1开始而不是从0开始，所以实际的常量池数量是<code>constant_pool_count - 1</code></p><p>常量池中主要存放两大类变量: 字面量和符号引用。字面量类似常量的概念，而符号引用则引至编译原理的概念，包括三类(类和接口的全限定名，字段的名称和描述符，方法的名称和描述符)，这里要注意的是，Java在<code>javac</code>编译的时候不会进行<code>Class</code>文件的动态连接，<strong>只有在运行时才会进行具体的<code>Class</code>文件的解析操作</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-9a9644b61564b4b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常量池分类类型"></p><h4 id="常量池表结构"><a href="#常量池表结构" class="headerlink" title="常量池表结构"></a>常量池表结构</h4><p>上文两大类的常量池类型细分之后，到JDK1.7之后增加到了14种。之所以说常量池是最复杂的结构，就是因为这14种不同的类型都有不同的表结构，下面我们来简单看下这14种结构</p><p>每种常量类型的起始位都有一个<code>u1</code>类型的tag标识符，用于标识当前的常量类型</p><p><img src="http://upload-images.jianshu.io/upload_images/2717496-100be34bc99676c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="截图至深入理解java虚拟机"><br><img src="http://upload-images.jianshu.io/upload_images/2717496-16c3df5c9fded87b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="截图至深入理解java虚拟机"></p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>访问标志用于识别类或接口层面的信息，标识是否为<code>public</code>，<code>abstract</code>，<code>final</code>，<code>注解</code>，<code>枚举</code>等</p><h3 id="类索引-父类索引-接口索引"><a href="#类索引-父类索引-接口索引" class="headerlink" title="类索引 父类索引 接口索引"></a>类索引 父类索引 接口索引</h3><p>类索引和父类索引都是一个<code>u2</code>类型的数据，而接口索引则是一组<code>u2</code>类型的集合，所以接口索引入口的第一项为一个<code>u2</code>类型的计数，表示有几个接口索引</p><p>类索引和接口索引的具体值是一个<code>u2</code>的数据项，并且指向一个<code>CONSTANT_Class_info</code>常量池表类型在常量池中的偏移量</p><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表用于描述接口或类中声明的变量，包括<strong>类级变量和实际级变量，不包括在方法内部声明的局部变量</strong></p><p>包含的信息主要有这几种: <code>字段作用域(private,protact,public)</code>，<code>是否static修饰</code>，<code>可变性</code>，<code>volatile 修饰</code>，<code>可否被序列化</code>，<code>字段类型(基本类型，引用，数组)</code>，<code>字段名称</code></p><p>字段表结构</p><table><thead><tr><th>类型</th><th>名称</th><th>数量 </th></tr></thead><tbody><tr><td>u2</td><td>access_flas</td><td>1 </td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>属性表</td><td>attributes_count</td></tr></tbody></table><h4 id="access-flas"><a href="#access-flas" class="headerlink" title="access_flas"></a>access_flas</h4><p>我们来看下字段<code>access_flas</code>访问标识可选的类型</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否public </td></tr><tr><td>ACC_PRIVARE</td><td>0x0002</td><td>字段是否private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否volatile</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>是否 transient</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为枚举类型</td></tr></tbody></table><p>看个例子，如果<code>access_flas</code>为<code>0x0019</code>，则标识了<code>ACC_PUBLIC</code>，<code>ACC_STATIC</code>，<code>ACC_FINAL</code>三种类型</p><h4 id="name-index和descriptor-index"><a href="#name-index和descriptor-index" class="headerlink" title="name_index和descriptor_index"></a>name_index和descriptor_index</h4><p>跟在<code>access_flas</code>之后是<code>name_index(简单名称)</code>和<code>descriptor_index(描述符)</code>。包括之前出现的<code>全限定名</code>，这里解释一下这几个名称。全限定名称一般来说是指<code>org/xxx/TestClass</code>这种类型的名称，可以理解为类的路径，简单名称就更加容易理解了，例如方法<code>inc()</code>的简单名称值的就是<code>inc</code></p><p>描述符相对于上面的两种稍复杂一些，<strong>描述符的作用是用来描述字段的数据类型，方法的参数列表和返回值</strong>，根据描述符规则，基本数据类型（byte,char,int,long,float,double,short,boolean）以及代表无返回值的<code>void</code>类型都用一个大写字符来表示，而对象类型则用<code>L</code>加对象的全限定名来表示</p><p>具体的列在了下表中</p><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>float</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>S</td><td>short</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>V</td><td>void</td></tr><tr><td>L</td><td>对象类型 如 Ljava/lang/Object</td></tr></tbody></table><p>对于数组类型，每一纬度使用一个前置的<code>[</code>来表示，如定义一个<code>java.lang.String []</code>的数组类型，将被记录为<code>[[Ljava/lang/String;</code></p><p>用描述符来描述方法时，按照先参数列表后返回值的顺序描述，参数列表严格按照顺序放在<code>()</code>内，如方法<code>void inc()</code>的描述符为<code>()V</code>，方法<code>int inc(int i, double)</code>的描述符为<code>(ID)I</code></p><p>在描述符之后，紧跟着是一个属性表集合，属性表集合可以为空，</p><h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><p><strong>方法表的组成与属性表的组成是完全一致的</strong>，访问标识符的取值略有不同</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>方法是否public </td></tr><tr><td>ACC_PRIVARE</td><td>0x0002</td><td>方法是否private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>方法是否protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>方法是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>方法是否final</td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>方法是否同步</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>方法是否由编译器产生的桥接方法</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>方法是否接受不定蚕食</td></tr><tr><td>ACC_NATIVE</td><td>0x0100</td><td>方法是否为native</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>方法是否为abstract</td></tr><tr><td>ACC_STRICTFP</td><td>0x0800</td><td>方法是否为strictfp</td></tr><tr><td>SYNTHETIC</td><td>0x1000</td><td>方法由编译器自动产生</td></tr></tbody></table><p>那么这里大家可能会有疑问，方法里的java代码去哪了呢？ 答案就是在方法表的属性表集合中，有一个<code>code</code>属性，那里存放了编译成字节码的Java代码。对于属性表，在下文会提到</p><h3 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h3><p>属性表，前文已经提到了多次。包括<code>Class</code>文件本身，<code>方法表</code>，<code>字段表</code>都有携带自己的属性表集合，用于描述专有场景信息</p><p>并且属性表与<code>Class</code>文件其他数据项要求不同，各个属性不要求严格的顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息</p><p>下面我们来看几个关键属性</p><h4 id="code-属性"><a href="#code-属性" class="headerlink" title="code 属性"></a>code 属性</h4><p>java程序方法体中的代码<code>javac</code>编译器处理后，最终变为字节码子令存储在<code>Code</code>属性内</p><h4 id="Exceptions-属性"><a href="#Exceptions-属性" class="headerlink" title="Exceptions 属性"></a>Exceptions 属性</h4><p>列举方法可能会抛出的异常</p><h4 id="LineNumberTable-属性"><a href="#LineNumberTable-属性" class="headerlink" title="LineNumberTable 属性"></a>LineNumberTable 属性</h4><p>描述java源码行数和字节码行数的对应关系，前者是字节码行，后者是源码行</p><h4 id="LocalVariableTable-属性"><a href="#LocalVariableTable-属性" class="headerlink" title="LocalVariableTable 属性"></a>LocalVariableTable 属性</h4><p>描述栈局部变量和源码中定义的变量的关系.这项是可选的，可使用<code>javac -g:none</code>或<code>javac -g:vars</code>命令关闭生成这项信息</p><h4 id="SourceFile-属性"><a href="#SourceFile-属性" class="headerlink" title="SourceFile 属性"></a>SourceFile 属性</h4><p>用于记录Class源码文件的文件名称，这个属性是可选的。可使用<code>javac -g:none</code>或<code>javac -g:source</code>命令关闭生成这项信息</p><h4 id="ConstantValue-属性"><a href="#ConstantValue-属性" class="headerlink" title="ConstantValue 属性"></a>ConstantValue 属性</h4><p>通知虚拟机为静态变量赋值</p><h4 id="InnerClasses-属性"><a href="#InnerClasses-属性" class="headerlink" title="InnerClasses 属性"></a>InnerClasses 属性</h4><p>用于记录内部类与宿主类之间的关系</p><h4 id="Deprecated-Synthetic-属性"><a href="#Deprecated-Synthetic-属性" class="headerlink" title="Deprecated Synthetic 属性"></a>Deprecated Synthetic 属性</h4><p><code>Deprecated</code> 标识某个类，字段或方法过期<br><code>Synthetic</code> 标识此字段不由Java源码直接产生，由编译器自动添加</p><h4 id="StackMapTable-属性"><a href="#StackMapTable-属性" class="headerlink" title="StackMapTable 属性"></a>StackMapTable 属性</h4><p>这个属性会在虚拟机加载完字节码后的验证阶段被使用</p><h4 id="Signature-属性"><a href="#Signature-属性" class="headerlink" title="Signature 属性"></a>Signature 属性</h4><p><code>Signature</code>在<code>JDK1.5</code>之后被添加，用于记录泛型签名信息。之所以要用这么一个属性去记录泛型信息，是因为Java语言的泛型采用的是擦除法实现的伪泛型，在<code>Code</code>属性中，泛型信息在编译之后统统都被擦除掉了。使用的擦除法的原因是这样子实现比较简单，只需要修改<code>javac</code>编译器就可以实现了，运行时也可以节省一些空间。坏处就是运行时无法拿到泛型信息。<code>Signature</code>就是为了弥补这个缺陷而设置的，现在的Java API反射能够获取到的泛型信息也来自这个属性</p><h4 id="BootStrapMathods-属性"><a href="#BootStrapMathods-属性" class="headerlink" title="BootStrapMathods 属性"></a>BootStrapMathods 属性</h4><p><code>BootStrapMathods</code>是JDK 1.7之后增加到规范中的，这个属性用于保存<code>invokedynamic</code>指令引用的引导方法限定符。本篇文章暂不赘述这个指令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;我们都知道java是跨平台的，原因就在于各个平台的java虚拟机可以载入和执行同一种平台无关的字节码文件，也就是说java虚拟机不与包括Ja
      
    
    </summary>
    
      <category term="java基础" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JVM" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/"/>
    
      <category term="java字节码" scheme="http://wangjunnan.github.io/categories/java%E5%9F%BA%E7%A1%80/JVM/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
    
      <category term="JVM" scheme="http://wangjunnan.github.io/tags/JVM/"/>
    
      <category term="java字节码" scheme="http://wangjunnan.github.io/tags/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
</feed>
