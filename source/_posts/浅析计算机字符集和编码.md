---
title: 浅析计算机字符集和编码
tags:
  - 编码
categories:
  - java基础
  - 编码
date: 2017-09-14 16:10:33
---

## 什么是字符集呢？
我们知道，在计算机内部，所有信息都是二进制表示的，二进制对于计算机来说是极为重要的，可以想象成一个开关的闭开信号，只有 `0 1`两种状态。计算机中 8个二进制（`8位`）代表一个字节，也就是说一个字节可以代表256种可能，于是上个世纪60年代，美国制定了一套字符集，对英语字符与二进制位之间的关系，做了统一规定。这被称为`ASCII`码，一直沿用至今，ASCII码一共规定了128个字符的编码，比如空格"SPACE"是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。

英语用128个字符就够了，但是世界上还有各种各样的语言字符，如中文，就有上万个。这样子，即使是256个也不够用，而且也无法统一。比如，一个二进制数可能会对应着各个国家不同的符号，这样子我们打开一个文件，如果不知道这个文件的编码方式，那就会乱码，完全看不懂。

这样子，`Unicode` 字符集就出现了，它将世界上所有的字符都纳入其中了，在`unicode`字符集中，每一个符号都对应着一个独一无二的编码,如`4E25`表示汉字`严`

### Unicode的问题

**需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储**。
比如，汉字`严`的`unicode`是十六进制数`4E25`，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。
这里就有两个严重的问题：
* 第一个问题是，如何才能区别`Unicode`和`ASCII`？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？
* 第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果`Unicode`统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。

它们造成的结果是：
 * 出现了`Unicode`的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。
* `Unicode`在很长一段时间内无法推广，直到互联网的出现。


### 编码和字符集的区别

如上文所说，符号集只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储，而编码则可以说是指定字符集的具体实现方式，如 `UTF-8`，`UTF-16`就是`Unicode`字符集的实现方式

### UTF-8
互联网的普及，强烈要求出现一种统一的编码方式。`UTF-8`就是在互联网上使用最广的一种`Unicode`的实现方式。其他实现方式还包括`UTF-16`（字符用两个字节或四个字节表示）和`UTF-32`（字符用四个字节表示），不过在互联网上基本不用。**重复一遍，这里的关系是，`UTF-8`是`Unicode`的实现方式之一。**
`UTF-8`最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。
`UTF-8`的编码规则很简单，只有二条：
  * 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
  * 对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。

##### 下表总结了编码规则，字母x表示可用编码的位。

Unicode符号范围(十六进制)  |  UTF-8编码方式（二进制）
--- | --- 
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。
下面，还是以汉字`严`为例，演示如何实现UTF-8编码。
已知`严`的unicode是`4E25（100111000100101）`，根据上表，可以发现`4E25`处在第三行的范围内（`0000 0800-0000 FFFF`），因此`严`的UTF-8编码需要三个字节，即格式是`1110xxxx 10xxxxxx 10xxxxxx`。然后，从`严`的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，`严`的UTF-8编码是`11100100 10111000 10100101`，转换成十六进制就是`E4B8A5`。
##### Little endian和Big endian
Unicode码可以采用两个字节格式直接存储。以汉字`严`为例，Unicode码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。
因此，第一个字节在前，就是`"大头方式"（Big endian）`，第二个字节在前就是`"小头方式"（Little endian）`。
那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？
Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符（`BOM头`），这个字符的名字叫做"零宽度非换行空格"（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。
如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。
